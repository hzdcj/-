; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc


PUBLIC	??_C@_0CE@OOHDBGBA@Exceeded?5stackLimit?5in?5readValue@ ; `string'
PUBLIC	??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ ; `string'
PUBLIC	??_C@_03FFDNHNKN@rue?$AA@			; `string'
PUBLIC	??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ ; `string'
PUBLIC	??_C@_03KNPGGKC@ull?$AA@			; `string'
PUBLIC	??_C@_04KCECFHEP@alse?$AA@			; `string'
PUBLIC	??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ ; `string'
PUBLIC	??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ ; `string'
PUBLIC	??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ ; `string'
PUBLIC	??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ ; `string'
PUBLIC	??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ ; `string'
PUBLIC	??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ ; `string'
PUBLIC	??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ ; `string'
PUBLIC	??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_02KAOAMBHJ@?$CK?5?$AA@			; `string'
PUBLIC	??_C@_04JBAOJHKB@See?5?$AA@			; `string'
PUBLIC	??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@	; `string'
PUBLIC	??_C@_07FFAIMGME@nfinity?$AA@			; `string'
PUBLIC	??_C@_0CH@OHPLAFOE@Extra?5non?9whitespace?5after?5JSON?5@ ; `string'
PUBLIC	??_C@_0BC@PJPJEKBD@keylength?5?$DO?$DN?52?$FO30?$AA@ ; `string'
PUBLIC	??_C@_02CHFBOFHB@aN?$AA@			; `string'
PUBLIC	??_C@_0BN@MIBOPDFC@Unable?5to?5parse?5token?5length?$AA@ ; `string'
PUBLIC	??_C@_0BB@BCJBKKDP@Duplicate?5key?3?5?8?$AA@	; `string'
PUBLIC	??_C@_0BA@MMGBJGAD@collectComments?$AA@		; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf?$AA@			; `string'
PUBLIC	??_C@_0L@BOEIFNHO@strictRoot?$AA@		; `string'
PUBLIC	??_C@_0O@DMCAHIJE@allowComments?$AA@		; `string'
PUBLIC	??_C@_0BB@CACNEFJM@allowNumericKeys?$AA@	; `string'
PUBLIC	??_C@_0BN@FGKEHPGK@allowDroppedNullPlaceholders?$AA@ ; `string'
PUBLIC	??_C@_0L@LJHGMJAL@stackLimit?$AA@		; `string'
PUBLIC	??_C@_0BC@IPFEJEO@allowSingleQuotes?$AA@	; `string'
PUBLIC	??_C@_0O@CGKMCCPN@rejectDupKeys?$AA@		; `string'
PUBLIC	??_C@_0M@MCPHKFFB@failIfExtra?$AA@		; `string'
PUBLIC	??_C@_0BG@PKNPKJIB@Error?5from?5reader?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BD@EAKIPOJB@allowSpecialFloats?$AA@	; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AVCharReaderBuilder@Json@@@8		; Json::CharReaderBuilder `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@CharReaderBuilder@Json@@8		; Json::CharReaderBuilder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_R4CharReader@Json@@6B@			; Json::CharReader::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4Factory@CharReader@Json@@6B@		; Json::CharReader::Factory::`RTTI Complete Object Locator'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_7Factory@CharReader@Json@@6B@		; Json::CharReader::Factory::`vftable'
PUBLIC	??_R3CharReader@Json@@8				; Json::CharReader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVFactory@CharReader@Json@@@8		; Json::CharReader::Factory `RTTI Type Descriptor'
PUBLIC	??_R2Factory@CharReader@Json@@8			; Json::CharReader::Factory::`RTTI Base Class Array'
PUBLIC	??_7OurCharReader@Json@@6B@			; Json::OurCharReader::`vftable'
PUBLIC	??_R2CharReaderBuilder@Json@@8			; Json::CharReaderBuilder::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CharReader@Json@@8		; Json::CharReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3OurCharReader@Json@@8			; Json::OurCharReader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3CharReaderBuilder@Json@@8			; Json::CharReaderBuilder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@OurCharReader@Json@@8		; Json::OurCharReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCharReader@Json@@@8			; Json::CharReader `RTTI Type Descriptor'
PUBLIC	??_R0?AVOurCharReader@Json@@@8			; Json::OurCharReader `RTTI Type Descriptor'
PUBLIC	??_R4CharReaderBuilder@Json@@6B@		; Json::CharReaderBuilder::`RTTI Complete Object Locator'
PUBLIC	??_R2CharReader@Json@@8				; Json::CharReader::`RTTI Base Class Array'
PUBLIC	??_7CharReaderBuilder@Json@@6B@			; Json::CharReaderBuilder::`vftable'
PUBLIC	??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3Factory@CharReader@Json@@8			; Json::CharReader::Factory::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@Factory@CharReader@Json@@8	; Json::CharReader::Factory::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4OurCharReader@Json@@6B@			; Json::OurCharReader::`RTTI Complete Object Locator'
PUBLIC	??_R2OurCharReader@Json@@8			; Json::OurCharReader::`RTTI Base Class Array'
PUBLIC	??_7CharReader@Json@@6B@			; Json::CharReader::`vftable'
EXTRN	__imp_??0_Container_base12@std@@QEAA@XZ:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:PROC
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@AEAN@Z:PROC
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp__Inf:BYTE
EXTRN	__imp__Nan:BYTE
EXTRN	__imp_localeconv:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	__imp_sscanf:PROC
EXTRN	__imp_??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@:BYTE
;	COMDAT ??_7CharReader@Json@@6B@
CONST	SEGMENT
??_7CharReader@Json@@6B@ DQ FLAT:??_R4CharReader@Json@@6B@ ; Json::CharReader::`vftable'
	DQ	FLAT:??_ECharReader@Json@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT ??_R2OurCharReader@Json@@8
rdata$r	SEGMENT
??_R2OurCharReader@Json@@8 DD imagerel ??_R1A@?0A@EA@OurCharReader@Json@@8 ; Json::OurCharReader::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@CharReader@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4OurCharReader@Json@@6B@
rdata$r	SEGMENT
??_R4OurCharReader@Json@@6B@ DD 01H			; Json::OurCharReader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVOurCharReader@Json@@@8
	DD	imagerel ??_R3OurCharReader@Json@@8
	DD	imagerel ??_R4OurCharReader@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Factory@CharReader@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Factory@CharReader@Json@@8 DD imagerel ??_R0?AVFactory@CharReader@Json@@@8 ; Json::CharReader::Factory::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Factory@CharReader@Json@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	088H
CONST	ENDS
;	COMDAT ??_R3Factory@CharReader@Json@@8
rdata$r	SEGMENT
??_R3Factory@CharReader@Json@@8 DD 00H			; Json::CharReader::Factory::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2Factory@CharReader@Json@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_7CharReaderBuilder@Json@@6B@
CONST	SEGMENT
??_7CharReaderBuilder@Json@@6B@ DQ FLAT:??_R4CharReaderBuilder@Json@@6B@ ; Json::CharReaderBuilder::`vftable'
	DQ	FLAT:??_ECharReaderBuilder@Json@@UEAAPEAXI@Z
	DQ	FLAT:?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ
CONST	ENDS
;	COMDAT ??_R2CharReader@Json@@8
rdata$r	SEGMENT
??_R2CharReader@Json@@8 DD imagerel ??_R1A@?0A@EA@CharReader@Json@@8 ; Json::CharReader::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4CharReaderBuilder@Json@@6B@
rdata$r	SEGMENT
??_R4CharReaderBuilder@Json@@6B@ DD 01H			; Json::CharReaderBuilder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVCharReaderBuilder@Json@@@8
	DD	imagerel ??_R3CharReaderBuilder@Json@@8
	DD	imagerel ??_R4CharReaderBuilder@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVOurCharReader@Json@@@8
data$r	SEGMENT
??_R0?AVOurCharReader@Json@@@8 DQ FLAT:??_7type_info@@6B@ ; Json::OurCharReader `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVOurCharReader@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVCharReader@Json@@@8
data$r	SEGMENT
??_R0?AVCharReader@Json@@@8 DQ FLAT:??_7type_info@@6B@	; Json::CharReader `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVCharReader@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@OurCharReader@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@OurCharReader@Json@@8 DD imagerel ??_R0?AVOurCharReader@Json@@@8 ; Json::OurCharReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3OurCharReader@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3CharReaderBuilder@Json@@8
rdata$r	SEGMENT
??_R3CharReaderBuilder@Json@@8 DD 00H			; Json::CharReaderBuilder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2CharReaderBuilder@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3OurCharReader@Json@@8
rdata$r	SEGMENT
??_R3OurCharReader@Json@@8 DD 00H			; Json::OurCharReader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2OurCharReader@Json@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CharReader@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CharReader@Json@@8 DD imagerel ??_R0?AVCharReader@Json@@@8 ; Json::CharReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CharReader@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2CharReaderBuilder@Json@@8
rdata$r	SEGMENT
??_R2CharReaderBuilder@Json@@8 DD imagerel ??_R1A@?0A@EA@CharReaderBuilder@Json@@8 ; Json::CharReaderBuilder::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Factory@CharReader@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7OurCharReader@Json@@6B@
CONST	SEGMENT
??_7OurCharReader@Json@@6B@ DQ FLAT:??_R4OurCharReader@Json@@6B@ ; Json::OurCharReader::`vftable'
	DQ	FLAT:??_EOurCharReader@Json@@UEAAPEAXI@Z
	DQ	FLAT:?parse@OurCharReader@Json@@UEAA_NPEBD0PEAVValue@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
CONST	ENDS
;	COMDAT ??_R2Factory@CharReader@Json@@8
rdata$r	SEGMENT
??_R2Factory@CharReader@Json@@8 DD imagerel ??_R1A@?0A@EA@Factory@CharReader@Json@@8 ; Json::CharReader::Factory::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVFactory@CharReader@Json@@@8
data$r	SEGMENT
??_R0?AVFactory@CharReader@Json@@@8 DQ FLAT:??_7type_info@@6B@ ; Json::CharReader::Factory `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVFactory@CharReader@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R3CharReader@Json@@8
rdata$r	SEGMENT
??_R3CharReader@Json@@8 DD 00H				; Json::CharReader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2CharReader@Json@@8
rdata$r	ENDS
;	COMDAT ??_7Factory@CharReader@Json@@6B@
CONST	SEGMENT
??_7Factory@CharReader@Json@@6B@ DQ FLAT:??_R4Factory@CharReader@Json@@6B@ ; Json::CharReader::Factory::`vftable'
	DQ	FLAT:??_EFactory@CharReader@Json@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4Factory@CharReader@Json@@6B@
rdata$r	SEGMENT
??_R4Factory@CharReader@Json@@6B@ DD 01H		; Json::CharReader::Factory::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVFactory@CharReader@Json@@@8
	DD	imagerel ??_R3Factory@CharReader@Json@@8
	DD	imagerel ??_R4Factory@CharReader@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 01H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	088H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	imagerel ??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
	DD	imagerel ??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4CharReader@Json@@6B@
rdata$r	SEGMENT
??_R4CharReader@Json@@6B@ DD 01H			; Json::CharReader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVCharReader@Json@@@8
	DD	imagerel ??_R3CharReader@Json@@8
	DD	imagerel ??_R4CharReader@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DQ FLAT:??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DQ	FLAT:??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CharReaderBuilder@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CharReaderBuilder@Json@@8 DD imagerel ??_R0?AVCharReaderBuilder@Json@@@8 ; Json::CharReaderBuilder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CharReaderBuilder@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCharReaderBuilder@Json@@@8
data$r	SEGMENT
??_R0?AVCharReaderBuilder@Json@@@8 DQ FLAT:??_7type_info@@6B@ ; Json::CharReaderBuilder `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVCharReaderBuilder@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allo'
	DB	'cator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EAKIPOJB@allowSpecialFloats?$AA@
CONST	SEGMENT
??_C@_0BD@EAKIPOJB@allowSpecialFloats?$AA@ DB 'allowSpecialFloats', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PKNPKJIB@Error?5from?5reader?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BG@PKNPKJIB@Error?5from?5reader?3?5?$CFs?$AA@ DB 'Error from reade'
	DB	'r: %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MCPHKFFB@failIfExtra?$AA@
CONST	SEGMENT
??_C@_0M@MCPHKFFB@failIfExtra?$AA@ DB 'failIfExtra', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CGKMCCPN@rejectDupKeys?$AA@
CONST	SEGMENT
??_C@_0O@CGKMCCPN@rejectDupKeys?$AA@ DB 'rejectDupKeys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IPFEJEO@allowSingleQuotes?$AA@
CONST	SEGMENT
??_C@_0BC@IPFEJEO@allowSingleQuotes?$AA@ DB 'allowSingleQuotes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LJHGMJAL@stackLimit?$AA@
CONST	SEGMENT
??_C@_0L@LJHGMJAL@stackLimit?$AA@ DB 'stackLimit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FGKEHPGK@allowDroppedNullPlaceholders?$AA@
CONST	SEGMENT
??_C@_0BN@FGKEHPGK@allowDroppedNullPlaceholders?$AA@ DB 'allowDroppedNull'
	DB	'Placeholders', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CACNEFJM@allowNumericKeys?$AA@
CONST	SEGMENT
??_C@_0BB@CACNEFJM@allowNumericKeys?$AA@ DB 'allowNumericKeys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMCAHIJE@allowComments?$AA@
CONST	SEGMENT
??_C@_0O@DMCAHIJE@allowComments?$AA@ DB 'allowComments', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BOEIFNHO@strictRoot?$AA@
CONST	SEGMENT
??_C@_0L@BOEIFNHO@strictRoot?$AA@ DB 'strictRoot', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf?$AA@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf?$AA@ DB '%lf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MMGBJGAD@collectComments?$AA@
CONST	SEGMENT
??_C@_0BA@MMGBJGAD@collectComments?$AA@ DB 'collectComments', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BCJBKKDP@Duplicate?5key?3?5?8?$AA@
CONST	SEGMENT
??_C@_0BB@BCJBKKDP@Duplicate?5key?3?5?8?$AA@ DB 'Duplicate key: ''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MIBOPDFC@Unable?5to?5parse?5token?5length?$AA@
CONST	SEGMENT
??_C@_0BN@MIBOPDFC@Unable?5to?5parse?5token?5length?$AA@ DB 'Unable to pa'
	DB	'rse token length', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CHFBOFHB@aN?$AA@
CONST	SEGMENT
??_C@_02CHFBOFHB@aN?$AA@ DB 'aN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PJPJEKBD@keylength?5?$DO?$DN?52?$FO30?$AA@
CONST	SEGMENT
??_C@_0BC@PJPJEKBD@keylength?5?$DO?$DN?52?$FO30?$AA@ DB 'keylength >= 2^3'
	DB	'0', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OHPLAFOE@Extra?5non?9whitespace?5after?5JSON?5@
CONST	SEGMENT
??_C@_0CH@OHPLAFOE@Extra?5non?9whitespace?5after?5JSON?5@ DB 'Extra non-w'
	DB	'hitespace after JSON value.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FFAIMGME@nfinity?$AA@
CONST	SEGMENT
??_C@_07FFAIMGME@nfinity?$AA@ DB 'nfinity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
CONST	SEGMENT
??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@ DB ' for detail.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JBAOJHKB@See?5?$AA@
CONST	SEGMENT
??_C@_04JBAOJHKB@See?5?$AA@ DB 'See ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAOAMBHJ@?$CK?5?$AA@
CONST	SEGMENT
??_C@_02KAOAMBHJ@?$CK?5?$AA@ DB '* ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: hexadecimal digit expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ DB 'Line %d, Column '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
CONST	SEGMENT
??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ DB 'expecting '
	DB	'another \u token to begin the second half of a unicode surrog'
	DB	'ate pair', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: four digits expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ DB 'Bad escape '
	DB	'sequence in string', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
CONST	SEGMENT
??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ DB 'additional si'
	DB	'x characters expected to parse unicode surrogate pair.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
CONST	SEGMENT
??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ DB ''' is not a number.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ DB 'Empty esc'
	DB	'ape sequence in string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
CONST	SEGMENT
??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ DB 'Missin'
	DB	'g ''}'' or object member name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
CONST	SEGMENT
??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ DB 'Mi'
	DB	'ssing '','' or '']'' in array declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
CONST	SEGMENT
??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ DB 'Missing '
	DB	''':'' after object member name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
CONST	SEGMENT
??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ DB 'Mi'
	DB	'ssing '','' or ''}'' in object declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCECFHEP@alse?$AA@
CONST	SEGMENT
??_C@_04KCECFHEP@alse?$AA@ DB 'alse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KNPGGKC@ull?$AA@
CONST	SEGMENT
??_C@_03KNPGGKC@ull?$AA@ DB 'ull', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
CONST	SEGMENT
??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ DB 'Syntax err'
	DB	'or: value, object or array expected.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFDNHNKN@rue?$AA@
CONST	SEGMENT
??_C@_03FFDNHNKN@rue?$AA@ DB 'rue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
CONST	SEGMENT
??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ DB 'A valid JS'
	DB	'ON document must be either an array or an object value.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OOHDBGBA@Exceeded?5stackLimit?5in?5readValue@
CONST	SEGMENT
??_C@_0CE@OOHDBGBA@Exceeded?5stackLimit?5in?5readValue@ DB 'Exceeded stac'
	DB	'kLimit in readValue().', 00H		; `string'
CONST	ENDS
PUBLIC	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??_GErrorInfo@OurReader@Json@@QEAAPEAXI@Z	; Json::OurReader::ErrorInfo::`scalar deleting destructor'
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Fill_n@PEAPEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@_KAEBQEAPEAV12@@Z ; std::_Fill_n<Json::Value * __ptr64 * __ptr64 * __ptr64,unsigned __int64,Json::Value * __ptr64 * __ptr64>
PUBLIC	??$_Uninit_copy@PEAPEAVValue@Json@@PEAPEAV12@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64>
PUBLIC	??$destroy@PEAVErrorInfo@OurReader@Json@@@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@@Z ; std::allocator<Json::OurReader::ErrorInfo>::destroy<Json::OurReader::ErrorInfo * __ptr64>
PUBLIC	??$_Fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@_KAEBQEAV123@@Z ; std::_Fill_n<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,Json::OurReader::ErrorInfo * __ptr64>
PUBLIC	??$_Uninit_copy@PEAVErrorInfo@OurReader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::OurReader::ErrorInfo * __ptr64,Json::OurReader::ErrorInfo * __ptr64>
PUBLIC	??$destroy@VErrorInfo@OurReader@Json@@@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z ; std::allocator<Json::OurReader::ErrorInfo>::destroy<Json::OurReader::ErrorInfo>
PUBLIC	??$_Fill_n@PEAPEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@_KAEBQEAV123@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,Json::Reader::ErrorInfo * __ptr64>
PUBLIC	??$_Uninit_copy@PEAVErrorInfo@Reader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo * __ptr64,Json::Reader::ErrorInfo * __ptr64>
PUBLIC	??$construct@PEAVValue@Json@@PEAV12@@?$allocator@PEAVValue@Json@@@std@@QEAAXPEAPEAVValue@Json@@$$QEAPEAV23@@Z ; std::allocator<Json::Value * __ptr64>::construct<Json::Value * __ptr64,Json::Value * __ptr64>
PUBLIC	??0ErrorInfo@OurReader@Json@@QEAA@AEBV012@@Z	; Json::OurReader::ErrorInfo::ErrorInfo
PUBLIC	??0ErrorInfo@Reader@Json@@QEAA@AEBV012@@Z	; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z ; std::allocator<Json::OurReader::ErrorInfo>::construct
PUBLIC	?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z ; std::allocator<Json::OurReader::ErrorInfo>::construct
PUBLIC	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct
PUBLIC	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct
PUBLIC	??$construct@VErrorInfo@OurReader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@@Z ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::construct<Json::OurReader::ErrorInfo>
PUBLIC	??$construct@VErrorInfo@Reader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@Reader@Json@@@1@PEAVErrorInfo@Reader@Json@@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@$$QEAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QEAU_Container_proxy@0@AEAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >
PUBLIC	??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::Value * __ptr64 * __ptr64,unsigned __int64,Json::Value * __ptr64 * __ptr64>
PUBLIC	??$_Ptr_cat@PEAPEAVValue@Json@@PEAPEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAPEAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64>
PUBLIC	??$_Val_type@PEAPEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@@Z ; std::_Val_type<Json::Value * __ptr64 * __ptr64 * __ptr64>
PUBLIC	??$_Rechecked@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@@std@@YAAEAPEAPEAPEAVValue@Json@@AEAPEAPEAPEAV12@PEAPEAPEAV12@@Z ; std::_Rechecked<Json::Value * __ptr64 * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64 * __ptr64>
PUBLIC	??$_Uninit_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z ; std::_Uninit_copy<Json::Value * __ptr64 * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >
PUBLIC	??$_Unchecked@PEAPEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@@Z ; std::_Unchecked<Json::Value * __ptr64 * __ptr64 * __ptr64>
PUBLIC	??$destroy@PEAVErrorInfo@OurReader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAPEAVErrorInfo@OurReader@Json@@@Z ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >
PUBLIC	??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::OurReader::ErrorInfo * __ptr64,unsigned __int64,Json::OurReader::ErrorInfo * __ptr64>
PUBLIC	??$_Ptr_cat@PEAVErrorInfo@OurReader@Json@@PEAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVErrorInfo@OurReader@Json@@0@Z ; std::_Ptr_cat<Json::OurReader::ErrorInfo * __ptr64,Json::OurReader::ErrorInfo * __ptr64>
PUBLIC	??$_Val_type@PEAPEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@Z ; std::_Val_type<Json::OurReader::ErrorInfo * __ptr64 * __ptr64>
PUBLIC	??$_Rechecked@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@std@@YAAEAPEAPEAVErrorInfo@OurReader@Json@@AEAPEAPEAV123@PEAPEAV123@@Z ; std::_Rechecked<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,Json::OurReader::ErrorInfo * __ptr64 * __ptr64>
PUBLIC	??$_Uninit_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z ; std::_Uninit_copy<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,Json::OurReader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >
PUBLIC	??$_Unchecked@PEAPEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@Z ; std::_Unchecked<Json::OurReader::ErrorInfo * __ptr64 * __ptr64>
PUBLIC	??$?0VErrorInfo@OurReader@Json@@@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAA@AEBV?$allocator@VErrorInfo@OurReader@Json@@@1@@Z ; std::allocator<Json::OurReader::ErrorInfo * __ptr64>::allocator<Json::OurReader::ErrorInfo * __ptr64><Json::OurReader::ErrorInfo>
PUBLIC	??$destroy@VErrorInfo@OurReader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@@Z ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >
PUBLIC	??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo * __ptr64,unsigned __int64,Json::Reader::ErrorInfo * __ptr64>
PUBLIC	??$_Ptr_cat@PEAVErrorInfo@Reader@Json@@PEAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo * __ptr64,Json::Reader::ErrorInfo * __ptr64>
PUBLIC	??$_Val_type@PEAPEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@Z ; std::_Val_type<Json::Reader::ErrorInfo * __ptr64 * __ptr64>
PUBLIC	??$_Rechecked@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@std@@YAAEAPEAPEAVErrorInfo@Reader@Json@@AEAPEAPEAV123@PEAPEAV123@@Z ; std::_Rechecked<Json::Reader::ErrorInfo * __ptr64 * __ptr64,Json::Reader::ErrorInfo * __ptr64 * __ptr64>
PUBLIC	??$_Uninit_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo * __ptr64 * __ptr64,Json::Reader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >
PUBLIC	??$_Unchecked@PEAPEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@Z ; std::_Unchecked<Json::Reader::ErrorInfo * __ptr64 * __ptr64>
PUBLIC	??$construct@PEAVValue@Json@@PEAV12@@?$allocator_traits@V?$allocator@PEAVValue@Json@@@std@@@std@@SAXAEAV?$allocator@PEAVValue@Json@@@1@PEAPEAVValue@Json@@$$QEAPEAV34@@Z ; std::allocator_traits<std::allocator<Json::Value * __ptr64> >::construct<Json::Value * __ptr64,Json::Value * __ptr64>
PUBLIC	??$construct@VErrorInfo@OurReader@Json@@AEBV123@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@AEBV345@@Z ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::construct<Json::OurReader::ErrorInfo,Json::OurReader::ErrorInfo const & __ptr64>
PUBLIC	??$forward@AEBVErrorInfo@OurReader@Json@@@std@@YAAEBVErrorInfo@OurReader@Json@@AEBV123@@Z ; std::forward<Json::OurReader::ErrorInfo const & __ptr64>
PUBLIC	??$construct@VErrorInfo@Reader@Json@@AEBV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@Reader@Json@@@1@PEAVErrorInfo@Reader@Json@@AEBV345@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const & __ptr64>
PUBLIC	??$forward@AEBVErrorInfo@Reader@Json@@@std@@YAAEBVErrorInfo@Reader@Json@@AEBV123@@Z ; std::forward<Json::Reader::ErrorInfo const & __ptr64>
PUBLIC	?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::construct
PUBLIC	?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z ; std::_Allocate<std::_Container_proxy>
PUBLIC	??$_Allocate@PEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@_KPEAPEAPEAV12@@Z ; std::_Allocate<Json::Value * __ptr64 * __ptr64>
PUBLIC	??$_Allocate@PEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@_KPEAPEAV123@@Z ; std::_Allocate<Json::OurReader::ErrorInfo * __ptr64>
PUBLIC	??$_Allocate@PEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@_KPEAPEAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo * __ptr64>
PUBLIC	??$_Allocate@PEAVValue@Json@@@std@@YAPEAPEAVValue@Json@@_KPEAPEAV12@@Z ; std::_Allocate<Json::Value * __ptr64>
PUBLIC	??$_Allocate@VErrorInfo@OurReader@Json@@@std@@YAPEAVErrorInfo@OurReader@Json@@_KPEAV123@@Z ; std::_Allocate<Json::OurReader::ErrorInfo>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPEAVErrorInfo@Reader@Json@@_KPEAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Value * __ptr64 * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >
PUBLIC	??$_Uninitialized_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Value * __ptr64 * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >
PUBLIC	??$destroy@PEAVErrorInfo@OurReader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >
PUBLIC	??$_Uninitialized_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,Json::OurReader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> >::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> ><std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> > >
PUBLIC	??$destroy@VErrorInfo@OurReader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >
PUBLIC	??$_Uninitialized_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * __ptr64 * __ptr64,Json::Reader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >
PUBLIC	??$construct@PEAVValue@Json@@PEAV12@@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAXPEAPEAVValue@Json@@$$QEAPEAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64> >::construct<Json::Value * __ptr64,Json::Value * __ptr64>
PUBLIC	??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z ; std::forward<Json::Value * __ptr64>
PUBLIC	??$construct@VErrorInfo@OurReader@Json@@AEBV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV234@@Z ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::construct<Json::OurReader::ErrorInfo,Json::OurReader::ErrorInfo const & __ptr64>
PUBLIC	??$emplace_back@$$$V@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::emplace_back<>
PUBLIC	??$construct@VErrorInfo@Reader@Json@@AEBV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV234@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const & __ptr64>
PUBLIC	??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>
PUBLIC	??$move@AEAPEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z ; std::move<Json::Value * __ptr64 & __ptr64>
PUBLIC	?max_size@?$allocator@PEAVValue@Json@@@std@@QEBA_KXZ ; std::allocator<Json::Value * __ptr64>::max_size
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Setcont
PUBLIC	?max_size@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEBA_KXZ ; std::allocator<Json::OurReader::ErrorInfo>::max_size
PUBLIC	?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QEBA_KXZ ; std::allocator<Json::Reader::ErrorInfo>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PEAVValue@Json@@@std@@@std@@SA_KAEBV?$allocator@PEAVValue@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::Value * __ptr64> >::max_size
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
PUBLIC	??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator+=
PUBLIC	?max_size@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SA_KAEBV?$allocator@VErrorInfo@OurReader@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA_KAEBV?$allocator@VErrorInfo@Reader@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	?allocate@?$allocator@PEAPEAVValue@Json@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z ; std::allocator<Json::Value * __ptr64 * __ptr64>::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBAAEBQEAVValue@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator*
PUBLIC	??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-=
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
PUBLIC	?allocate@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z ; std::allocator<Json::OurReader::ErrorInfo * __ptr64>::allocate
PUBLIC	?deallocate@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@_K@Z ; std::allocator<Json::OurReader::ErrorInfo * __ptr64>::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::max_size
PUBLIC	?deallocate@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@_K@Z ; std::allocator<Json::OurReader::ErrorInfo>::deallocate
PUBLIC	?allocate@?$allocator@PEAVErrorInfo@Reader@Json@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z ; std::allocator<Json::Reader::ErrorInfo * __ptr64>::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@QEAA@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> >::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> >::allocate
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::_Alloc_proxy
PUBLIC	?allocate@?$allocator@PEAVValue@Json@@@std@@QEAAPEAPEAVValue@Json@@_K@Z ; std::allocator<Json::Value * __ptr64>::allocate
PUBLIC	?_Xlen@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEBAXXZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Xlen
PUBLIC	?max_size@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::max_size
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
PUBLIC	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
PUBLIC	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBAAEAPEAVValue@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator*
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::_Setcont
PUBLIC	?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::_Compat
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@_K@Z ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> >::deallocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@_K@Z ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >
PUBLIC	?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Free_proxy
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Alloc_proxy
PUBLIC	?allocate@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z ; std::allocator<Json::OurReader::ErrorInfo>::allocate
PUBLIC	?_Xlen@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEBAXXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Xlen
PUBLIC	?empty@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_NXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::empty
PUBLIC	?max_size@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::max_size
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QEAA@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> >::allocate
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAAXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy
PUBLIC	?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z ; std::allocator<Json::Reader::ErrorInfo>::allocate
PUBLIC	?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEBAXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
PUBLIC	?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAPEAPEAVValue@Json@@_K@Z ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64> >::allocate
PUBLIC	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@PEAVValue@Json@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >
PUBLIC	?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Growmap
PUBLIC	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
PUBLIC	??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >::~_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
PUBLIC	??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator==
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_K_K@Z ; std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >::_Getblock
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::allocate
PUBLIC	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Getal
PUBLIC	??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >
PUBLIC	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@OurReader@Json@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >
PUBLIC	??0?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAA@XZ ; std::allocator<Json::OurReader::ErrorInfo>::allocator<Json::OurReader::ErrorInfo>
PUBLIC	?_Tidy@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAXXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Tidy
PUBLIC	?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Growmap
PUBLIC	?pop_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::pop_back
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate
PUBLIC	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
PUBLIC	?back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::back
PUBLIC	?size@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::size
PUBLIC	?push_back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::push_back
PUBLIC	??0?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator!=
PUBLIC	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator++
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBAAEBVErrorInfo@OurReader@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator*
PUBLIC	?clear@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::clear
PUBLIC	?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
PUBLIC	?size@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::size
PUBLIC	?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize
PUBLIC	?end@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::end
PUBLIC	?begin@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::begin
PUBLIC	??1?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::~deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >
PUBLIC	??0?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >
PUBLIC	?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
PUBLIC	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
PUBLIC	?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
PUBLIC	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
PUBLIC	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAA@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	?pop@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAXXZ ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::pop
PUBLIC	?top@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::top
PUBLIC	?size@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEBA_KXZ ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::size
PUBLIC	?empty@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEBA_NXZ ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::empty
PUBLIC	?push@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::push
PUBLIC	??0?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ ; Json::CharReaderBuilder::newCharReader
PUBLIC	??1CharReaderBuilder@Json@@UEAA@XZ		; Json::CharReaderBuilder::~CharReaderBuilder
PUBLIC	??_GCharReaderBuilder@Json@@UEAAPEAXI@Z		; Json::CharReaderBuilder::`scalar deleting destructor'
PUBLIC	??1OurCharReader@Json@@UEAA@XZ			; Json::OurCharReader::~OurCharReader
PUBLIC	??1OurReader@Json@@QEAA@XZ			; Json::OurReader::~OurReader
PUBLIC	??0CharReader@Json@@QEAA@XZ			; Json::CharReader::CharReader
PUBLIC	??_GOurCharReader@Json@@UEAAPEAXI@Z		; Json::OurCharReader::`scalar deleting destructor'
PUBLIC	?parse@OurCharReader@Json@@UEAA_NPEBD0PEAVValue@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::OurCharReader::parse
PUBLIC	??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z ; Json::OurCharReader::OurCharReader
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >
PUBLIC	?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::OurReader::getFormattedErrorMessages
PUBLIC	?getLocationLineAndColumn@OurReader@Json@@AEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z ; Json::OurReader::getLocationLineAndColumn
PUBLIC	?getLocationLineAndColumn@OurReader@Json@@AEBAXPEBDAEAH1@Z ; Json::OurReader::getLocationLineAndColumn
PUBLIC	?getNextChar@OurReader@Json@@AEAADXZ		; Json::OurReader::getNextChar
PUBLIC	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
PUBLIC	?addErrorAndRecover@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z ; Json::OurReader::addErrorAndRecover
PUBLIC	?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z ; Json::OurReader::recoverFromError
PUBLIC	??1ErrorInfo@OurReader@Json@@QEAA@XZ		; Json::OurReader::ErrorInfo::~ErrorInfo
PUBLIC	??0ErrorInfo@OurReader@Json@@QEAA@XZ		; Json::OurReader::ErrorInfo::ErrorInfo
PUBLIC	?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::OurReader::addError
PUBLIC	?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ; Json::OurReader::decodeUnicodeEscapeSequence
PUBLIC	?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ; Json::OurReader::decodeUnicodeCodePoint
PUBLIC	?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::OurReader::decodeString
PUBLIC	?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::decodeString
PUBLIC	?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ; Json::OurReader::decodeDouble
PUBLIC	?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ; Json::OurReader::decodeNumber
PUBLIC	?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::decodeNumber
PUBLIC	?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readArray
PUBLIC	?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readObject
PUBLIC	?readStringSingleQuote@OurReader@Json@@AEAA_NXZ	; Json::OurReader::readStringSingleQuote
PUBLIC	?readString@OurReader@Json@@AEAA_NXZ		; Json::OurReader::readString
PUBLIC	?readNumber@OurReader@Json@@AEAA_N_N@Z		; Json::OurReader::readNumber
PUBLIC	?readCppStyleComment@OurReader@Json@@AEAA_NXZ	; Json::OurReader::readCppStyleComment
PUBLIC	?readCStyleComment@OurReader@Json@@AEAA_NXZ	; Json::OurReader::readCStyleComment
PUBLIC	?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z ; Json::OurReader::addComment
PUBLIC	?readComment@OurReader@Json@@AEAA_NXZ		; Json::OurReader::readComment
PUBLIC	?match@OurReader@Json@@AEAA_NPEBDH@Z		; Json::OurReader::match
PUBLIC	?skipSpaces@OurReader@Json@@AEAAXXZ		; Json::OurReader::skipSpaces
PUBLIC	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
PUBLIC	?skipCommentTokens@OurReader@Json@@AEAAXAEAVToken@12@@Z ; Json::OurReader::skipCommentTokens
PUBLIC	?readValue@OurReader@Json@@AEAA_NXZ		; Json::OurReader::readValue
PUBLIC	?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z ; Json::OurReader::parse
PUBLIC	??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z	; Json::OurReader::OurReader
PUBLIC	?all@OurFeatures@Json@@SA?AV12@XZ		; Json::OurFeatures::all
PUBLIC	?getNextChar@Reader@Json@@AEAADXZ		; Json::Reader::getNextChar
PUBLIC	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ	; Json::Reader::currentValue
PUBLIC	?addErrorAndRecover@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
PUBLIC	?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
PUBLIC	??0ErrorInfo@Reader@Json@@QEAA@XZ		; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::Reader::addError
PUBLIC	?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
PUBLIC	?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ; Json::Reader::decodeUnicodeCodePoint
PUBLIC	?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
PUBLIC	?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::decodeString
PUBLIC	?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ; Json::Reader::decodeDouble
PUBLIC	?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ; Json::Reader::decodeNumber
PUBLIC	?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::decodeNumber
PUBLIC	?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z	; Json::Reader::readArray
PUBLIC	?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z	; Json::Reader::readObject
PUBLIC	?readString@Reader@Json@@AEAA_NXZ		; Json::Reader::readString
PUBLIC	?readNumber@Reader@Json@@AEAAXXZ		; Json::Reader::readNumber
PUBLIC	?readCppStyleComment@Reader@Json@@AEAA_NXZ	; Json::Reader::readCppStyleComment
PUBLIC	?readCStyleComment@Reader@Json@@AEAA_NXZ	; Json::Reader::readCStyleComment
PUBLIC	?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
PUBLIC	?readComment@Reader@Json@@AEAA_NXZ		; Json::Reader::readComment
PUBLIC	?match@Reader@Json@@AEAA_NPEBDH@Z		; Json::Reader::match
PUBLIC	?skipSpaces@Reader@Json@@AEAAXXZ		; Json::Reader::skipSpaces
PUBLIC	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z	; Json::Reader::readToken
PUBLIC	?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z ; Json::Reader::skipCommentTokens
PUBLIC	?readValue@Reader@Json@@AEAA_NXZ		; Json::Reader::readValue
PUBLIC	?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z	; Json::Reader::parse
PUBLIC	?all@Features@Json@@SA?AV12@XZ			; Json::Features::all
PUBLIC	??0Features@Json@@QEAA@XZ			; Json::Features::Features
PUBLIC	??_GFactory@CharReader@Json@@UEAAPEAXI@Z	; Json::CharReader::Factory::`scalar deleting destructor'
PUBLIC	??_GCharReader@Json@@UEAAPEAXI@Z		; Json::CharReader::`scalar deleting destructor'
PUBLIC	??1Factory@CharReader@Json@@UEAA@XZ		; Json::CharReader::Factory::~Factory
PUBLIC	??1CharReader@Json@@UEAA@XZ			; Json::CharReader::~CharReader
PUBLIC	?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	??1_Iterator_base12@std@@QEAA@XZ		; std::_Iterator_base12::~_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??0_Iterator_base12@std@@QEAA@AEBU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QEAA@XZ		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Container_proxy@std@@QEAA@XZ		; std::_Container_proxy::_Container_proxy
PUBLIC	?quiet_NaN@?$numeric_limits@N@std@@SANXZ	; std::numeric_limits<double>::quiet_NaN
PUBLIC	?infinity@?$numeric_limits@N@std@@SANXZ		; std::numeric_limits<double>::infinity
PUBLIC	?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z ; Json::Reader::parse
PUBLIC	??0Reader@Json@@QEAA@XZ				; Json::Reader::Reader
EXTRN	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_ECharReaderBuilder@Json@@UEAAPEAXI@Z:PROC	; Json::CharReaderBuilder::`vector deleting destructor'
EXTRN	??_EOurCharReader@Json@@UEAAPEAXI@Z:PROC	; Json::OurCharReader::`vector deleting destructor'
EXTRN	??_EFactory@CharReader@Json@@UEAAPEAXI@Z:PROC	; Json::CharReader::Factory::`vector deleting destructor'
EXTRN	??_ECharReader@Json@@UEAAPEAXI@Z:PROC		; Json::CharReader::`vector deleting destructor'
_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GErrorInfo@OurReader@Json@@QEAAPEAXI@Z DD imagerel $LN39
	DD	imagerel $LN39+55
	DD	imagerel $unwind$??_GErrorInfo@OurReader@Json@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAPEAVValue@Json@@PEAPEAV12@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Uninit_copy@PEAPEAVValue@Json@@PEAPEAV12@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAVErrorInfo@OurReader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Uninit_copy@PEAVErrorInfo@OurReader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@VErrorInfo@OurReader@Json@@@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z DD imagerel $LN41
	DD	imagerel $LN41+52
	DD	imagerel $unwind$??$destroy@VErrorInfo@OurReader@Json@@@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAVErrorInfo@Reader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Uninit_copy@PEAVErrorInfo@Reader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ErrorInfo@OurReader@Json@@QEAA@AEBV012@@Z DD imagerel $LN47
	DD	imagerel $LN47+94
	DD	imagerel $unwind$??0ErrorInfo@OurReader@Json@@QEAA@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ErrorInfo@Reader@Json@@QEAA@AEBV012@@Z DD imagerel $LN47
	DD	imagerel $LN47+94
	DD	imagerel $unwind$??0ErrorInfo@Reader@Json@@QEAA@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z DD imagerel $LN54
	DD	imagerel $LN54+121
	DD	imagerel $unwind$?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z@4HA DD imagerel ?dtor$0@?0??construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z@4HA
	DD	imagerel ?dtor$0@?0??construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0??construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z DD imagerel $LN54
	DD	imagerel $LN54+121
	DD	imagerel $unwind$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z@4HA DD imagerel ?dtor$0@?0??construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z@4HA
	DD	imagerel ?dtor$0@?0??construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0??construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN13
	DD	imagerel $LN13+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN13+9
	DD	imagerel $LN13+28
	DD	imagerel $chain$0$??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN13+28
	DD	imagerel $LN13+33
	DD	imagerel $chain$1$??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+48
	DD	imagerel $unwind$??$_Uninit_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN13
	DD	imagerel $LN13+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN13+9
	DD	imagerel $LN13+28
	DD	imagerel $chain$0$??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN13+28
	DD	imagerel $LN13+33
	DD	imagerel $chain$1$??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+48
	DD	imagerel $unwind$??$_Uninit_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@VErrorInfo@OurReader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@@Z DD imagerel $LN43
	DD	imagerel $LN43+52
	DD	imagerel $unwind$??$destroy@VErrorInfo@OurReader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN13
	DD	imagerel $LN13+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN13+9
	DD	imagerel $LN13+28
	DD	imagerel $chain$0$??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN13+28
	DD	imagerel $LN13+33
	DD	imagerel $chain$1$??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+48
	DD	imagerel $unwind$??$_Uninit_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z DD imagerel $LN13
	DD	imagerel $LN13+46
	DD	imagerel $unwind$??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@PEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@_KPEAPEAPEAV12@@Z DD imagerel $LN13
	DD	imagerel $LN13+50
	DD	imagerel $unwind$??$_Allocate@PEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@_KPEAPEAPEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@PEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@_KPEAPEAV123@@Z DD imagerel $LN13
	DD	imagerel $LN13+50
	DD	imagerel $unwind$??$_Allocate@PEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@_KPEAPEAV123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@PEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@_KPEAPEAV123@@Z DD imagerel $LN13
	DD	imagerel $LN13+50
	DD	imagerel $unwind$??$_Allocate@PEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@_KPEAPEAV123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@PEAVValue@Json@@@std@@YAPEAPEAVValue@Json@@_KPEAPEAV12@@Z DD imagerel $LN13
	DD	imagerel $LN13+50
	DD	imagerel $unwind$??$_Allocate@PEAVValue@Json@@@std@@YAPEAPEAVValue@Json@@_KPEAPEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@VErrorInfo@OurReader@Json@@@std@@YAPEAVErrorInfo@OurReader@Json@@_KPEAV123@@Z DD imagerel $LN13
	DD	imagerel $LN13+46
	DD	imagerel $unwind$??$_Allocate@VErrorInfo@OurReader@Json@@@std@@YAPEAVErrorInfo@OurReader@Json@@_KPEAV123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPEAVErrorInfo@Reader@Json@@_KPEAV123@@Z DD imagerel $LN13
	DD	imagerel $LN13+46
	DD	imagerel $unwind$??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPEAVErrorInfo@Reader@Json@@_KPEAV123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z DD imagerel $LN19
	DD	imagerel $LN19+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z DD imagerel $LN19+9
	DD	imagerel $LN19+28
	DD	imagerel $chain$0$??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z DD imagerel $LN19+28
	DD	imagerel $LN19+33
	DD	imagerel $chain$1$??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z DD imagerel $LN19
	DD	imagerel $LN19+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z DD imagerel $LN19+9
	DD	imagerel $LN19+28
	DD	imagerel $chain$0$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z DD imagerel $LN19+28
	DD	imagerel $LN19+33
	DD	imagerel $chain$1$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@VErrorInfo@OurReader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z DD imagerel $LN45
	DD	imagerel $LN45+52
	DD	imagerel $unwind$??$destroy@VErrorInfo@OurReader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z DD imagerel $LN19
	DD	imagerel $LN19+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z DD imagerel $LN19+9
	DD	imagerel $LN19+28
	DD	imagerel $chain$0$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z DD imagerel $LN19+28
	DD	imagerel $LN19+33
	DD	imagerel $chain$1$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@$$$V@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ DD imagerel $LN78
	DD	imagerel $LN78+154
	DD	imagerel $unwind$??$emplace_back@$$$V@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ DD imagerel $LN78
	DD	imagerel $LN78+154
	DD	imagerel $unwind$??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+32
	DD	imagerel $unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAPEAVValue@Json@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z DD imagerel $LN12
	DD	imagerel $LN12+57
	DD	imagerel $unwind$?allocate@?$allocator@PEAPEAVValue@Json@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN16
	DD	imagerel $LN16+32
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z DD imagerel $LN12
	DD	imagerel $LN12+57
	DD	imagerel $unwind$?allocate@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAVErrorInfo@Reader@Json@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z DD imagerel $LN12
	DD	imagerel $LN12+57
	DD	imagerel $unwind$?allocate@?$allocator@PEAVErrorInfo@Reader@Json@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+57
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN36
	DD	imagerel $LN36+53
	DD	imagerel $unwind$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAVValue@Json@@@std@@QEAAPEAPEAVValue@Json@@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+32
	DD	imagerel $unwind$?allocate@?$allocator@PEAVValue@Json@@@std@@QEAAPEAPEAVValue@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+57
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+31
	DD	imagerel $unwind$?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN36
	DD	imagerel $LN36+53
	DD	imagerel $unwind$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+32
	DD	imagerel $unwind$?allocate@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+57
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN36
	DD	imagerel $LN36+53
	DD	imagerel $unwind$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+32
	DD	imagerel $unwind$?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAPEAPEAVValue@Json@@_K@Z DD imagerel $LN16
	DD	imagerel $LN16+32
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAPEAPEAVValue@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@PEAVValue@Json@@@1@@Z DD imagerel $LN43
	DD	imagerel $LN43+75
	DD	imagerel $unwind$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@PEAVValue@Json@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169
	DD	imagerel $LN169+74
	DD	imagerel $unwind$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+74
	DD	imagerel $LN169+154
	DD	imagerel $chain$1$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+154
	DD	imagerel $LN169+234
	DD	imagerel $chain$3$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+234
	DD	imagerel $LN169+288
	DD	imagerel $chain$4$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+288
	DD	imagerel $LN169+393
	DD	imagerel $chain$5$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+393
	DD	imagerel $LN169+424
	DD	imagerel $chain$6$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+424
	DD	imagerel $LN169+438
	DD	imagerel $chain$7$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD_K@Z DD imagerel $LN40
	DD	imagerel $LN40+42
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z DD imagerel $LN16
	DD	imagerel $LN16+32
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+31
	DD	imagerel $unwind$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@OurReader@Json@@@1@@Z DD imagerel $LN43
	DD	imagerel $LN43+75
	DD	imagerel $unwind$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@OurReader@Json@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAXXZ DD imagerel $LN83
	DD	imagerel $LN83+194
	DD	imagerel $unwind$?_Tidy@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169
	DD	imagerel $LN169+77
	DD	imagerel $unwind$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+77
	DD	imagerel $LN169+151
	DD	imagerel $chain$1$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+151
	DD	imagerel $LN169+231
	DD	imagerel $chain$3$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+231
	DD	imagerel $LN169+285
	DD	imagerel $chain$4$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+285
	DD	imagerel $LN169+390
	DD	imagerel $chain$5$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+390
	DD	imagerel $LN169+421
	DD	imagerel $chain$6$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+421
	DD	imagerel $LN169+435
	DD	imagerel $chain$7$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ DD imagerel $LN52
	DD	imagerel $LN52+97
	DD	imagerel $unwind$?pop_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN533
	DD	imagerel $LN533+389
	DD	imagerel $unwind$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel $LN43
	DD	imagerel $LN43+59
	DD	imagerel $unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z DD imagerel $LN16
	DD	imagerel $LN16+32
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@Reader@Json@@@1@@Z DD imagerel $LN43
	DD	imagerel $LN43+75
	DD	imagerel $unwind$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169
	DD	imagerel $LN169+77
	DD	imagerel $unwind$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+77
	DD	imagerel $LN169+151
	DD	imagerel $chain$1$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+151
	DD	imagerel $LN169+231
	DD	imagerel $chain$3$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+231
	DD	imagerel $LN169+285
	DD	imagerel $chain$4$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+285
	DD	imagerel $LN169+390
	DD	imagerel $chain$5$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+390
	DD	imagerel $LN169+421
	DD	imagerel $chain$6$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD imagerel $LN169+421
	DD	imagerel $LN169+435
	DD	imagerel $chain$7$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ DD imagerel $LN14
	DD	imagerel $LN14+78
	DD	imagerel $unwind$?back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z DD imagerel $LN46
	DD	imagerel $LN46+204
	DD	imagerel $unwind$?push_back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA@XZ DD imagerel $LN49
	DD	imagerel $LN49+75
	DD	imagerel $unwind$??0?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+83
	DD	imagerel $unwind$??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN6
	DD	imagerel $LN6+35
	DD	imagerel $unwind$?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD imagerel $LN29
	DD	imagerel $LN29+176
	DD	imagerel $unwind$??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel $LN51
	DD	imagerel $LN51+178
	DD	imagerel $unwind$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z DD imagerel $LN87
	DD	imagerel $LN87+230
	DD	imagerel $unwind$?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z@4HA DD imagerel ?dtor$0@?0??push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z@4HA
	DD	imagerel ?dtor$0@?0??push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0??push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z DD imagerel $LN65
	DD	imagerel $LN65+42
	DD	imagerel $unwind$?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z DD imagerel $LN65+42
	DD	imagerel $LN65+152
	DD	imagerel $chain$1$?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z DD imagerel $LN65+152
	DD	imagerel $LN65+163
	DD	imagerel $chain$2$?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+36
	DD	imagerel $unwind$??1?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ DD imagerel $LN49
	DD	imagerel $LN49+75
	DD	imagerel $unwind$??0?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z DD imagerel $LN87
	DD	imagerel $LN87+230
	DD	imagerel $unwind$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z@4HA DD imagerel ?dtor$0@?0??push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z@4HA
	DD	imagerel ?dtor$0@?0??push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0??push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z DD imagerel $LN65
	DD	imagerel $LN65+42
	DD	imagerel $unwind$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z DD imagerel $LN65+42
	DD	imagerel $LN65+152
	DD	imagerel $chain$1$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z DD imagerel $LN65+152
	DD	imagerel $LN65+163
	DD	imagerel $chain$2$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAA@XZ DD imagerel $LN49
	DD	imagerel $LN49+75
	DD	imagerel $unwind$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?top@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ DD imagerel $LN16
	DD	imagerel $LN16+78
	DD	imagerel $unwind$?top@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN53
	DD	imagerel $LN53+75
	DD	imagerel $unwind$??0?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD0@Z DD imagerel $LN42
	DD	imagerel $LN42+50
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+36
	DD	imagerel $unwind$??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ DD imagerel $LN424
	DD	imagerel $LN424+1239
	DD	imagerel $unwind$?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD imagerel ?dtor$1@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	imagerel ?dtor$1@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$1@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD imagerel ?dtor$7@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	imagerel ?dtor$7@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$7@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$13@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD imagerel ?dtor$13@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	imagerel ?dtor$13@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$13@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$19@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD imagerel ?dtor$19@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	imagerel ?dtor$19@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$19@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$25@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD imagerel ?dtor$25@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	imagerel ?dtor$25@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$25@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$31@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD imagerel ?dtor$31@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	imagerel ?dtor$31@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$31@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$37@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD imagerel ?dtor$37@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	imagerel ?dtor$37@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$37@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$43@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD imagerel ?dtor$43@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	imagerel ?dtor$43@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$43@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$49@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD imagerel ?dtor$49@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	imagerel ?dtor$49@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$49@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$55@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD imagerel ?dtor$55@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	imagerel ?dtor$55@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$55@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CharReaderBuilder@Json@@UEAA@XZ DD imagerel $LN7
	DD	imagerel $LN7+58
	DD	imagerel $unwind$??1CharReaderBuilder@Json@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCharReaderBuilder@Json@@UEAAPEAXI@Z DD imagerel $LN11
	DD	imagerel $LN11+87
	DD	imagerel $unwind$??_GCharReaderBuilder@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1OurCharReader@Json@@UEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+34
	DD	imagerel $unwind$??1OurCharReader@Json@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1OurReader@Json@@QEAA@XZ DD imagerel $LN94
	DD	imagerel $LN94+160
	DD	imagerel $unwind$??1OurReader@Json@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GOurCharReader@Json@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+62
	DD	imagerel $unwind$??_GOurCharReader@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?parse@OurCharReader@Json@@UEAA_NPEBD0PEAVValue@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN48
	DD	imagerel $LN48+131
	DD	imagerel $unwind$?parse@OurCharReader@Json@@UEAA_NPEBD0PEAVValue@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z DD imagerel $LN7
	DD	imagerel $LN7+57
	DD	imagerel $unwind$??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel $LN344
	DD	imagerel $LN344+679
	DD	imagerel $unwind$?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$0@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getLocationLineAndColumn@OurReader@Json@@AEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z DD imagerel $LN63
	DD	imagerel $LN63+222
	DD	imagerel $unwind$?getLocationLineAndColumn@OurReader@Json@@AEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ DD imagerel $LN18
	DD	imagerel $LN18+82
	DD	imagerel $unwind$?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addErrorAndRecover@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z DD imagerel $LN17
	DD	imagerel $LN17+104
	DD	imagerel $unwind$?addErrorAndRecover@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z DD imagerel $LN15
	DD	imagerel $LN15+103
	DD	imagerel $unwind$?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ErrorInfo@OurReader@Json@@QEAA@XZ DD imagerel $LN36
	DD	imagerel $LN36+52
	DD	imagerel $unwind$??1ErrorInfo@OurReader@Json@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z DD imagerel $LN133
	DD	imagerel $LN133+175
	DD	imagerel $unwind$?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD imagerel $LN437
	DD	imagerel $LN437+490
	DD	imagerel $unwind$?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD imagerel $LN166
	DD	imagerel $LN166+398
	DD	imagerel $unwind$?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN257
	DD	imagerel $LN257+704
	DD	imagerel $unwind$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel $LN278
	DD	imagerel $LN278+622
	DD	imagerel $unwind$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD imagerel $LN455
	DD	imagerel $LN455+721
	DD	imagerel $unwind$?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD imagerel $LN40
	DD	imagerel $LN40+298
	DD	imagerel $unwind$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel $LN193
	DD	imagerel $LN193+571
	DD	imagerel $unwind$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel $LN579
	DD	imagerel $LN579+1415
	DD	imagerel $unwind$?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$9@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA DD imagerel ?dtor$9@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	imagerel ?dtor$9@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA+46
	DD	imagerel $unwind$?dtor$9@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel $LN1585
	DD	imagerel $LN1585+2297
	DD	imagerel $unwind$?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z DD imagerel $LN54
	DD	imagerel $LN54+151
	DD	imagerel $unwind$?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readComment@OurReader@Json@@AEAA_NXZ DD imagerel $LN81
	DD	imagerel $LN81+343
	DD	imagerel $unwind$?readComment@OurReader@Json@@AEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel $LN159
	DD	imagerel $LN159+1354
	DD	imagerel $unwind$?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?skipCommentTokens@OurReader@Json@@AEAAXAEAVToken@12@@Z DD imagerel $LN12
	DD	imagerel $LN12+74
	DD	imagerel $unwind$?skipCommentTokens@OurReader@Json@@AEAAXAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readValue@OurReader@Json@@AEAA_NXZ DD imagerel $LN593
	DD	imagerel $LN593+1332
	DD	imagerel $unwind$?readValue@OurReader@Json@@AEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z DD imagerel $LN492
	DD	imagerel $LN492+721
	DD	imagerel $unwind$?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z DD imagerel $LN181
	DD	imagerel $LN181+280
	DD	imagerel $unwind$??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ DD imagerel $LN18
	DD	imagerel $LN18+82
	DD	imagerel $unwind$?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addErrorAndRecover@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z DD imagerel $LN17
	DD	imagerel $LN17+104
	DD	imagerel $unwind$?addErrorAndRecover@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z DD imagerel $LN15
	DD	imagerel $LN15+103
	DD	imagerel $unwind$?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z DD imagerel $LN133
	DD	imagerel $LN133+175
	DD	imagerel $unwind$?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD imagerel $LN437
	DD	imagerel $LN437+490
	DD	imagerel $unwind$?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD imagerel $LN166
	DD	imagerel $LN166+398
	DD	imagerel $unwind$?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN257
	DD	imagerel $LN257+704
	DD	imagerel $unwind$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel $LN278
	DD	imagerel $LN278+622
	DD	imagerel $unwind$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD imagerel $LN303
	DD	imagerel $LN303+655
	DD	imagerel $unwind$?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA DD imagerel ?dtor$6@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	imagerel ?dtor$6@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA+46
	DD	imagerel $unwind$?dtor$6@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD imagerel $LN49
	DD	imagerel $LN49+310
	DD	imagerel $unwind$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel $LN193
	DD	imagerel $LN193+571
	DD	imagerel $unwind$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel $LN579
	DD	imagerel $LN579+1415
	DD	imagerel $unwind$?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$9@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA DD imagerel ?dtor$9@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	imagerel ?dtor$9@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA+46
	DD	imagerel $unwind$?dtor$9@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel $LN1516
	DD	imagerel $LN1516+2347
	DD	imagerel $unwind$?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$19@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA DD imagerel ?dtor$19@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	imagerel ?dtor$19@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA+49
	DD	imagerel $unwind$?dtor$19@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z DD imagerel $LN54
	DD	imagerel $LN54+151
	DD	imagerel $unwind$?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z DD imagerel ?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z
	DD	imagerel ?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z+202
	DD	imagerel $unwind$?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z@4HA DD imagerel ?dtor$0@?0??normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z@4HA
	DD	imagerel ?dtor$0@?0??normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readComment@Reader@Json@@AEAA_NXZ DD imagerel $LN81
	DD	imagerel $LN81+343
	DD	imagerel $unwind$?readComment@Reader@Json@@AEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel $LN92
	DD	imagerel $LN92+858
	DD	imagerel $unwind$?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z DD imagerel $LN102
	DD	imagerel $LN102+26
	DD	imagerel $unwind$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z DD imagerel $LN102+26
	DD	imagerel $LN102+417
	DD	imagerel $chain$4$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z DD imagerel $LN102+417
	DD	imagerel $LN102+753
	DD	imagerel $chain$6$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z DD imagerel $LN102+753
	DD	imagerel $LN102+764
	DD	imagerel $chain$7$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z DD imagerel $LN102+764
	DD	imagerel $LN102+946
	DD	imagerel $chain$8$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readValue@Reader@Json@@AEAA_NXZ DD imagerel $LN516
	DD	imagerel $LN516+1144
	DD	imagerel $unwind$?readValue@Reader@Json@@AEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z DD imagerel $LN270
	DD	imagerel $LN270+501
	DD	imagerel $unwind$?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fixNumericLocaleInput@Json@@YAXPEAD0@Z DD imagerel ?fixNumericLocaleInput@Json@@YAXPEAD0@Z
	DD	imagerel ?fixNumericLocaleInput@Json@@YAXPEAD0@Z+93
	DD	imagerel $unwind$?fixNumericLocaleInput@Json@@YAXPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD imagerel ?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	imagerel ?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z+562
	DD	imagerel $unwind$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA DD imagerel ?dtor$0@?0??codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA
	DD	imagerel ?dtor$0@?0??codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getDecimalPoint@Json@@YADXZ DD imagerel ?getDecimalPoint@Json@@YADXZ
	DD	imagerel ?getDecimalPoint@Json@@YADXZ+31
	DD	imagerel $unwind$?getDecimalPoint@Json@@YADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GFactory@CharReader@Json@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$??_GFactory@CharReader@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCharReader@Json@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$??_GCharReader@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z DD imagerel $LN357
	DD	imagerel $LN357+251
	DD	imagerel $unwind$?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Reader@Json@@QEAA@XZ DD imagerel $LN185
	DD	imagerel $LN185+256
	DD	imagerel $unwind$??0Reader@Json@@QEAA@XZ
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Reader@Json@@QEAA@XZ DD imagerel ??0Reader@Json@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0Reader@Json@@QEAA@XZ+89
	DD	00H
	DD	imagerel ??0Reader@Json@@QEAA@XZ+237
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Reader@Json@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0Reader@Json@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0Reader@Json@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0Reader@Json@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0Reader@Json@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Reader@Json@@QEAA@XZ DD 061d11H
	DD	0a641dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0Reader@Json@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z DD imagerel ?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z
	DD	0ffffffffH
	DD	imagerel ?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z+111
	DD	00H
	DD	imagerel ?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z+208
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z@4HA
	DD	00H
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z DD 042019H
	DD	07004b208H
	DD	030026003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z
	DD	05aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCharReader@Json@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GFactory@CharReader@Json@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getDecimalPoint@Json@@YADXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD imagerel ?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	0ffffffffH
	DD	imagerel ?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z+29
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fixNumericLocaleInput@Json@@YAXPEAD0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z DD imagerel ?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
	DD	0ffffffffH
	DD	imagerel ?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+354
	DD	00H
	DD	imagerel ?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+369
	DD	01H
	DD	imagerel ?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+426
	DD	00H
	DD	imagerel ?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+444
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z DD 0a2f19H
	DD	0190119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
	DD	0b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?readValue@Reader@Json@@AEAA_NXZ DD imagerel ?readValue@Reader@Json@@AEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?readValue@Reader@Json@@AEAA_NXZ+100
	DD	00H
	DD	imagerel ?readValue@Reader@Json@@AEAA_NXZ+110
	DD	0ffffffffH
	DD	imagerel ?readValue@Reader@Json@@AEAA_NXZ+237
	DD	00H
	DD	imagerel ?readValue@Reader@Json@@AEAA_NXZ+239
	DD	0ffffffffH
	DD	imagerel ?readValue@Reader@Json@@AEAA_NXZ+956
	DD	03H
	DD	imagerel ?readValue@Reader@Json@@AEAA_NXZ+972
	DD	04H
	DD	imagerel ?readValue@Reader@Json@@AEAA_NXZ+1028
	DD	03H
	DD	imagerel ?readValue@Reader@Json@@AEAA_NXZ+1046
	DD	0ffffffffH
	DD	imagerel ?readValue@Reader@Json@@AEAA_NXZ+1104
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?readValue@Reader@Json@@AEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??readValue@Reader@Json@@AEAA_NXZ@4HA
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$5@?0??readValue@Reader@Json@@AEAA_NXZ@4HA
	DD	03H
	DD	imagerel ?dtor$16@?0??readValue@Reader@Json@@AEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?readValue@Reader@Json@@AEAA_NXZ DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$?readValue@Reader@Json@@AEAA_NXZ
	DD	00H
	DD	00H
	DD	0aH
	DD	imagerel $ip2state$?readValue@Reader@Json@@AEAA_NXZ
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readValue@Reader@Json@@AEAA_NXZ DD 093019H
	DD	0206422H
	DD	01f341eH
	DD	01a0112H
	DD	07005e007H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?readValue@Reader@Json@@AEAA_NXZ
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z DD 0a0021H
	DD	04f400H
	DD	0be400H
	DD	0ac400H
	DD	096400H
	DD	085400H
	DD	imagerel $LN102
	DD	imagerel $LN102+26
	DD	imagerel $unwind$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z DD 021H
	DD	imagerel $LN102
	DD	imagerel $LN102+26
	DD	imagerel $unwind$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z DD 0a0021H
	DD	04f400H
	DD	0be400H
	DD	0ac400H
	DD	096400H
	DD	085400H
	DD	imagerel $LN102
	DD	imagerel $LN102+26
	DD	imagerel $unwind$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z DD 0a1921H
	DD	04f419H
	DD	0be414H
	DD	0ac40fH
	DD	09640aH
	DD	085405H
	DD	imagerel $LN102
	DD	imagerel $LN102+26
	DD	imagerel $unwind$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z DD 030701H
	DD	070034207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readComment@Reader@Json@@AEAA_NXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z DD imagerel ?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z
	DD	0ffffffffH
	DD	imagerel ?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z+43
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z DD 082211H
	DD	0b6422H
	DD	0a541dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z DD imagerel ?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
	DD	0ffffffffH
	DD	imagerel ?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z+48
	DD	00H
	DD	imagerel ?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z+112
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z DD 031f19H
	DD	07003a207H
	DD	03002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$19@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	0ffffffffH
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+98
	DD	00H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+143
	DD	01H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+168
	DD	02H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+618
	DD	04H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+896
	DD	02H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+1385
	DD	0cH
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+1410
	DD	0dH
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+1489
	DD	0cH
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+1606
	DD	02H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+1707
	DD	0aH
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+1732
	DD	0bH
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+1811
	DD	0aH
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+1926
	DD	02H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+1931
	DD	04H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+1953
	DD	05H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+1982
	DD	06H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+2031
	DD	07H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+2053
	DD	08H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+2086
	DD	09H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+2095
	DD	04H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+2111
	DD	02H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+2179
	DD	0eH
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+2218
	DD	02H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+2266
	DD	00H
	DD	imagerel ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z+2277
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$7@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	00H
	DD	02H
	DD	imagerel ?dtor$2@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	04H
	DD	imagerel ?dtor$19@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	05H
	DD	imagerel ?dtor$20@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	06H
	DD	imagerel ?dtor$22@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	04H
	DD	imagerel ?dtor$17@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	08H
	DD	imagerel ?dtor$18@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$4@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	0aH
	DD	imagerel ?dtor$23@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$5@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	0cH
	DD	imagerel ?dtor$24@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$6@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 019930522H
	DD	0fH
	DD	imagerel $stateUnwindMap$?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	00H
	DD	00H
	DD	01aH
	DD	imagerel $ip2state$?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	0a0H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 0b3b19H
	DD	051742aH
	DD	0506426H
	DD	04f3422H
	DD	04a0116H
	DD	0e006f008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	024aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$9@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	0ffffffffH
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+132
	DD	00H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+157
	DD	01H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+854
	DD	02H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+885
	DD	03H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+937
	DD	04H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+960
	DD	05H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+995
	DD	06H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+1004
	DD	01H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+1055
	DD	07H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+1077
	DD	08H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+1141
	DD	07H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+1244
	DD	01H
	DD	imagerel ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z+1282
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$2@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$9@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$10@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$12@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$7@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	05H
	DD	imagerel ?dtor$8@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$1@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	07H
	DD	imagerel ?dtor$13@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 019930522H
	DD	09H
	DD	imagerel $stateUnwindMap$?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	00H
	DD	00H
	DD	0eH
	DD	imagerel $ip2state$?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	068H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 0d4019H
	DD	043742fH
	DD	042642bH
	DD	0413427H
	DD	03a011aH
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	01caH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel ?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	0ffffffffH
	DD	imagerel ?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z+57
	DD	01H
	DD	imagerel ?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z+417
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 081e11H
	DD	015541eH
	DD	014341aH
	DD	0e007f20eH
	DD	060047005H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD 0c1f01H
	DD	012741fH
	DD	011641fH
	DD	010341fH
	DD	0f018921fH
	DD	0d014e016H
	DD	05010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
	DD	0ffffffffH
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+116
	DD	00H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+139
	DD	01H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+170
	DD	02H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+232
	DD	03H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+289
	DD	04H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+371
	DD	05H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+392
	DD	06H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+415
	DD	07H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+435
	DD	06H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+483
	DD	05H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+516
	DD	04H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+586
	DD	00H
	DD	imagerel ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+606
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$6@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$7@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$9@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	04H
	DD	imagerel ?dtor$2@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	05H
	DD	imagerel ?dtor$3@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	06H
	DD	imagerel ?dtor$4@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD 019930522H
	DD	08H
	DD	imagerel $stateUnwindMap$?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
	DD	00H
	DD	00H
	DD	0eH
	DD	imagerel $ip2state$?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD 073019H
	DD	0380116H
	DD	07005e007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
	DD	01baH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	0ffffffffH
	DD	imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z+71
	DD	00H
	DD	imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z+554
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	080H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z DD 092f19H
	DD	01e341dH
	DD	0160111H
	DD	0e008f00aH
	DD	060057006H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z
	DD	0aaH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+229
	DD	00H
	DD	imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+231
	DD	0ffffffffH
	DD	imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+318
	DD	01H
	DD	imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+337
	DD	0ffffffffH
	DD	imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+437
	DD	02H
	DD	imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+458
	DD	0ffffffffH
	DD	imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+503
	DD	00H
	DD	imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+524
	DD	0ffffffffH
	DD	imagerel ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+580
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	00H
	DD	00H
	DD	0aH
	DD	imagerel $ip2state$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 092d19H
	DD	0120117H
	DD	0e009f00bH
	DD	07005c007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	08aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD imagerel ?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	0ffffffffH
	DD	imagerel ?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+156
	DD	00H
	DD	imagerel ?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+178
	DD	0ffffffffH
	DD	imagerel ?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+345
	DD	01H
	DD	imagerel ?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+367
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 062319H
	DD	0e007d20bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD imagerel ?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	0ffffffffH
	DD	imagerel ?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+116
	DD	00H
	DD	imagerel ?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+139
	DD	01H
	DD	imagerel ?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+194
	DD	00H
	DD	imagerel ?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+212
	DD	0ffffffffH
	DD	imagerel ?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+343
	DD	02H
	DD	imagerel ?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+366
	DD	03H
	DD	imagerel ?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+421
	DD	02H
	DD	imagerel ?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+439
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	00H
	DD	00H
	DD	09H
	DD	imagerel $ip2state$?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 072f19H
	DD	01b3421H
	DD	0140111H
	DD	06003e005H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	092H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z DD imagerel ?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
	DD	0ffffffffH
	DD	imagerel ?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z+63
	DD	00H
	DD	imagerel ?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z+131
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z DD 042219H
	DD	011010aH
	DD	030027003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
	DD	072H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addErrorAndRecover@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z DD imagerel ??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z
	DD	0ffffffffH
	DD	imagerel ??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z+97
	DD	00H
	DD	imagerel ??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z+256
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z DD 082211H
	DD	0b6422H
	DD	0a541dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z DD imagerel ?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
	DD	0ffffffffH
	DD	imagerel ?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+342
	DD	00H
	DD	imagerel ?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+357
	DD	01H
	DD	imagerel ?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+414
	DD	00H
	DD	imagerel ?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+432
	DD	0ffffffffH
	DD	imagerel ?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+590
	DD	02H
	DD	imagerel ?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+605
	DD	03H
	DD	imagerel ?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+662
	DD	02H
	DD	imagerel ?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z+680
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
	DD	00H
	DD	00H
	DD	09H
	DD	imagerel $ip2state$?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z DD 0a2f19H
	DD	0190119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
	DD	0b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?readValue@OurReader@Json@@AEAA_NXZ DD imagerel ?readValue@OurReader@Json@@AEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?readValue@OurReader@Json@@AEAA_NXZ+108
	DD	00H
	DD	imagerel ?readValue@OurReader@Json@@AEAA_NXZ+118
	DD	0ffffffffH
	DD	imagerel ?readValue@OurReader@Json@@AEAA_NXZ+279
	DD	00H
	DD	imagerel ?readValue@OurReader@Json@@AEAA_NXZ+281
	DD	0ffffffffH
	DD	imagerel ?readValue@OurReader@Json@@AEAA_NXZ+1128
	DD	03H
	DD	imagerel ?readValue@OurReader@Json@@AEAA_NXZ+1144
	DD	04H
	DD	imagerel ?readValue@OurReader@Json@@AEAA_NXZ+1200
	DD	03H
	DD	imagerel ?readValue@OurReader@Json@@AEAA_NXZ+1218
	DD	0ffffffffH
	DD	imagerel ?readValue@OurReader@Json@@AEAA_NXZ+1280
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?readValue@OurReader@Json@@AEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??readValue@OurReader@Json@@AEAA_NXZ@4HA
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$8@?0??readValue@OurReader@Json@@AEAA_NXZ@4HA
	DD	03H
	DD	imagerel ?dtor$19@?0??readValue@OurReader@Json@@AEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?readValue@OurReader@Json@@AEAA_NXZ DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$?readValue@OurReader@Json@@AEAA_NXZ
	DD	00H
	DD	00H
	DD	0aH
	DD	imagerel $ip2state$?readValue@OurReader@Json@@AEAA_NXZ
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readValue@OurReader@Json@@AEAA_NXZ DD 0b3519H
	DD	0217427H
	DD	0206423H
	DD	01f341fH
	DD	01a0113H
	DD	0e006f008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?readValue@OurReader@Json@@AEAA_NXZ
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?skipCommentTokens@OurReader@Json@@AEAAXAEAVToken@12@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readComment@OurReader@Json@@AEAA_NXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z DD imagerel ?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
	DD	0ffffffffH
	DD	imagerel ?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z+48
	DD	00H
	DD	imagerel ?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z+112
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z DD 031f19H
	DD	07003a207H
	DD	03002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	0ffffffffH
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+79
	DD	00H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+128
	DD	01H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+153
	DD	02H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+583
	DD	04H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+756
	DD	02H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1326
	DD	00H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1337
	DD	0ffffffffH
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1361
	DD	02H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1403
	DD	08H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1423
	DD	0aH
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1472
	DD	0bH
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1532
	DD	0aH
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1622
	DD	02H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1706
	DD	0cH
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1742
	DD	02H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1804
	DD	07H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1814
	DD	02H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1855
	DD	05H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1871
	DD	06H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1928
	DD	05H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+2021
	DD	02H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+2056
	DD	00H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+2067
	DD	0ffffffffH
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+2091
	DD	04H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+2107
	DD	02H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+2157
	DD	0dH
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+2193
	DD	02H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+2226
	DD	00H
	DD	imagerel ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z+2237
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$10@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	00H
	DD	02H
	DD	imagerel ?dtor$2@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$4@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	05H
	DD	imagerel ?dtor$20@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$5@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$6@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	08H
	DD	imagerel ?dtor$7@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$7@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	0aH
	DD	imagerel ?dtor$21@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$8@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$9@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 019930522H
	DD	0eH
	DD	imagerel $stateUnwindMap$?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	00H
	DD	00H
	DD	01eH
	DD	imagerel $ip2state$?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	068H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 0b3619H
	DD	0346428H
	DD	0333424H
	DD	02c0117H
	DD	0e009f00bH
	DD	07005c007H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	015aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$9@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	0ffffffffH
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+132
	DD	00H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+157
	DD	01H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+854
	DD	02H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+885
	DD	03H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+937
	DD	04H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+960
	DD	05H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+995
	DD	06H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1004
	DD	01H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1055
	DD	07H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1077
	DD	08H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1141
	DD	07H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1244
	DD	01H
	DD	imagerel ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z+1282
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$2@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$9@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$10@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$12@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$7@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	05H
	DD	imagerel ?dtor$8@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$1@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
	DD	07H
	DD	imagerel ?dtor$13@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 019930522H
	DD	09H
	DD	imagerel $stateUnwindMap$?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	00H
	DD	00H
	DD	0eH
	DD	imagerel $ip2state$?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	068H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 0d4019H
	DD	043742fH
	DD	042642bH
	DD	0413427H
	DD	03a011aH
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	01caH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel ?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	0ffffffffH
	DD	imagerel ?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z+57
	DD	01H
	DD	imagerel ?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z+417
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 081e11H
	DD	015541eH
	DD	014341aH
	DD	0e007f20eH
	DD	060047005H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD 0a1a01H
	DD	0f741aH
	DD	0e641aH
	DD	0d541aH
	DD	0c341aH
	DD	0e016921aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD imagerel ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
	DD	0ffffffffH
	DD	imagerel ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+121
	DD	00H
	DD	imagerel ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+137
	DD	01H
	DD	imagerel ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+194
	DD	00H
	DD	imagerel ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+212
	DD	0ffffffffH
	DD	imagerel ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+495
	DD	02H
	DD	imagerel ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+516
	DD	03H
	DD	imagerel ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+536
	DD	04H
	DD	imagerel ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+556
	DD	03H
	DD	imagerel ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+589
	DD	02H
	DD	imagerel ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z+622
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$6@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$4@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
	DD	00H
	DD	00H
	DD	0bH
	DD	imagerel $ip2state$?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z DD 092d19H
	DD	0180117H
	DD	0e009f00bH
	DD	07005d007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
	DD	0baH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	0ffffffffH
	DD	imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z+71
	DD	00H
	DD	imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z+554
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	080H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z DD 092f19H
	DD	01e341dH
	DD	0160111H
	DD	0e008f00aH
	DD	060057006H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z
	DD	0aaH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+229
	DD	00H
	DD	imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+231
	DD	0ffffffffH
	DD	imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+318
	DD	01H
	DD	imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+337
	DD	0ffffffffH
	DD	imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+437
	DD	02H
	DD	imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+458
	DD	0ffffffffH
	DD	imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+503
	DD	00H
	DD	imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+524
	DD	0ffffffffH
	DD	imagerel ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+580
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	00H
	DD	00H
	DD	0aH
	DD	imagerel $ip2state$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 092d19H
	DD	0120117H
	DD	0e009f00bH
	DD	07005c007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	08aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD imagerel ?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	0ffffffffH
	DD	imagerel ?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+156
	DD	00H
	DD	imagerel ?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+178
	DD	0ffffffffH
	DD	imagerel ?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+345
	DD	01H
	DD	imagerel ?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+367
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 062319H
	DD	0e007d20bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD imagerel ?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	0ffffffffH
	DD	imagerel ?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+116
	DD	00H
	DD	imagerel ?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+139
	DD	01H
	DD	imagerel ?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+194
	DD	00H
	DD	imagerel ?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+212
	DD	0ffffffffH
	DD	imagerel ?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+343
	DD	02H
	DD	imagerel ?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+366
	DD	03H
	DD	imagerel ?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+421
	DD	02H
	DD	imagerel ?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z+439
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	00H
	DD	00H
	DD	09H
	DD	imagerel $ip2state$?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z DD 072f19H
	DD	01b3421H
	DD	0140111H
	DD	06003e005H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
	DD	092H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z DD imagerel ?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
	DD	0ffffffffH
	DD	imagerel ?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z+63
	DD	00H
	DD	imagerel ?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z+131
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z DD 042219H
	DD	011010aH
	DD	030027003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
	DD	072H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ErrorInfo@OurReader@Json@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addErrorAndRecover@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getLocationLineAndColumn@OurReader@Json@@AEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z DD 041c19H
	DD	015340dH
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	0ffffffffH
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+60
	DD	00H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+190
	DD	01H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+210
	DD	02H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+230
	DD	03H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+249
	DD	02H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+282
	DD	01H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+315
	DD	00H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+353
	DD	04H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+373
	DD	05H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+392
	DD	04H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+425
	DD	00H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+468
	DD	06H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+488
	DD	07H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+508
	DD	08H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+527
	DD	07H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+560
	DD	06H
	DD	imagerel ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+593
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$4@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	04H
	DD	imagerel ?dtor$5@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$6@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	06H
	DD	imagerel ?dtor$7@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	07H
	DD	imagerel ?dtor$8@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	09H
	DD	imagerel $stateUnwindMap$?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	00H
	DD	00H
	DD	012H
	DD	imagerel $ip2state$?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0b3619H
	DD	01e3428H
	DD	0140118H
	DD	0e00af00cH
	DD	0c006d008H
	DD	060037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	09aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z DD imagerel ??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z
	DD	0ffffffffH
	DD	imagerel ??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z+22
	DD	00H
	DD	imagerel ??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?parse@OurCharReader@Json@@UEAA_NPEBD0PEAVValue@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041719H
	DD	07004b208H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GOurCharReader@Json@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1OurReader@Json@@QEAA@XZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1OurCharReader@Json@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GCharReaderBuilder@Json@@UEAAPEAXI@Z DD imagerel ??_GCharReaderBuilder@Json@@UEAAPEAXI@Z
	DD	0ffffffffH
	DD	imagerel ??_GCharReaderBuilder@Json@@UEAAPEAXI@Z+39
	DD	00H
	DD	imagerel ??_GCharReaderBuilder@Json@@UEAAPEAXI@Z+49
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GCharReaderBuilder@Json@@UEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???_GCharReaderBuilder@Json@@UEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_GCharReaderBuilder@Json@@UEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_GCharReaderBuilder@Json@@UEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_GCharReaderBuilder@Json@@UEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCharReaderBuilder@Json@@UEAAPEAXI@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_GCharReaderBuilder@Json@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CharReaderBuilder@Json@@UEAA@XZ DD imagerel ??1CharReaderBuilder@Json@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1CharReaderBuilder@Json@@UEAA@XZ+32
	DD	00H
	DD	imagerel ??1CharReaderBuilder@Json@@UEAA@XZ+42
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1CharReaderBuilder@Json@@UEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1CharReaderBuilder@Json@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1CharReaderBuilder@Json@@UEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1CharReaderBuilder@Json@@UEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1CharReaderBuilder@Json@@UEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CharReaderBuilder@Json@@UEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1CharReaderBuilder@Json@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$55@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$49@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$43@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$37@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$31@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$25@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$19@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$13@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ DD imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ
	DD	0ffffffffH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+89
	DD	00H
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+137
	DD	0ffffffffH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+220
	DD	02H
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+268
	DD	0ffffffffH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+329
	DD	04H
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+377
	DD	0ffffffffH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+438
	DD	06H
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+486
	DD	0ffffffffH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+547
	DD	08H
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+595
	DD	0ffffffffH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+656
	DD	0aH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+704
	DD	0ffffffffH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+765
	DD	0cH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+813
	DD	0ffffffffH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+874
	DD	0eH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+922
	DD	0ffffffffH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+983
	DD	010H
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+1031
	DD	0ffffffffH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+1092
	DD	012H
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+1140
	DD	0ffffffffH
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+1176
	DD	014H
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+1181
	DD	015H
	DD	imagerel ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ+1210
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$7@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$13@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$19@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$25@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$31@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	0aH
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$37@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	0cH
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$43@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	0eH
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$49@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	010H
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$55@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	012H
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
	DD	014H
	DD	imagerel ?dtor$61@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ DD 019930522H
	DD	016H
	DD	imagerel $stateUnwindMap$?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ
	DD	00H
	DD	00H
	DD	018H
	DD	imagerel $ip2state$?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ DD 081e11H
	DD	0d641eH
	DD	0c5419H
	DD	0b3414H
	DD	070027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?top@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN65
	DD	imagerel $LN65+42
	DD	imagerel $unwind$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z DD 040a21H
	DD	07740aH
	DD	065405H
	DD	imagerel $LN65
	DD	imagerel $LN65+42
	DD	imagerel $unwind$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z DD imagerel ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z
	DD	0ffffffffH
	DD	imagerel ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z+142
	DD	00H
	DD	imagerel ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z+210
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z DD 061911H
	DD	0b6419H
	DD	093414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN65
	DD	imagerel $LN65+42
	DD	imagerel $unwind$?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z DD 040a21H
	DD	07740aH
	DD	065405H
	DD	imagerel $LN65
	DD	imagerel $LN65+42
	DD	imagerel $unwind$?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z DD imagerel ?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z
	DD	0ffffffffH
	DD	imagerel ?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z+142
	DD	00H
	DD	imagerel ?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z+210
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z DD 061911H
	DD	0b6419H
	DD	093414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+64
	DD	00H
	DD	imagerel ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+92
	DD	01H
	DD	imagerel ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+138
	DD	02H
	DD	imagerel ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+164
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 041d11H
	DD	09341dH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN169
	DD	imagerel $LN169+77
	DD	imagerel $unwind$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN169+77
	DD	imagerel $LN169+151
	DD	imagerel $chain$1$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN169+151
	DD	imagerel $LN169+231
	DD	imagerel $chain$3$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD 020521H
	DD	0ac405H
	DD	imagerel $LN169+151
	DD	imagerel $LN169+231
	DD	imagerel $chain$3$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD 040a21H
	DD	09740aH
	DD	086405H
	DD	imagerel $LN169+77
	DD	imagerel $LN169+151
	DD	imagerel $chain$1$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD 041121H
	DD	04f411H
	DD	0be405H
	DD	imagerel $LN169
	DD	imagerel $LN169+77
	DD	imagerel $unwind$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z DD 030701H
	DD	050034207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@Reader@Json@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+25
	DD	00H
	DD	imagerel ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+50
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 020f11H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 062019H
	DD	0f7412H
	DD	0e3412H
	DD	0500b9212H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN169
	DD	imagerel $LN169+77
	DD	imagerel $unwind$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN169+77
	DD	imagerel $LN169+151
	DD	imagerel $chain$1$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN169+151
	DD	imagerel $LN169+231
	DD	imagerel $chain$3$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD 020521H
	DD	0ac405H
	DD	imagerel $LN169+151
	DD	imagerel $LN169+231
	DD	imagerel $chain$3$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD 040a21H
	DD	09740aH
	DD	086405H
	DD	imagerel $LN169+77
	DD	imagerel $LN169+151
	DD	imagerel $chain$1$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD 041121H
	DD	04f411H
	DD	0be405H
	DD	imagerel $LN169
	DD	imagerel $LN169+77
	DD	imagerel $unwind$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z DD 030701H
	DD	050034207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAXXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@OurReader@Json@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN169
	DD	imagerel $LN169+74
	DD	imagerel $unwind$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN169+74
	DD	imagerel $LN169+154
	DD	imagerel $chain$1$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN169+154
	DD	imagerel $LN169+234
	DD	imagerel $chain$3$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD 020521H
	DD	0ac405H
	DD	imagerel $LN169+154
	DD	imagerel $LN169+234
	DD	imagerel $chain$3$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD 040a21H
	DD	09740aH
	DD	086405H
	DD	imagerel $LN169+74
	DD	imagerel $LN169+154
	DD	imagerel $chain$1$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD 041521H
	DD	04f415H
	DD	0be405H
	DD	imagerel $LN169
	DD	imagerel $LN169+74
	DD	imagerel $unwind$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z DD 030701H
	DD	050034207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@PEAVValue@Json@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAPEAPEAVValue@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAVValue@Json@@@std@@QEAAPEAPEAVValue@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAVErrorInfo@Reader@Json@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAPEAVValue@Json@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@$$$V@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN19
	DD	imagerel $LN19+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@VErrorInfo@OurReader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN19
	DD	imagerel $LN19+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN19
	DD	imagerel $LN19+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPEAVErrorInfo@Reader@Json@@_KPEAV123@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@VErrorInfo@OurReader@Json@@@std@@YAPEAVErrorInfo@OurReader@Json@@_KPEAV123@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@PEAVValue@Json@@@std@@YAPEAPEAVValue@Json@@_KPEAPEAV12@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@PEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@_KPEAPEAV123@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@PEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@_KPEAPEAV123@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@PEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@_KPEAPEAPEAV12@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN13
	DD	imagerel $LN13+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@VErrorInfo@OurReader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN13
	DD	imagerel $LN13+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN13
	DD	imagerel $LN13+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z DD imagerel ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z
	DD	0ffffffffH
	DD	imagerel ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z+40
	DD	00H
	DD	imagerel ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z+110
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z DD 041d11H
	DD	0a341dH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z DD imagerel ?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z
	DD	0ffffffffH
	DD	imagerel ?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z+40
	DD	00H
	DD	imagerel ?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z+110
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z DD 041d11H
	DD	0a341dH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ErrorInfo@Reader@Json@@QEAA@AEBV012@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ErrorInfo@OurReader@Json@@QEAA@AEBV012@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAVErrorInfo@Reader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@VErrorInfo@OurReader@Json@@@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAVErrorInfo@OurReader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAPEAVValue@Json@@PEAPEAV12@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GErrorInfo@OurReader@Json@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ??0Reader@Json@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0Reader@Json@@QEAA@XZ PROC				; Json::Reader::Reader, COMDAT

; 97   :       collectComments_() {}

$LN185:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	esi, esi
	mov	QWORD PTR [rcx], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rsi

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rsi

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rsi

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	lea	ecx, QWORD PTR [rsi+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN28@Reader

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN28@Reader:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 97   :       collectComments_() {}

	lea	rdi, QWORD PTR [rbx+40]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	mov	QWORD PTR [rdi], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rdi+8], rsi

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rdi+16], rsi

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rdi+24], rsi

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rdi+32], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN76@Reader

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN76@Reader:
	mov	QWORD PTR [rdi], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rbx+104], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+96], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+80], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 97   :       collectComments_() {}

	mov	QWORD PTR [rbx+112], rsi
	mov	QWORD PTR [rbx+120], rsi
	mov	QWORD PTR [rbx+128], rsi
	mov	QWORD PTR [rbx+136], rsi
	mov	QWORD PTR [rbx+144], rsi
	mov	QWORD PTR [rbx+176], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+168], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+152], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 68   :       allowDroppedNullPlaceholders_(false), allowNumericKeys_(false) {}

	mov	DWORD PTR [rbx+184], 1

; 97   :       collectComments_() {}

	mov	BYTE PTR [rbx+188], 0
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN184@Reader:
??0Reader@Json@@QEAA@XZ ENDP				; Json::Reader::Reader
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0Reader@Json@@QEAA@XZ@4HA PROC		; `Json::Reader::Reader'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0???0Reader@Json@@QEAA@XZ@4HA ENDP		; `Json::Reader::Reader'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z
_TEXT	SEGMENT
$T1 = 48
documentCopy$ = 56
__$ArrayPad$ = 88
this$ = 128
document$ = 136
root$ = 144
collectComments$dead$ = 152
?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z PROC ; Json::Reader::parse, COMDAT

; 105  : Reader::parse(const std::string& document, Value& root, bool collectComments) {

$LN357:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR $T1[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, r8
	mov	rdi, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	mov	rcx, QWORD PTR [rdx+24]
	cmp	rcx, 16
	jb	SHORT $LN10@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rdx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	jmp	SHORT $LN11@parse
$LN10@parse:
	mov	rax, rdx
$LN11@parse:
	cmp	rcx, 16
	jb	SHORT $LN23@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rdx, QWORD PTR [rdx]
$LN23@parse:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 106  :   JSONCPP_STRING documentCopy(document.data(), document.data() + document.capacity());

	lea	r8, QWORD PTR [rax+rcx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR documentCopy$[rsp+24], 15

; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR documentCopy$[rsp+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR documentCopy$[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 862  : 		if (_First != _Last)

	cmp	rdx, r8
	je	SHORT $LN26@parse

; 863  : 			assign(&*_First, _Last - _First);

	sub	r8, rdx
	lea	rcx, QWORD PTR documentCopy$[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
$LN26@parse:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 107  :   std::swap(documentCopy, document_);

	lea	rbx, QWORD PTR [rdi+80]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1858 : 		if (this == &_Right)

	lea	rax, QWORD PTR documentCopy$[rsp]
	cmp	rax, rbx
	je	SHORT $LN312@parse

; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);

	mov	rdx, rbx
	lea	rcx, QWORD PTR documentCopy$[rsp]
	call	?_Swap_bx@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_bx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rcx, QWORD PTR documentCopy$[rsp+16]

; 53   : 	_Left = _Move(_Right);

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR documentCopy$[rsp+16], rax

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [rbx+16], rcx

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rcx, QWORD PTR documentCopy$[rsp+24]

; 53   : 	_Left = _Move(_Right);

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR documentCopy$[rsp+24], rax

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [rbx+24], rcx
$LN312@parse:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN319@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rbx, QWORD PTR [rbx]
$LN319@parse:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1749 : 		return (this->_Mysize);

	mov	r8, QWORD PTR [rdi+96]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 109  :   const char* end = begin + document_.length();

	add	r8, rbx

; 110  :   return parse(begin, end, root, collectComments);

	mov	r9, rsi
	mov	rdx, rbx
	mov	rcx, rdi
	call	?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z ; Json::Reader::parse
	movzx	ebx, al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR documentCopy$[rsp+24], 16
	jb	SHORT $LN356@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR documentCopy$[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN356@parse:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 110  :   return parse(begin, end, root, collectComments);

	movzx	eax, bl

; 111  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z ENDP ; Json::Reader::parse
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
documentCopy$ = 56
__$ArrayPad$ = 88
this$ = 128
document$ = 136
root$ = 144
collectComments$dead$ = 152
?dtor$0@?0??parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z@4HA PROC ; `Json::Reader::parse'::`1'::dtor$0
	lea	rcx, QWORD PTR documentCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??parse@Reader@Json@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVValue@2@_N@Z@4HA ENDP ; `Json::Reader::parse'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\limits
;	COMDAT ?infinity@?$numeric_limits@N@std@@SANXZ
_TEXT	SEGMENT
?infinity@?$numeric_limits@N@std@@SANXZ PROC		; std::numeric_limits<double>::infinity, COMDAT

; 1160 : 		return (_CSTD _Inf._Double);

	mov	rax, QWORD PTR __imp__Inf
	movsdx	xmm0, QWORD PTR [rax]

; 1161 : 		}

	ret	0
?infinity@?$numeric_limits@N@std@@SANXZ ENDP		; std::numeric_limits<double>::infinity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\limits
;	COMDAT ?quiet_NaN@?$numeric_limits@N@std@@SANXZ
_TEXT	SEGMENT
?quiet_NaN@?$numeric_limits@N@std@@SANXZ PROC		; std::numeric_limits<double>::quiet_NaN, COMDAT

; 1165 : 		return (_CSTD _Nan._Double);

	mov	rax, QWORD PTR __imp__Nan
	movsdx	xmm0, QWORD PTR [rax]

; 1166 : 		}

	ret	0
?quiet_NaN@?$numeric_limits@N@std@@SANXZ ENDP		; std::numeric_limits<double>::quiet_NaN
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Container_proxy@std@@QEAA@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT

; 68   : 		{	// construct from pointers

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 69   : 		}

	mov	rax, rcx
	ret	0
??0_Container_proxy@std@@QEAA@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT

; 114  : 		{	// construct orphaned iterator

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 115  : 		}

	mov	rax, rcx
	ret	0
??0_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0_Iterator_base12@std@@QEAA@AEBU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT

; 119  : 		{	// copy an iterator

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 122  : 
; 123  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 124  : 		{	// assign an iterator
; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN15@Iterator_b

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	rax, QWORD PTR [rax]

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

	test	rax, rax
	je	SHORT $LN15@Iterator_b

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
$LN15@Iterator_b:

; 120  : 		*this = _Right;
; 121  : 		}

	mov	rax, rcx
	ret	0
??0_Iterator_base12@std@@QEAA@AEBU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z PROC	; std::_Iterator_base12::operator=, COMDAT

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	je	SHORT $LN12@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)

	test	rax, rax
	je	SHORT $LN12@operator

; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	rax, QWORD PTR [rax]

; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

	test	rax, rax
	je	SHORT $LN12@operator

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
$LN12@operator:

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);

	mov	rax, rcx

; 137  : 		}

	ret	0
??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z ENDP	; std::_Iterator_base12::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT

; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}

	ret	0
??1_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
_TEXT	SEGMENT
this$ = 8
_Parent$ = 16
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT

; 149  : 		if (_Parent == 0)

	test	rdx, rdx
	je	SHORT $LN1@Adopt

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN1@Adopt:

; 172  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 173  : 			}
; 174  : 		}

	ret	0
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	jne	SHORT $LN3@Getcont

; 184  : 		}

	ret	0
$LN3@Getcont:

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rax, QWORD PTR [rax]

; 184  : 		}

	ret	0
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\include\json\reader.h
;	COMDAT ??1CharReader@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1CharReader@Json@@UEAA@XZ PROC			; Json::CharReader::~CharReader, COMDAT

; 251  :   virtual ~CharReader() {}

	lea	rax, OFFSET FLAT:??_7CharReader@Json@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1CharReader@Json@@UEAA@XZ ENDP			; Json::CharReader::~CharReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\include\json\reader.h
;	COMDAT ??1Factory@CharReader@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Factory@CharReader@Json@@UEAA@XZ PROC		; Json::CharReader::Factory::~Factory, COMDAT

; 275  :     virtual ~Factory() {}

	lea	rax, OFFSET FLAT:??_7Factory@CharReader@Json@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1Factory@CharReader@Json@@UEAA@XZ ENDP		; Json::CharReader::Factory::~Factory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\include\json\reader.h
;	COMDAT ??_GCharReader@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCharReader@Json@@UEAAPEAXI@Z PROC			; Json::CharReader::`scalar deleting destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 251  :   virtual ~CharReader() {}

	lea	rax, OFFSET FLAT:??_7CharReader@Json@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN6@scalar
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN6@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GCharReader@Json@@UEAAPEAXI@Z ENDP			; Json::CharReader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\include\json\reader.h
;	COMDAT ??_GFactory@CharReader@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GFactory@CharReader@Json@@UEAAPEAXI@Z PROC		; Json::CharReader::Factory::`scalar deleting destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 275  :     virtual ~Factory() {}

	lea	rax, OFFSET FLAT:??_7Factory@CharReader@Json@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN6@scalar
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN6@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GFactory@CharReader@Json@@UEAAPEAXI@Z ENDP		; Json::CharReader::Factory::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_tool.h
;	COMDAT ?getDecimalPoint@Json@@YADXZ
_TEXT	SEGMENT
?getDecimalPoint@Json@@YADXZ PROC			; Json::getDecimalPoint, COMDAT

; 26   : static char getDecimalPoint() {

	sub	rsp, 40					; 00000028H

; 27   : #ifdef JSONCPP_NO_LOCALE_SUPPORT
; 28   :   return '\0';
; 29   : #else
; 30   :   struct lconv* lc = localeconv();

	call	QWORD PTR __imp_localeconv

; 31   :   return lc ? *(lc->decimal_point) : '\0';

	test	rax, rax
	je	SHORT $LN3@getDecimal
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]

; 32   : #endif
; 33   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@getDecimal:
	add	rsp, 40					; 00000028H
	ret	0
?getDecimalPoint@Json@@YADXZ ENDP			; Json::getDecimalPoint
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_tool.h
;	COMDAT ?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
__$ReturnUdt$ = 64
cp$ = 72
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; Json::codePointToUTF8, COMDAT

; 36   : static inline JSONCPP_STRING codePointToUTF8(unsigned int cp) {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	edi, edx
	mov	rbx, rcx
	xor	eax, eax
	mov	DWORD PTR $T1[rsp], eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], al
	mov	edx, 1
	mov	DWORD PTR $T1[rsp], edx
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 41   :   if (cp <= 0x7f) {

	cmp	edi, 127				; 0000007fH
	ja	SHORT $LN7@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1770 : 		if (_Newsize <= this->_Mysize)

	cmp	rax, rdx
	jb	SHORT $LN53@codePointT

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+24], 16
	jb	SHORT $LN60@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rcx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN61@codePointT
$LN60@codePointT:
	mov	rax, rcx
$LN61@codePointT:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax+1], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1772 : 		else

	jmp	SHORT $LN52@codePointT
$LN53@codePointT:

; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

	sub	rdx, rax
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN52@codePointT:

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN70@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	$LN71@codePointT
$LN70@codePointT:
	mov	rax, rbx
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 43   :     result[0] = static_cast<char>(cp);

	jmp	$LN71@codePointT
$LN7@codePointT:

; 44   :   } else if (cp <= 0x7FF) {

	cmp	edi, 2047				; 000007ffH
	ja	SHORT $LN5@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	edx, 2

; 1770 : 		if (_Newsize <= this->_Mysize)

	cmp	rax, rdx
	jb	SHORT $LN77@codePointT

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+24], 16
	jb	SHORT $LN84@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rcx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN85@codePointT
$LN84@codePointT:
	mov	rax, rcx
$LN85@codePointT:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax+2], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1772 : 		else

	jmp	SHORT $LN76@codePointT
$LN77@codePointT:

; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

	sub	rdx, rax
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN76@codePointT:

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN94@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN95@codePointT
$LN94@codePointT:
	mov	rcx, rbx
$LN95@codePointT:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 46   :     result[1] = static_cast<char>(0x80 | (0x3f & cp));

	movzx	eax, dil
	and	al, 63					; 0000003fH
	or	al, -128				; ffffffffffffff80H
	mov	BYTE PTR [rcx+1], al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN102@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN103@codePointT
$LN102@codePointT:
	mov	rax, rbx
$LN103@codePointT:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 47   :     result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));

	shr	edi, 6
	and	dil, 31
	or	dil, -64				; ffffffffffffffc0H
	jmp	$LN71@codePointT
$LN5@codePointT:

; 48   :   } else if (cp <= 0xFFFF) {

	cmp	edi, 65535				; 0000ffffH
	ja	$LN3@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	edx, 3

; 1770 : 		if (_Newsize <= this->_Mysize)

	cmp	rax, rdx
	jb	SHORT $LN109@codePointT

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+24], 16
	jb	SHORT $LN116@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rcx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN117@codePointT
$LN116@codePointT:
	mov	rax, rcx
$LN117@codePointT:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax+3], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1772 : 		else

	jmp	SHORT $LN108@codePointT
$LN109@codePointT:

; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

	sub	rdx, rax
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN108@codePointT:

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN126@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN127@codePointT
$LN126@codePointT:
	mov	rcx, rbx
$LN127@codePointT:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 50   :     result[2] = static_cast<char>(0x80 | (0x3f & cp));

	movzx	eax, dil
	and	al, 63					; 0000003fH
	or	al, -128				; ffffffffffffff80H
	mov	BYTE PTR [rcx+2], al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN134@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN135@codePointT
$LN134@codePointT:
	mov	rcx, rbx
$LN135@codePointT:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 51   :     result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));

	mov	eax, edi
	shr	eax, 6
	and	al, 63					; 0000003fH
	or	al, -128				; ffffffffffffff80H
	mov	BYTE PTR [rcx+1], al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN142@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN143@codePointT
$LN142@codePointT:
	mov	rax, rbx
$LN143@codePointT:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 52   :     result[0] = static_cast<char>(0xE0 | (0xf & (cp >> 12)));

	shr	edi, 12
	and	dil, 15
	or	dil, -32				; ffffffffffffffe0H
	jmp	$LN71@codePointT
$LN3@codePointT:

; 53   :   } else if (cp <= 0x10FFFF) {

	cmp	edi, 1114111				; 0010ffffH
	ja	$LN194@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	edx, 4

; 1770 : 		if (_Newsize <= this->_Mysize)

	cmp	rax, rdx
	jb	SHORT $LN149@codePointT

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+24], 16
	jb	SHORT $LN156@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rcx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN157@codePointT
$LN156@codePointT:
	mov	rax, rcx
$LN157@codePointT:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax+4], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1772 : 		else

	jmp	SHORT $LN148@codePointT
$LN149@codePointT:

; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

	sub	rdx, rax
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN148@codePointT:

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN166@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN167@codePointT
$LN166@codePointT:
	mov	rcx, rbx
$LN167@codePointT:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 55   :     result[3] = static_cast<char>(0x80 | (0x3f & cp));

	movzx	eax, dil
	and	al, 63					; 0000003fH
	or	al, -128				; ffffffffffffff80H
	mov	BYTE PTR [rcx+3], al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN174@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN175@codePointT
$LN174@codePointT:
	mov	rcx, rbx
$LN175@codePointT:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 56   :     result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));

	mov	eax, edi
	shr	eax, 6
	and	al, 63					; 0000003fH
	or	al, -128				; ffffffffffffff80H
	mov	BYTE PTR [rcx+2], al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN182@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN183@codePointT
$LN182@codePointT:
	mov	rcx, rbx
$LN183@codePointT:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 57   :     result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));

	mov	eax, edi
	shr	eax, 12
	and	al, 63					; 0000003fH
	or	al, -128				; ffffffffffffff80H
	mov	BYTE PTR [rcx+1], al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN190@codePointT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN191@codePointT
$LN190@codePointT:
	mov	rax, rbx
$LN191@codePointT:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 58   :     result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));

	shr	edi, 18
	and	dil, 7
	or	dil, -16
$LN71@codePointT:
	mov	BYTE PTR [rax], dil
$LN194@codePointT:

; 59   :   }
; 60   : 
; 61   :   return result;

	mov	rax, rbx

; 62   : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
	int	3
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; Json::codePointToUTF8
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
__$ReturnUdt$ = 64
cp$ = 72
?dtor$0@?0??codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA PROC ; `Json::codePointToUTF8'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN11@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA ENDP ; `Json::codePointToUTF8'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_tool.h
;	COMDAT ?fixNumericLocaleInput@Json@@YAXPEAD0@Z
_TEXT	SEGMENT
begin$ = 48
end$ = 56
?fixNumericLocaleInput@Json@@YAXPEAD0@Z PROC		; Json::fixNumericLocaleInput, COMDAT

; 103  : static inline void fixNumericLocaleInput(char* begin, char* end) {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 30   :   struct lconv* lc = localeconv();

	call	QWORD PTR __imp_localeconv

; 31   :   return lc ? *(lc->decimal_point) : '\0';

	test	rax, rax
	je	SHORT $LN2@fixNumeric
	mov	rax, QWORD PTR [rax]
	movzx	ecx, BYTE PTR [rax]

; 104  :   char decimalPoint = getDecimalPoint();
; 105  :   if (decimalPoint != '\0' && decimalPoint != '.') {

	test	cl, cl
	je	SHORT $LN2@fixNumeric
	cmp	cl, 46					; 0000002eH
	je	SHORT $LN2@fixNumeric

; 106  :     while (begin < end) {

	xor	eax, eax
	mov	rdx, rdi
	sub	rdx, rbx
	cmp	rbx, rdi
	cmova	rdx, rax
	test	rdx, rdx
	je	SHORT $LN2@fixNumeric
	npad	2
$LL13@fixNumeric:

; 107  :       if (*begin == '.') {

	cmp	BYTE PTR [rbx], 46			; 0000002eH
	jne	SHORT $LN14@fixNumeric

; 108  :         *begin = decimalPoint;

	mov	BYTE PTR [rbx], cl
$LN14@fixNumeric:

; 109  :       }
; 110  :       ++begin;

	inc	rax
	inc	rbx
	cmp	rax, rdx
	jb	SHORT $LL13@fixNumeric
$LN2@fixNumeric:

; 111  :     }
; 112  :   }
; 113  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?fixNumericLocaleInput@Json@@YAXPEAD0@Z ENDP		; Json::fixNumericLocaleInput
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ??0Features@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Features@Json@@QEAA@XZ PROC				; Json::Features::Features, COMDAT

; 68   :       allowDroppedNullPlaceholders_(false), allowNumericKeys_(false) {}

	mov	DWORD PTR [rcx], 1
	mov	rax, rcx
	ret	0
??0Features@Json@@QEAA@XZ ENDP				; Json::Features::Features
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?all@Features@Json@@SA?AV12@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 8
?all@Features@Json@@SA?AV12@XZ PROC			; Json::Features::all, COMDAT

; 68   :       allowDroppedNullPlaceholders_(false), allowNumericKeys_(false) {}

	mov	DWORD PTR [rcx], 1

; 70   : Features Features::all() { return Features(); }

	mov	rax, rcx
	ret	0
?all@Features@Json@@SA?AV12@XZ ENDP			; Json::Features::all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?containsNewLine@Json@@YA_NPEBD0@Z
_TEXT	SEGMENT
begin$ = 8
end$ = 16
?containsNewLine@Json@@YA_NPEBD0@Z PROC			; Json::containsNewLine, COMDAT

; 85   :   for (; begin < end; ++begin)

	cmp	rcx, rdx
	jae	SHORT $LN3@containsNe
$LL5@containsNe:

; 86   :     if (*begin == '\n' || *begin == '\r')

	movzx	eax, BYTE PTR [rcx]
	cmp	al, 10
	je	SHORT $LN9@containsNe
	cmp	al, 13
	je	SHORT $LN9@containsNe

; 85   :   for (; begin < end; ++begin)

	inc	rcx
	cmp	rcx, rdx
	jb	SHORT $LL5@containsNe
$LN3@containsNe:

; 88   :   return false;

	xor	al, al

; 89   : }

	ret	0
$LN9@containsNe:

; 87   :       return true;

	mov	al, 1

; 89   : }

	ret	0
?containsNewLine@Json@@YA_NPEBD0@Z ENDP			; Json::containsNewLine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
_TEXT	SEGMENT
token$ = 32
root$GSCopy$ = 56
$T1 = 64
info$2 = 80
$T3 = 144
__$ArrayPad$ = 176
this$ = 272
beginDoc$ = 280
endDoc$ = 288
root$ = 296
collectComments$dead$ = 304
?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z PROC	; Json::Reader::parse, COMDAT

; 129  :                    bool collectComments) {

$LN270:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-23]
	sub	rsp, 200				; 000000c8H
	mov	QWORD PTR $T1[rbp-177], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-177], rax
	mov	r14, r9
	mov	r13, r8
	mov	r12, rdx
	mov	rbx, rcx
	mov	QWORD PTR root$GSCopy$[rbp-177], r9
	mov	al, 1

; 130  :   if (!features_.allowComments_) {

	movzx	eax, al
	xor	esi, esi
	cmp	BYTE PTR [rcx+184], sil
	cmove	eax, esi
	mov	QWORD PTR [rcx+112], rdx

; 131  :     collectComments = false;
; 132  :   }
; 133  : 
; 134  :   begin_ = beginDoc;
; 135  :   end_ = endDoc;

	mov	QWORD PTR [rcx+120], r8

; 136  :   collectComments_ = collectComments;

	mov	BYTE PTR [rcx+188], al

; 137  :   current_ = begin_;

	mov	QWORD PTR [rcx+128], rdx

; 138  :   lastValueEnd_ = 0;

	mov	QWORD PTR [rcx+136], rsi

; 139  :   lastValue_ = 0;

	mov	QWORD PTR [rcx+144], rsi

; 140  :   commentsBefore_.clear();

	lea	rdi, QWORD PTR [rcx+152]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], rsi

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN16@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rdi]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN17@parse
$LN16@parse:
	mov	rax, rdi
$LN17@parse:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax], sil
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 141  :   errors_.clear();

	lea	r15, QWORD PTR [rcx+40]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1643 : 		_Tidy();

	mov	rcx, r15
	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 1362 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+32], rsi
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 142  :   while (!nodes_.empty())

	je	SHORT $LN4@parse
	mov	rax, QWORD PTR [rbx+32]
$LL5@parse:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1491 : 		if (--this->_Mysize == 0)

	dec	rax
	jne	SHORT $LN30@parse

; 1492 : 			this->_Myoff = 0;

	mov	QWORD PTR [rbx+24], rsi
$LN30@parse:

; 1362 : 		return (this->_Mysize == 0);

	test	rax, rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 142  :   while (!nodes_.empty())

	jne	SHORT $LL5@parse
	mov	QWORD PTR [rbx+32], rax
$LN4@parse:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	lea	rdx, QWORD PTR root$GSCopy$[rbp-177]
	mov	rcx, rbx
	call	?push_back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::push_back
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 146  :   bool successful = readValue();

	mov	rcx, rbx
	call	?readValue@Reader@Json@@AEAA_NXZ	; Json::Reader::readValue
	movzx	esi, al

; 147  :   Token token;
; 148  :   skipCommentTokens(token);

	lea	rdx, QWORD PTR token$[rsp]
	mov	rcx, rbx
	call	?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z ; Json::Reader::skipCommentTokens

; 149  :   if (collectComments_ && !commentsBefore_.empty())

	cmp	BYTE PTR [rbx+188], 0
	je	SHORT $LN43@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+168], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 149  :   if (collectComments_ && !commentsBefore_.empty())

	je	SHORT $LN43@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1749 : 		return (this->_Mysize);

	mov	r8, QWORD PTR [rdi+16]

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN52@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rdi, QWORD PTR [rdi]
$LN52@parse:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1407 :   setComment(comment.c_str(), comment.length(), placement);

	mov	r9d, 2
	mov	rdx, rdi
	mov	rcx, r14
	call	?setComment@Value@Json@@QEAAXPEBD_KW4CommentPlacement@2@@Z ; Json::Value::setComment
$LN43@parse:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 151  :   if (features_.strictRoot_) {

	cmp	BYTE PTR [rbx+185], 0
	je	$LN1@parse
	movzx	eax, BYTE PTR [r14+8]
	sub	al, 6
	cmp	al, 1
	jbe	$LN1@parse

; 152  :     if (!root.isArray() && !root.isObject()) {
; 153  :       // Set error location to start of doc, ideally should be first token found
; 154  :       // in doc
; 155  :       token.type_ = tokenError;

	mov	DWORD PTR token$[rsp], 13

; 156  :       token.start_ = beginDoc;

	mov	QWORD PTR token$[rsp+8], r12

; 157  :       token.end_ = endDoc;

	mov	QWORD PTR token$[rsp+16], r13
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rbp-153], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	ebx, ebx
	mov	QWORD PTR $T3[rbp-161], rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rbp-177], bl
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+65]
	lea	rdx, OFFSET FLAT:??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
	lea	rcx, QWORD PTR $T3[rbp-177]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR info$2[rbp-129], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$2[rbp-137], rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$2[rbp-153], bl
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 756  :   info.token_ = token;

	movups	xmm0, XMMWORD PTR token$[rsp]
	movaps	XMMWORD PTR info$2[rbp-177], xmm0
	movsdx	xmm1, QWORD PTR token$[rsp+16]
	movsdx	QWORD PTR info$2[rbp-161], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T3[rbp-177]
	lea	rcx, QWORD PTR info$2[rbp-153]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 758  :   info.extra_ = extra;

	mov	QWORD PTR info$2[rbp-121], rbx

; 759  :   errors_.push_back(info);

	lea	rdx, QWORD PTR info$2[rbp-177]
	mov	rcx, r15
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$2[rbp-129], 16
	jb	SHORT $LN222@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$2[rbp-153]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN222@parse:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T3[rbp-153], 16
	jb	SHORT $LN254@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T3[rbp-177]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN254@parse:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 161  :       return false;

	xor	al, al
	jmp	SHORT $LN7@parse
$LN1@parse:

; 162  :     }
; 163  :   }
; 164  :   return successful;

	movzx	eax, sil
$LN7@parse:

; 165  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-177]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z ENDP	; Json::Reader::parse
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
root$GSCopy$ = 56
$T1 = 64
info$2 = 80
$T3 = 144
__$ArrayPad$ = 176
this$ = 272
beginDoc$ = 280
endDoc$ = 288
root$ = 296
collectComments$dead$ = 304
?dtor$0@?0??parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA PROC ; `Json::Reader::parse'::`1'::dtor$0
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA ENDP ; `Json::Reader::parse'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
root$GSCopy$ = 56
$T1 = 64
info$2 = 80
$T3 = 144
__$ArrayPad$ = 176
this$ = 272
beginDoc$ = 280
endDoc$ = 288
root$ = 296
collectComments$dead$ = 304
?dtor$1@?0??parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA PROC ; `Json::Reader::parse'::`1'::dtor$1
	lea	rcx, QWORD PTR info$2[rdx]
	jmp	??1ErrorInfo@Reader@Json@@QEAA@XZ
?dtor$1@?0??parse@Reader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA ENDP ; `Json::Reader::parse'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readValue@Reader@Json@@AEAA_NXZ
_TEXT	SEGMENT
token$ = 32
$T1 = 56
$T2 = 64
$T3 = 64
info$4 = 96
$T5 = 96
$T6 = 96
v$7 = 96
v$8 = 96
v$9 = 96
v$10 = 96
$T11 = 160
$T12 = 160
__$ArrayPad$ = 192
this$ = 240
?readValue@Reader@Json@@AEAA_NXZ PROC			; Json::Reader::readValue, COMDAT

; 167  : bool Reader::readValue() {

$LN516:
	mov	rax, rsp
	push	rbp
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 208				; 000000d0H
	mov	QWORD PTR $T1[rbp-137], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-137], rax
	mov	rdi, rcx

; 171  :   if (nodes_.size() > stackLimit_g) throwRuntimeError("Exceeded stackLimit in readValue().");

	cmp	QWORD PTR [rcx+32], 1000		; 000003e8H
	jbe	SHORT $LN102@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T12[rbp-113], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	esi, esi
	mov	QWORD PTR $T12[rbp-121], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T12[rbp-137], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+35]
	lea	rdx, OFFSET FLAT:??_C@_0CE@OOHDBGBA@Exceeded?5stackLimit?5in?5readValue@
	lea	rcx, QWORD PTR $T12[rbp-137]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 171  :   if (nodes_.size() > stackLimit_g) throwRuntimeError("Exceeded stackLimit in readValue().");

	lea	rcx, QWORD PTR $T12[rbp-137]
	call	?throwRuntimeError@Json@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::throwRuntimeError
	npad	1
$LN102@readValue:

; 172  : 
; 173  :   Token token;
; 174  :   skipCommentTokens(token);

	lea	rdx, QWORD PTR token$[rbp-137]
	call	?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z ; Json::Reader::skipCommentTokens

; 175  :   bool successful = true;

	mov	r14b, 1

; 177  :   if (collectComments_ && !commentsBefore_.empty()) {

	xor	esi, esi
	cmp	BYTE PTR [rdi+188], sil
	je	SHORT $LN128@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rdi+168], rsi
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 177  :   if (collectComments_ && !commentsBefore_.empty()) {

	je	SHORT $LN128@readValue

; 178  :     currentValue().setComment(commentsBefore_, commentBefore);

	lea	rbx, QWORD PTR [rdi+152]
	mov	rcx, rdi
	call	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ; Json::Reader::currentValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN114@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rdx, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	jmp	SHORT $LN115@readValue
$LN114@readValue:
	mov	rdx, rbx
$LN115@readValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1407 :   setComment(comment.c_str(), comment.length(), placement);

	xor	r9d, r9d
	mov	r8, QWORD PTR [rbx+16]
	mov	rcx, rax
	call	?setComment@Value@Json@@QEAAXPEBD_KW4CommentPlacement@2@@Z ; Json::Value::setComment
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rsi

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN125@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rbx, QWORD PTR [rbx]
$LN125@readValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], sil
$LN128@readValue:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 182  :   switch (token.type_) {

	mov	eax, DWORD PTR token$[rbp-137]
	dec	eax
	cmp	eax, 9
	ja	$LN3@readValue
	cdqe
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN509@readValue[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN11@readValue:

; 183  :   case tokenObjectBegin:
; 184  :     successful = readObject(token);

	lea	rdx, QWORD PTR token$[rbp-137]
	mov	rcx, rdi
	call	?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readObject
$LN513@readValue:
	movzx	r14d, al

; 185  :     currentValue().setOffsetLimit(current_ - begin_);

	mov	rbx, QWORD PTR [rdi+128]
	sub	rbx, QWORD PTR [rdi+112]
	mov	rcx, rdi
	call	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ; Json::Reader::currentValue
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1422 : void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

	mov	QWORD PTR [rax+32], rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 186  :     break;

	jmp	$LN12@readValue
$LN10@readValue:

; 187  :   case tokenArrayBegin:
; 188  :     successful = readArray(token);

	lea	rdx, QWORD PTR token$[rbp-137]
	mov	rcx, rdi
	call	?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readArray

; 189  :     currentValue().setOffsetLimit(current_ - begin_);
; 190  :     break;

	jmp	SHORT $LN513@readValue
$LN9@readValue:

; 191  :   case tokenNumber:
; 192  :     successful = decodeNumber(token);

	lea	rdx, QWORD PTR token$[rbp-137]
	mov	rcx, rdi
	call	?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::decodeNumber
	movzx	r14d, al

; 193  :     break;

	jmp	$LN12@readValue
$LN8@readValue:

; 194  :   case tokenString:
; 195  :     successful = decodeString(token);

	lea	rdx, QWORD PTR token$[rbp-137]
	mov	rcx, rdi
	call	?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::decodeString
	movzx	r14d, al

; 196  :     break;

	jmp	$LN12@readValue
$LN7@readValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 431  :   value_.bool_ = value;

	mov	BYTE PTR v$10[rbp-137], 1
$LN514@readValue:
	mov	ebx, DWORD PTR v$10[rbp-129]
	and	ebx, -507				; fffffe05H

; 1023 :   allocated_ = allocated;

	or	ebx, 5
$LN515@readValue:
	xorps	xmm0, xmm0
	mov	DWORD PTR v$10[rbp-129], ebx
	movdqu	XMMWORD PTR v$10[rbp-121], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR v$10[rbp-105], rsi
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 200  :     currentValue().swapPayload(v);

	mov	rcx, rdi
	call	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ; Json::Reader::currentValue
	mov	r8, rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	edx, BYTE PTR [rax+8]

; 518  :   type_ = other.type_;

	movzx	ecx, bl
	mov	BYTE PTR [rax+8], bl

; 519  :   other.type_ = temp;

	mov	ecx, ebx
	xor	ecx, edx
	movzx	ecx, cl
	xor	ebx, ecx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rcx, QWORD PTR [rax]

; 53   : 	_Left = _Move(_Right);

	mov	rdx, QWORD PTR v$10[rbp-137]
	mov	QWORD PTR [rax], rdx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR v$10[rbp-137], rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [rax+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, ecx
	xor	eax, ebx
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, ebx
	and	edx, 256				; 00000100H
	xor	ebx, edx
	mov	DWORD PTR v$10[rbp-129], ebx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 201  :     currentValue().setOffsetStart(token.start_ - begin_);

	mov	rbx, QWORD PTR token$[rbp-129]
	sub	rbx, QWORD PTR [rdi+112]
	mov	rcx, rdi
	call	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ; Json::Reader::currentValue
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rax+24], rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 202  :     currentValue().setOffsetLimit(token.end_ - begin_);

	mov	rbx, QWORD PTR token$[rbp-121]

; 203  :     }
; 204  :     break;

	jmp	$LN511@readValue
$LN6@readValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 431  :   value_.bool_ = value;

	mov	BYTE PTR v$9[rbp-137], sil
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 212  :     break;

	jmp	$LN514@readValue
$LN5@readValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	mov	ebx, DWORD PTR v$8[rbp-129]
	and	ebx, -512				; fffffe00H
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 220  :     break;

	jmp	$LN515@readValue
$LN4@readValue:

; 221  :   case tokenArraySeparator:
; 222  :   case tokenObjectEnd:
; 223  :   case tokenArrayEnd:
; 224  :     if (features_.allowDroppedNullPlaceholders_) {

	cmp	BYTE PTR [rdi+186], sil
	je	$LN3@readValue

; 225  :       // "Un-read" the current token and mark the current value as a null
; 226  :       // token.
; 227  :       current_--;

	dec	QWORD PTR [rdi+128]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	mov	ebx, DWORD PTR v$7[rbp-129]
	and	ebx, -512				; fffffe00H
	mov	DWORD PTR v$7[rbp-129], ebx
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR v$7[rbp-121], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR v$7[rbp-105], rsi
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 229  :       currentValue().swapPayload(v);

	mov	rcx, rdi
	call	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ; Json::Reader::currentValue
	mov	r8, rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	edx, BYTE PTR [rax+8]

; 518  :   type_ = other.type_;

	movzx	ecx, bl
	mov	BYTE PTR [rax+8], bl

; 519  :   other.type_ = temp;

	mov	ecx, ebx
	xor	ecx, edx
	movzx	ecx, cl
	xor	ebx, ecx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rcx, QWORD PTR [rax]

; 53   : 	_Left = _Move(_Right);

	mov	rdx, QWORD PTR v$7[rbp-137]
	mov	QWORD PTR [rax], rdx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR v$7[rbp-137], rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [rax+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, ecx
	xor	eax, ebx
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, ebx
	and	edx, 256				; 00000100H
	xor	ebx, edx
	mov	DWORD PTR v$7[rbp-129], ebx

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	rbx, QWORD PTR [rdi+128]
	sub	rbx, QWORD PTR [rdi+112]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 230  :       currentValue().setOffsetStart(current_ - begin_ - 1);

	dec	rbx
	mov	rcx, rdi
	call	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ; Json::Reader::currentValue
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rax+24], rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 231  :       currentValue().setOffsetLimit(current_ - begin_);

	mov	rbx, QWORD PTR [rdi+128]
$LN511@readValue:
	sub	rbx, QWORD PTR [rdi+112]
	mov	rcx, rdi
	call	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ; Json::Reader::currentValue
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1422 : void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

	mov	QWORD PTR [rax+32], rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 232  :       break;

	lea	rcx, QWORD PTR v$7[rbp-137]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
$LN12@readValue:

; 238  :   }
; 239  : 
; 240  :   if (collectComments_) {

	cmp	BYTE PTR [rdi+188], sil
	je	SHORT $LN1@readValue

; 241  :     lastValueEnd_ = current_;

	mov	rax, QWORD PTR [rdi+128]
	mov	QWORD PTR [rdi+136], rax

; 242  :     lastValue_ = &currentValue();

	mov	rcx, rdi
	call	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ; Json::Reader::currentValue
	mov	QWORD PTR [rdi+144], rax
$LN1@readValue:

; 243  :   }
; 244  : 
; 245  :   return successful;

	movzx	eax, r14b
	jmp	$LN16@readValue
$LN3@readValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T3[rbp-137]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T6[rbp-137]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN278@readValue
	mov	r8, rsi
	jmp	SHORT $LN279@readValue
$LN278@readValue:
	mov	r8, QWORD PTR [r8]
$LN279@readValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 233  :     } // Else, fall through...
; 234  :   default:
; 235  :     currentValue().setOffsetStart(token.start_ - begin_);

	mov	rax, QWORD PTR token$[rbp-129]
	sub	rax, QWORD PTR [rdi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rdx+24], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T5[rbp-137]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T2[rbp-137]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN296@readValue
	mov	r8, rsi
	jmp	SHORT $LN297@readValue
$LN296@readValue:
	mov	r8, QWORD PTR [r8]
$LN297@readValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 236  :     currentValue().setOffsetLimit(token.end_ - begin_);

	mov	rax, QWORD PTR token$[rbp-121]
	sub	rax, QWORD PTR [rdi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1422 : void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

	mov	QWORD PTR [rdx+32], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T11[rbp-113], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T11[rbp-121], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T11[rbp-137], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 46					; 0000002eH
	lea	rdx, OFFSET FLAT:??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
	lea	rcx, QWORD PTR $T11[rbp-137]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR info$4[rbp-89], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$4[rbp-97], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$4[rbp-113], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 756  :   info.token_ = token;

	movups	xmm0, XMMWORD PTR token$[rbp-137]
	movaps	XMMWORD PTR info$4[rbp-137], xmm0
	movsdx	xmm1, QWORD PTR token$[rbp-121]
	movsdx	QWORD PTR info$4[rbp-121], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T11[rbp-137]
	lea	rcx, QWORD PTR info$4[rbp-113]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 758  :   info.extra_ = extra;

	mov	QWORD PTR info$4[rbp-81], rsi

; 759  :   errors_.push_back(info);

	lea	rcx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR info$4[rbp-137]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$4[rbp-89], 16
	jb	SHORT $LN465@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$4[rbp-113]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN465@readValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T11[rbp-113], 16
	jb	SHORT $LN497@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T11[rbp-137]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN497@readValue:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 237  :     return addError("Syntax error: value, object or array expected.", token);

	xor	al, al
$LN16@readValue:

; 246  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-137]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
$LN510@readValue:
	npad	3
$LN509@readValue:
	DD	$LN11@readValue
	DD	$LN4@readValue
	DD	$LN10@readValue
	DD	$LN4@readValue
	DD	$LN8@readValue
	DD	$LN9@readValue
	DD	$LN7@readValue
	DD	$LN6@readValue
	DD	$LN5@readValue
	DD	$LN4@readValue
?readValue@Reader@Json@@AEAA_NXZ ENDP			; Json::Reader::readValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
$T1 = 56
$T2 = 64
$T3 = 64
info$4 = 96
$T5 = 96
$T6 = 96
v$7 = 96
v$8 = 96
v$9 = 96
v$10 = 96
$T11 = 160
$T12 = 160
__$ArrayPad$ = 192
this$ = 240
?dtor$0@?0??readValue@Reader@Json@@AEAA_NXZ@4HA PROC	; `Json::Reader::readValue'::`1'::dtor$0
	lea	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??readValue@Reader@Json@@AEAA_NXZ@4HA ENDP	; `Json::Reader::readValue'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
$T1 = 56
$T2 = 64
$T3 = 64
info$4 = 96
$T5 = 96
$T6 = 96
v$7 = 96
v$8 = 96
v$9 = 96
v$10 = 96
$T11 = 160
$T12 = 160
__$ArrayPad$ = 192
this$ = 240
?dtor$5@?0??readValue@Reader@Json@@AEAA_NXZ@4HA PROC	; `Json::Reader::readValue'::`1'::dtor$5
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??readValue@Reader@Json@@AEAA_NXZ@4HA ENDP	; `Json::Reader::readValue'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
$T1 = 56
$T2 = 64
$T3 = 64
info$4 = 96
$T5 = 96
$T6 = 96
v$7 = 96
v$8 = 96
v$9 = 96
v$10 = 96
$T11 = 160
$T12 = 160
__$ArrayPad$ = 192
this$ = 240
?dtor$16@?0??readValue@Reader@Json@@AEAA_NXZ@4HA PROC	; `Json::Reader::readValue'::`1'::dtor$16
	lea	rcx, QWORD PTR info$4[rdx]
	jmp	??1ErrorInfo@Reader@Json@@QEAA@XZ
?dtor$16@?0??readValue@Reader@Json@@AEAA_NXZ@4HA ENDP	; `Json::Reader::readValue'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z
_TEXT	SEGMENT
this$ = 64
token$ = 72
?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z PROC ; Json::Reader::skipCommentTokens, COMDAT

; 248  : void Reader::skipCommentTokens(Token& token) {

$LN102:
	push	rbx
	push	rdi
	sub	rsp, 40					; 00000028H

; 249  :   if (features_.allowComments_) {

	cmp	BYTE PTR [rcx+184], 0
	mov	rdi, rdx
	mov	rbx, rcx
	je	$LN5@skipCommen
	mov	QWORD PTR [rsp+64], rbp
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+80], r12
	mov	QWORD PTR [rsp+88], r14
	mov	QWORD PTR [rsp+32], r15

; 344  :     if (current_[index] != pattern[index])

	mov	rbp, 4294977024				; 0000000100002600H
	lea	r15, OFFSET FLAT:??_C@_04KCECFHEP@alse?$AA@+4
	lea	rsi, OFFSET FLAT:__ImageBase
	lea	r14, OFFSET FLAT:??_C@_03FFDNHNKN@rue?$AA@+3
	lea	r12, OFFSET FLAT:??_C@_03KNPGGKC@ull?$AA@+3
	npad	7
$LL4@skipCommen:

; 326  :   return true;
; 327  : }
; 328  : 
; 329  : void Reader::skipSpaces() {
; 330  :   while (current_ != end_) {

	mov	rdx, QWORD PTR [rbx+120]
	cmp	QWORD PTR [rbx+128], rdx
	je	SHORT $LN97@skipCommen
	npad	3
$LL31@skipCommen:

; 331  :     Char c = *current_;

	mov	rcx, QWORD PTR [rbx+128]
	movzx	eax, BYTE PTR [rcx]
	cmp	al, 32					; 00000020H
	ja	SHORT $LN97@skipCommen
	bt	rbp, rax
	jae	SHORT $LN97@skipCommen

; 332  :     if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
; 333  :       ++current_;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx+128], rax
	cmp	rax, rdx
	jne	SHORT $LL31@skipCommen
$LN97@skipCommen:

; 257  : 
; 258  : bool Reader::readToken(Token& token) {
; 259  :   skipSpaces();
; 260  :   token.start_ = current_;

	mov	rax, QWORD PTR [rbx+128]
	mov	QWORD PTR [rdi+8], rax

; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)

	mov	rax, QWORD PTR [rbx+128]
	cmp	rax, QWORD PTR [rbx+120]
	jne	SHORT $LN34@skipCommen

; 787  :     return 0;

	xor	cl, cl
	jmp	SHORT $LN35@skipCommen
$LN34@skipCommen:

; 788  :   return *current_++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+128], rax
$LN35@skipCommen:

; 261  :   Char c = getNextChar();
; 262  :   bool ok = true;
; 263  :   switch (c) {

	movsx	rax, cl
	cmp	eax, 125				; 0000007dH
	ja	$LN93@skipCommen
	movzx	eax, BYTE PTR $LN95@skipCommen[rsi+rax]
	mov	ecx, DWORD PTR $LN96@skipCommen[rsi+rax*4]
	add	rcx, rsi
	jmp	rcx
$LN22@skipCommen:

; 264  :   case '{':
; 265  :     token.type_ = tokenObjectBegin;

	mov	DWORD PTR [rdi], 1

; 266  :     break;

	jmp	$LN8@skipCommen
$LN21@skipCommen:

; 267  :   case '}':
; 268  :     token.type_ = tokenObjectEnd;

	mov	DWORD PTR [rdi], 2

; 269  :     break;

	jmp	SHORT $LN8@skipCommen
$LN20@skipCommen:

; 270  :   case '[':
; 271  :     token.type_ = tokenArrayBegin;

	mov	DWORD PTR [rdi], 3

; 272  :     break;

	jmp	SHORT $LN8@skipCommen
$LN19@skipCommen:

; 273  :   case ']':
; 274  :     token.type_ = tokenArrayEnd;

	mov	DWORD PTR [rdi], 4

; 275  :     break;

	jmp	SHORT $LN8@skipCommen
$LN18@skipCommen:

; 276  :   case '"':
; 277  :     token.type_ = tokenString;

	mov	DWORD PTR [rdi], 5

; 347  :   return true;
; 348  : }
; 349  : 
; 350  : bool Reader::readComment() {
; 351  :   Location commentBegin = current_ - 1;
; 352  :   Char c = getNextChar();
; 353  :   bool successful = false;
; 354  :   if (c == '*')
; 355  :     successful = readCStyleComment();
; 356  :   else if (c == '/')
; 357  :     successful = readCppStyleComment();
; 358  :   if (!successful)
; 359  :     return false;
; 360  : 
; 361  :   if (collectComments_) {
; 362  :     CommentPlacement placement = commentBefore;
; 363  :     if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
; 364  :       if (c != '*' || !containsNewLine(commentBegin, current_))
; 365  :         placement = commentAfterOnSameLine;
; 366  :     }
; 367  : 
; 368  :     addComment(commentBegin, current_, placement);
; 369  :   }
; 370  :   return true;
; 371  : }
; 372  : 
; 373  : static JSONCPP_STRING normalizeEOL(Reader::Location begin, Reader::Location end) {
; 374  :   JSONCPP_STRING normalized;
; 375  :   normalized.reserve(static_cast<size_t>(end - begin));
; 376  :   Reader::Location current = begin;
; 377  :   while (current != end) {
; 378  :     char c = *current++;
; 379  :     if (c == '\r') {
; 380  :       if (current != end && *current == '\n')
; 381  :          // convert dos EOL
; 382  :          ++current;
; 383  :       // convert Mac EOL
; 384  :       normalized += '\n';
; 385  :     } else {
; 386  :       normalized += c;
; 387  :     }
; 388  :   }
; 389  :   return normalized;
; 390  : }
; 391  : 
; 392  : void
; 393  : Reader::addComment(Location begin, Location end, CommentPlacement placement) {
; 394  :   assert(collectComments_);
; 395  :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
; 396  :   if (placement == commentAfterOnSameLine) {
; 397  :     assert(lastValue_ != 0);
; 398  :     lastValue_->setComment(normalized, placement);
; 399  :   } else {
; 400  :     commentsBefore_ += normalized;
; 401  :   }
; 402  : }
; 403  : 
; 404  : bool Reader::readCStyleComment() {
; 405  :   while ((current_ + 1) < end_) {
; 406  :     Char c = getNextChar();
; 407  :     if (c == '*' && *current_ == '/')
; 408  :       break;
; 409  :   }
; 410  :   return getNextChar() == '/';
; 411  : }
; 412  : 
; 413  : bool Reader::readCppStyleComment() {
; 414  :   while (current_ != end_) {
; 415  :     Char c = getNextChar();
; 416  :     if (c == '\n')
; 417  :       break;
; 418  :     if (c == '\r') {
; 419  :       // Consume DOS EOL. It will be normalized in addComment.
; 420  :       if (current_ != end_ && *current_ == '\n')
; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;
; 427  : }
; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {

	mov	rax, QWORD PTR [rbx+128]
	mov	rdx, QWORD PTR [rbx+120]
	xor	cl, cl
	cmp	rax, rdx
	je	SHORT $LN98@skipCommen
$LN44@skipCommen:

; 788  :   return *current_++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+128], rax

; 454  :     c = getNextChar();
; 455  :     if (c == '\\')

	cmp	cl, 92					; 0000005cH
	jne	SHORT $LN39@skipCommen

; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)

	cmp	rax, rdx
	je	SHORT $LN37@skipCommen

; 788  :   return *current_++;

	inc	rax
	mov	QWORD PTR [rbx+128], rax

; 456  :       getNextChar();
; 457  :     else if (c == '"')

	jmp	SHORT $LN37@skipCommen
$LN39@skipCommen:
	cmp	cl, 34					; 00000022H
	je	SHORT $LN99@skipCommen
$LN37@skipCommen:

; 347  :   return true;
; 348  : }
; 349  : 
; 350  : bool Reader::readComment() {
; 351  :   Location commentBegin = current_ - 1;
; 352  :   Char c = getNextChar();
; 353  :   bool successful = false;
; 354  :   if (c == '*')
; 355  :     successful = readCStyleComment();
; 356  :   else if (c == '/')
; 357  :     successful = readCppStyleComment();
; 358  :   if (!successful)
; 359  :     return false;
; 360  : 
; 361  :   if (collectComments_) {
; 362  :     CommentPlacement placement = commentBefore;
; 363  :     if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
; 364  :       if (c != '*' || !containsNewLine(commentBegin, current_))
; 365  :         placement = commentAfterOnSameLine;
; 366  :     }
; 367  : 
; 368  :     addComment(commentBegin, current_, placement);
; 369  :   }
; 370  :   return true;
; 371  : }
; 372  : 
; 373  : static JSONCPP_STRING normalizeEOL(Reader::Location begin, Reader::Location end) {
; 374  :   JSONCPP_STRING normalized;
; 375  :   normalized.reserve(static_cast<size_t>(end - begin));
; 376  :   Reader::Location current = begin;
; 377  :   while (current != end) {
; 378  :     char c = *current++;
; 379  :     if (c == '\r') {
; 380  :       if (current != end && *current == '\n')
; 381  :          // convert dos EOL
; 382  :          ++current;
; 383  :       // convert Mac EOL
; 384  :       normalized += '\n';
; 385  :     } else {
; 386  :       normalized += c;
; 387  :     }
; 388  :   }
; 389  :   return normalized;
; 390  : }
; 391  : 
; 392  : void
; 393  : Reader::addComment(Location begin, Location end, CommentPlacement placement) {
; 394  :   assert(collectComments_);
; 395  :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
; 396  :   if (placement == commentAfterOnSameLine) {
; 397  :     assert(lastValue_ != 0);
; 398  :     lastValue_->setComment(normalized, placement);
; 399  :   } else {
; 400  :     commentsBefore_ += normalized;
; 401  :   }
; 402  : }
; 403  : 
; 404  : bool Reader::readCStyleComment() {
; 405  :   while ((current_ + 1) < end_) {
; 406  :     Char c = getNextChar();
; 407  :     if (c == '*' && *current_ == '/')
; 408  :       break;
; 409  :   }
; 410  :   return getNextChar() == '/';
; 411  : }
; 412  : 
; 413  : bool Reader::readCppStyleComment() {
; 414  :   while (current_ != end_) {
; 415  :     Char c = getNextChar();
; 416  :     if (c == '\n')
; 417  :       break;
; 418  :     if (c == '\r') {
; 419  :       // Consume DOS EOL. It will be normalized in addComment.
; 420  :       if (current_ != end_ && *current_ == '\n')
; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;
; 427  : }
; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {

	mov	rax, QWORD PTR [rbx+128]
	cmp	rax, rdx
	jne	SHORT $LN44@skipCommen
$LN98@skipCommen:

; 458  :       break;
; 459  :   }
; 460  :   return c == '"';

	cmp	cl, 34					; 00000022H
$LN99@skipCommen:
	sete	al

; 278  :     ok = readString();
; 279  :     break;

	jmp	SHORT $LN23@skipCommen
$LN17@skipCommen:

; 280  :   case '/':
; 281  :     token.type_ = tokenComment;
; 282  :     ok = readComment();

	mov	rcx, rbx
	mov	DWORD PTR [rdi], 12
	call	?readComment@Reader@Json@@AEAA_NXZ	; Json::Reader::readComment
$LN23@skipCommen:

; 319  :   default:
; 320  :     ok = false;
; 321  :     break;
; 322  :   }
; 323  :   if (!ok)

	test	al, al
	jne	SHORT $LN8@skipCommen
$LN93@skipCommen:

; 324  :     token.type_ = tokenError;

	mov	DWORD PTR [rdi], 13
$LN8@skipCommen:

; 250  :     do {
; 251  :       readToken(token);
; 252  :     } while (token.type_ == tokenComment);

	cmp	DWORD PTR [rdi], 12

; 325  :   token.end_ = current_;

	mov	rax, QWORD PTR [rbx+128]
	mov	QWORD PTR [rdi+16], rax

; 250  :     do {
; 251  :       readToken(token);
; 252  :     } while (token.type_ == tokenComment);

	je	$LL4@skipCommen
	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+64]

; 255  :   }
; 256  : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbx
	ret	0
$LN16@skipCommen:

; 283  :     break;
; 284  :   case '0':
; 285  :   case '1':
; 286  :   case '2':
; 287  :   case '3':
; 288  :   case '4':
; 289  :   case '5':
; 290  :   case '6':
; 291  :   case '7':
; 292  :   case '8':
; 293  :   case '9':
; 294  :   case '-':
; 295  :     token.type_ = tokenNumber;
; 296  :     readNumber();

	mov	rcx, rbx
	mov	DWORD PTR [rdi], 6
	call	?readNumber@Reader@Json@@AEAAXXZ	; Json::Reader::readNumber

; 297  :     break;

	jmp	SHORT $LN8@skipCommen
$LN15@skipCommen:

; 298  :   case 't':
; 299  :     token.type_ = tokenTrue;

	mov	DWORD PTR [rdi], 7

; 334  :     else
; 335  :       break;
; 336  :   }
; 337  : }
; 338  : 
; 339  : bool Reader::match(Location pattern, int patternLength) {
; 340  :   if (end_ - current_ < patternLength)

	mov	r9, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r9
	cmp	rax, 3
	jl	SHORT $LN93@skipCommen

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	mov	r8, r9
	mov	edx, 3
	sub	r8, r14
	npad	10
$LL52@skipCommen:
	dec	rdx

; 344  :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_03FFDNHNKN@rue?$AA@[rsi]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r8+rcx+3], al
	jne	$LN93@skipCommen

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL52@skipCommen

; 345  :       return false;
; 346  :   current_ += patternLength;

	lea	rax, QWORD PTR [r9+3]
	mov	QWORD PTR [rbx+128], rax

; 300  :     ok = match("rue", 3);
; 301  :     break;

	jmp	$LN8@skipCommen
$LN14@skipCommen:

; 302  :   case 'f':
; 303  :     token.type_ = tokenFalse;

	mov	DWORD PTR [rdi], 8

; 334  :     else
; 335  :       break;
; 336  :   }
; 337  : }
; 338  : 
; 339  : bool Reader::match(Location pattern, int patternLength) {
; 340  :   if (end_ - current_ < patternLength)

	mov	r9, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r9
	cmp	rax, 4
	jl	$LN93@skipCommen

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	mov	r8, r9
	mov	edx, 4
	sub	r8, r15
	npad	7
$LL58@skipCommen:
	dec	rdx

; 344  :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_04KCECFHEP@alse?$AA@[rsi]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r8+rcx+4], al
	jne	$LN93@skipCommen

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL58@skipCommen

; 345  :       return false;
; 346  :   current_ += patternLength;

	lea	rax, QWORD PTR [r9+4]
	mov	QWORD PTR [rbx+128], rax

; 304  :     ok = match("alse", 4);
; 305  :     break;

	jmp	$LN8@skipCommen
$LN13@skipCommen:

; 306  :   case 'n':
; 307  :     token.type_ = tokenNull;

	mov	DWORD PTR [rdi], 9

; 334  :     else
; 335  :       break;
; 336  :   }
; 337  : }
; 338  : 
; 339  : bool Reader::match(Location pattern, int patternLength) {
; 340  :   if (end_ - current_ < patternLength)

	mov	r9, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r9
	cmp	rax, 3
	jl	$LN93@skipCommen

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	mov	r8, r9
	mov	edx, 3
	sub	r8, r12
	npad	7
$LL64@skipCommen:
	dec	rdx

; 344  :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_03KNPGGKC@ull?$AA@[rsi]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r8+rcx+3], al
	jne	$LN93@skipCommen

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL64@skipCommen

; 345  :       return false;
; 346  :   current_ += patternLength;

	lea	rax, QWORD PTR [r9+3]
	mov	QWORD PTR [rbx+128], rax

; 308  :     ok = match("ull", 3);
; 309  :     break;

	jmp	$LN8@skipCommen
$LN12@skipCommen:

; 310  :   case ',':
; 311  :     token.type_ = tokenArraySeparator;

	mov	DWORD PTR [rdi], 10

; 312  :     break;

	jmp	$LN8@skipCommen
$LN11@skipCommen:

; 313  :   case ':':
; 314  :     token.type_ = tokenMemberSeparator;

	mov	DWORD PTR [rdi], 11

; 315  :     break;

	jmp	$LN8@skipCommen
$LN10@skipCommen:

; 316  :   case 0:
; 317  :     token.type_ = tokenEndOfStream;

	mov	DWORD PTR [rdi], 0

; 318  :     break;

	jmp	$LN8@skipCommen
$LN5@skipCommen:

; 255  :   }
; 256  : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbx

; 253  :   } else {
; 254  :     readToken(token);

	jmp	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken
$LN96@skipCommen:

; 255  :   }
; 256  : }

	DD	$LN10@skipCommen
	DD	$LN18@skipCommen
	DD	$LN12@skipCommen
	DD	$LN16@skipCommen
	DD	$LN17@skipCommen
	DD	$LN11@skipCommen
	DD	$LN20@skipCommen
	DD	$LN19@skipCommen
	DD	$LN14@skipCommen
	DD	$LN13@skipCommen
	DD	$LN15@skipCommen
	DD	$LN22@skipCommen
	DD	$LN21@skipCommen
	DD	$LN93@skipCommen
$LN95@skipCommen:
	DB	0
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	1
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	2
	DB	3
	DB	13
	DB	4
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	5
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	6
	DB	13
	DB	7
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	8
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	9
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	10
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	11
	DB	13
	DB	12
?skipCommentTokens@Reader@Json@@AEAAXAEAVToken@12@@Z ENDP ; Json::Reader::skipCommentTokens
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z
_TEXT	SEGMENT
this$ = 48
token$ = 56
?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z PROC	; Json::Reader::readToken, COMDAT

; 258  : bool Reader::readToken(Token& token) {

$LN92:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 328  : 
; 329  : void Reader::skipSpaces() {
; 330  :   while (current_ != end_) {

	mov	rdx, QWORD PTR [rcx+120]

; 258  : bool Reader::readToken(Token& token) {

	mov	rbx, rcx

; 328  : 
; 329  : void Reader::skipSpaces() {
; 330  :   while (current_ != end_) {

	cmp	QWORD PTR [rcx+128], rdx
	je	SHORT $LN87@readToken
	mov	r8, 4294977024				; 0000000100002600H
	npad	9
$LL24@readToken:

; 331  :     Char c = *current_;

	mov	rcx, QWORD PTR [rbx+128]
	movzx	eax, BYTE PTR [rcx]
	cmp	al, 32					; 00000020H
	ja	SHORT $LN87@readToken
	bt	r8, rax
	jae	SHORT $LN87@readToken

; 332  :     if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
; 333  :       ++current_;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx+128], rax
	cmp	rax, rdx
	jne	SHORT $LL24@readToken
$LN87@readToken:

; 259  :   skipSpaces();
; 260  :   token.start_ = current_;

	mov	rax, QWORD PTR [rbx+128]
	mov	QWORD PTR [rdi+8], rax

; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)

	mov	rax, QWORD PTR [rbx+128]
	cmp	rax, QWORD PTR [rbx+120]
	jne	SHORT $LN27@readToken

; 787  :     return 0;

	xor	cl, cl
	jmp	SHORT $LN28@readToken
$LN27@readToken:

; 788  :   return *current_++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+128], rax
$LN28@readToken:

; 261  :   Char c = getNextChar();
; 262  :   bool ok = true;
; 263  :   switch (c) {

	movsx	rax, cl
	cmp	eax, 125				; 0000007dH
	ja	$LN83@readToken
	lea	r10, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN85@readToken[r10+rax]
	mov	ecx, DWORD PTR $LN86@readToken[r10+rax*4]
	add	rcx, r10
	jmp	rcx
$LN15@readToken:

; 264  :   case '{':
; 265  :     token.type_ = tokenObjectBegin;

	mov	DWORD PTR [rdi], 1

; 266  :     break;

	jmp	$LN1@readToken
$LN14@readToken:

; 267  :   case '}':
; 268  :     token.type_ = tokenObjectEnd;

	mov	DWORD PTR [rdi], 2

; 269  :     break;

	jmp	SHORT $LN1@readToken
$LN13@readToken:

; 270  :   case '[':
; 271  :     token.type_ = tokenArrayBegin;

	mov	edx, 3
	mov	DWORD PTR [rdi], edx

; 272  :     break;

	jmp	SHORT $LN1@readToken
$LN12@readToken:

; 273  :   case ']':
; 274  :     token.type_ = tokenArrayEnd;

	mov	edx, 4
	mov	DWORD PTR [rdi], edx

; 275  :     break;

	jmp	SHORT $LN1@readToken
$LN11@readToken:

; 276  :   case '"':
; 277  :     token.type_ = tokenString;

	mov	DWORD PTR [rdi], 5

; 347  :   return true;
; 348  : }
; 349  : 
; 350  : bool Reader::readComment() {
; 351  :   Location commentBegin = current_ - 1;
; 352  :   Char c = getNextChar();
; 353  :   bool successful = false;
; 354  :   if (c == '*')
; 355  :     successful = readCStyleComment();
; 356  :   else if (c == '/')
; 357  :     successful = readCppStyleComment();
; 358  :   if (!successful)
; 359  :     return false;
; 360  : 
; 361  :   if (collectComments_) {
; 362  :     CommentPlacement placement = commentBefore;
; 363  :     if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
; 364  :       if (c != '*' || !containsNewLine(commentBegin, current_))
; 365  :         placement = commentAfterOnSameLine;
; 366  :     }
; 367  : 
; 368  :     addComment(commentBegin, current_, placement);
; 369  :   }
; 370  :   return true;
; 371  : }
; 372  : 
; 373  : static JSONCPP_STRING normalizeEOL(Reader::Location begin, Reader::Location end) {
; 374  :   JSONCPP_STRING normalized;
; 375  :   normalized.reserve(static_cast<size_t>(end - begin));
; 376  :   Reader::Location current = begin;
; 377  :   while (current != end) {
; 378  :     char c = *current++;
; 379  :     if (c == '\r') {
; 380  :       if (current != end && *current == '\n')
; 381  :          // convert dos EOL
; 382  :          ++current;
; 383  :       // convert Mac EOL
; 384  :       normalized += '\n';
; 385  :     } else {
; 386  :       normalized += c;
; 387  :     }
; 388  :   }
; 389  :   return normalized;
; 390  : }
; 391  : 
; 392  : void
; 393  : Reader::addComment(Location begin, Location end, CommentPlacement placement) {
; 394  :   assert(collectComments_);
; 395  :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
; 396  :   if (placement == commentAfterOnSameLine) {
; 397  :     assert(lastValue_ != 0);
; 398  :     lastValue_->setComment(normalized, placement);
; 399  :   } else {
; 400  :     commentsBefore_ += normalized;
; 401  :   }
; 402  : }
; 403  : 
; 404  : bool Reader::readCStyleComment() {
; 405  :   while ((current_ + 1) < end_) {
; 406  :     Char c = getNextChar();
; 407  :     if (c == '*' && *current_ == '/')
; 408  :       break;
; 409  :   }
; 410  :   return getNextChar() == '/';
; 411  : }
; 412  : 
; 413  : bool Reader::readCppStyleComment() {
; 414  :   while (current_ != end_) {
; 415  :     Char c = getNextChar();
; 416  :     if (c == '\n')
; 417  :       break;
; 418  :     if (c == '\r') {
; 419  :       // Consume DOS EOL. It will be normalized in addComment.
; 420  :       if (current_ != end_ && *current_ == '\n')
; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;
; 427  : }
; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {

	mov	rax, QWORD PTR [rbx+128]
	mov	rdx, QWORD PTR [rbx+120]
	xor	cl, cl
	cmp	rax, rdx
	je	SHORT $LN88@readToken
$LN37@readToken:

; 788  :   return *current_++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+128], rax

; 454  :     c = getNextChar();
; 455  :     if (c == '\\')

	cmp	cl, 92					; 0000005cH
	jne	SHORT $LN32@readToken

; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)

	cmp	rax, rdx
	je	SHORT $LN30@readToken

; 788  :   return *current_++;

	inc	rax
	mov	QWORD PTR [rbx+128], rax

; 456  :       getNextChar();
; 457  :     else if (c == '"')

	jmp	SHORT $LN30@readToken
$LN32@readToken:
	cmp	cl, 34					; 00000022H
	je	SHORT $LN89@readToken
$LN30@readToken:

; 347  :   return true;
; 348  : }
; 349  : 
; 350  : bool Reader::readComment() {
; 351  :   Location commentBegin = current_ - 1;
; 352  :   Char c = getNextChar();
; 353  :   bool successful = false;
; 354  :   if (c == '*')
; 355  :     successful = readCStyleComment();
; 356  :   else if (c == '/')
; 357  :     successful = readCppStyleComment();
; 358  :   if (!successful)
; 359  :     return false;
; 360  : 
; 361  :   if (collectComments_) {
; 362  :     CommentPlacement placement = commentBefore;
; 363  :     if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
; 364  :       if (c != '*' || !containsNewLine(commentBegin, current_))
; 365  :         placement = commentAfterOnSameLine;
; 366  :     }
; 367  : 
; 368  :     addComment(commentBegin, current_, placement);
; 369  :   }
; 370  :   return true;
; 371  : }
; 372  : 
; 373  : static JSONCPP_STRING normalizeEOL(Reader::Location begin, Reader::Location end) {
; 374  :   JSONCPP_STRING normalized;
; 375  :   normalized.reserve(static_cast<size_t>(end - begin));
; 376  :   Reader::Location current = begin;
; 377  :   while (current != end) {
; 378  :     char c = *current++;
; 379  :     if (c == '\r') {
; 380  :       if (current != end && *current == '\n')
; 381  :          // convert dos EOL
; 382  :          ++current;
; 383  :       // convert Mac EOL
; 384  :       normalized += '\n';
; 385  :     } else {
; 386  :       normalized += c;
; 387  :     }
; 388  :   }
; 389  :   return normalized;
; 390  : }
; 391  : 
; 392  : void
; 393  : Reader::addComment(Location begin, Location end, CommentPlacement placement) {
; 394  :   assert(collectComments_);
; 395  :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
; 396  :   if (placement == commentAfterOnSameLine) {
; 397  :     assert(lastValue_ != 0);
; 398  :     lastValue_->setComment(normalized, placement);
; 399  :   } else {
; 400  :     commentsBefore_ += normalized;
; 401  :   }
; 402  : }
; 403  : 
; 404  : bool Reader::readCStyleComment() {
; 405  :   while ((current_ + 1) < end_) {
; 406  :     Char c = getNextChar();
; 407  :     if (c == '*' && *current_ == '/')
; 408  :       break;
; 409  :   }
; 410  :   return getNextChar() == '/';
; 411  : }
; 412  : 
; 413  : bool Reader::readCppStyleComment() {
; 414  :   while (current_ != end_) {
; 415  :     Char c = getNextChar();
; 416  :     if (c == '\n')
; 417  :       break;
; 418  :     if (c == '\r') {
; 419  :       // Consume DOS EOL. It will be normalized in addComment.
; 420  :       if (current_ != end_ && *current_ == '\n')
; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;
; 427  : }
; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {

	mov	rax, QWORD PTR [rbx+128]
	cmp	rax, rdx
	jne	SHORT $LN37@readToken
$LN88@readToken:

; 458  :       break;
; 459  :   }
; 460  :   return c == '"';

	cmp	cl, 34					; 00000022H
$LN89@readToken:
	sete	al

; 278  :     ok = readString();
; 279  :     break;

	jmp	SHORT $LN16@readToken
$LN10@readToken:

; 280  :   case '/':
; 281  :     token.type_ = tokenComment;
; 282  :     ok = readComment();

	mov	rcx, rbx
	mov	DWORD PTR [rdi], 12
	call	?readComment@Reader@Json@@AEAA_NXZ	; Json::Reader::readComment
$LN16@readToken:

; 319  :   default:
; 320  :     ok = false;
; 321  :     break;
; 322  :   }
; 323  :   if (!ok)

	test	al, al
	jne	SHORT $LN1@readToken
$LN83@readToken:

; 324  :     token.type_ = tokenError;

	mov	DWORD PTR [rdi], 13
$LN1@readToken:

; 325  :   token.end_ = current_;

	mov	rax, QWORD PTR [rbx+128]

; 326  :   return true;
; 327  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	mov	al, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@readToken:

; 283  :     break;
; 284  :   case '0':
; 285  :   case '1':
; 286  :   case '2':
; 287  :   case '3':
; 288  :   case '4':
; 289  :   case '5':
; 290  :   case '6':
; 291  :   case '7':
; 292  :   case '8':
; 293  :   case '9':
; 294  :   case '-':
; 295  :     token.type_ = tokenNumber;
; 296  :     readNumber();

	mov	rcx, rbx
	mov	DWORD PTR [rdi], 6
	call	?readNumber@Reader@Json@@AEAAXXZ	; Json::Reader::readNumber

; 297  :     break;

	jmp	SHORT $LN1@readToken
$LN8@readToken:

; 298  :   case 't':
; 299  :     token.type_ = tokenTrue;

	mov	DWORD PTR [rdi], 7

; 334  :     else
; 335  :       break;
; 336  :   }
; 337  : }
; 338  : 
; 339  : bool Reader::match(Location pattern, int patternLength) {
; 340  :   if (end_ - current_ < patternLength)

	mov	r8, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r8
	cmp	rax, 3
	jl	SHORT $LN83@readToken

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	lea	rcx, OFFSET FLAT:??_C@_03FFDNHNKN@rue?$AA@+3
	mov	r9, r8
	mov	edx, 3
	sub	r9, rcx
	npad	4
$LL45@readToken:
	dec	rdx

; 344  :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_03FFDNHNKN@rue?$AA@[r10]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r9+rcx+3], al
	jne	SHORT $LN83@readToken

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL45@readToken

; 345  :       return false;
; 346  :   current_ += patternLength;

	lea	rax, QWORD PTR [r8+3]
	mov	QWORD PTR [rbx+128], rax

; 300  :     ok = match("rue", 3);
; 301  :     break;

	jmp	$LN1@readToken
$LN7@readToken:

; 302  :   case 'f':
; 303  :     token.type_ = tokenFalse;

	mov	DWORD PTR [rdi], 8

; 334  :     else
; 335  :       break;
; 336  :   }
; 337  : }
; 338  : 
; 339  : bool Reader::match(Location pattern, int patternLength) {
; 340  :   if (end_ - current_ < patternLength)

	mov	r8, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r8
	cmp	rax, 4
	jl	$LN83@readToken

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	lea	rcx, OFFSET FLAT:??_C@_04KCECFHEP@alse?$AA@+4
	mov	r9, r8
	mov	edx, 4
	sub	r9, rcx
	npad	4
$LL51@readToken:
	dec	rdx

; 344  :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_04KCECFHEP@alse?$AA@[r10]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r9+rcx+4], al
	jne	$LN83@readToken

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL51@readToken

; 345  :       return false;
; 346  :   current_ += patternLength;

	lea	rax, QWORD PTR [r8+4]
	mov	QWORD PTR [rbx+128], rax

; 304  :     ok = match("alse", 4);
; 305  :     break;

	jmp	$LN1@readToken
$LN6@readToken:

; 306  :   case 'n':
; 307  :     token.type_ = tokenNull;

	mov	DWORD PTR [rdi], 9

; 334  :     else
; 335  :       break;
; 336  :   }
; 337  : }
; 338  : 
; 339  : bool Reader::match(Location pattern, int patternLength) {
; 340  :   if (end_ - current_ < patternLength)

	mov	r8, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r8
	cmp	rax, 3
	jl	$LN83@readToken

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	lea	rcx, OFFSET FLAT:??_C@_03KNPGGKC@ull?$AA@+3
	mov	r9, r8
	mov	edx, 3
	sub	r9, rcx
$LL57@readToken:
	dec	rdx

; 344  :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_03KNPGGKC@ull?$AA@[r10]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r9+rcx+3], al
	jne	$LN83@readToken

; 341  :     return false;
; 342  :   int index = patternLength;
; 343  :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL57@readToken

; 345  :       return false;
; 346  :   current_ += patternLength;

	lea	rax, QWORD PTR [r8+3]
	mov	QWORD PTR [rbx+128], rax

; 308  :     ok = match("ull", 3);
; 309  :     break;

	jmp	$LN1@readToken
$LN5@readToken:

; 310  :   case ',':
; 311  :     token.type_ = tokenArraySeparator;

	mov	DWORD PTR [rdi], 10

; 312  :     break;

	jmp	$LN1@readToken
$LN4@readToken:

; 313  :   case ':':
; 314  :     token.type_ = tokenMemberSeparator;

	mov	DWORD PTR [rdi], 11

; 315  :     break;

	jmp	$LN1@readToken
$LN3@readToken:

; 316  :   case 0:
; 317  :     token.type_ = tokenEndOfStream;

	mov	DWORD PTR [rdi], 0

; 318  :     break;

	jmp	$LN1@readToken
	npad	3
$LN86@readToken:

; 326  :   return true;
; 327  : }

	DD	$LN3@readToken
	DD	$LN11@readToken
	DD	$LN5@readToken
	DD	$LN9@readToken
	DD	$LN10@readToken
	DD	$LN4@readToken
	DD	$LN13@readToken
	DD	$LN12@readToken
	DD	$LN7@readToken
	DD	$LN6@readToken
	DD	$LN8@readToken
	DD	$LN15@readToken
	DD	$LN14@readToken
	DD	$LN83@readToken
$LN85@readToken:
	DB	0
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	1
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	2
	DB	3
	DB	13
	DB	4
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	5
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	6
	DB	13
	DB	7
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	8
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	9
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	10
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	11
	DB	13
	DB	12
?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ENDP	; Json::Reader::readToken
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?skipSpaces@Reader@Json@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?skipSpaces@Reader@Json@@AEAAXXZ PROC			; Json::Reader::skipSpaces, COMDAT

; 330  :   while (current_ != end_) {

	mov	r8, QWORD PTR [rcx+120]
	cmp	QWORD PTR [rcx+128], r8
	je	SHORT $LN3@skipSpaces
	mov	r9, 4294977024				; 0000000100002600H
	npad	9
$LL5@skipSpaces:

; 331  :     Char c = *current_;

	mov	rdx, QWORD PTR [rcx+128]
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 32					; 00000020H
	ja	SHORT $LN3@skipSpaces
	bt	r9, rax
	jae	SHORT $LN3@skipSpaces

; 332  :     if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
; 333  :       ++current_;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rcx+128], rax
	cmp	rax, r8
	jne	SHORT $LL5@skipSpaces
$LN3@skipSpaces:

; 334  :     else
; 335  :       break;
; 336  :   }
; 337  : }

	ret	0
?skipSpaces@Reader@Json@@AEAAXXZ ENDP			; Json::Reader::skipSpaces
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?match@Reader@Json@@AEAA_NPEBDH@Z
_TEXT	SEGMENT
this$ = 8
pattern$ = 16
patternLength$ = 24
?match@Reader@Json@@AEAA_NPEBDH@Z PROC			; Json::Reader::match, COMDAT

; 340  :   if (end_ - current_ < patternLength)

	mov	r9, QWORD PTR [rcx+128]
	mov	rax, QWORD PTR [rcx+120]
	movsxd	r10, r8d
	sub	rax, r9
	mov	r11, rcx
	cmp	rax, r10
	jge	SHORT $LN4@match
$LN8@match:

; 341  :     return false;

	xor	al, al

; 348  : }

	ret	0
$LN4@match:

; 342  :   int index = patternLength;
; 343  :   while (index--)

	test	r8d, r8d
	je	SHORT $LN9@match
	mov	r8, r9

; 344  :     if (current_[index] != pattern[index])

	lea	rax, QWORD PTR [r10+rdx]
	sub	r8, rdx
	neg	rdx
	npad	2
$LL3@match:
	movzx	ecx, BYTE PTR [rax-1]
	dec	rax
	cmp	BYTE PTR [r8+rax], cl
	jne	SHORT $LN8@match

; 342  :   int index = patternLength;
; 343  :   while (index--)

	lea	rcx, QWORD PTR [rdx+rax]
	test	rcx, rcx
	jne	SHORT $LL3@match
$LN9@match:

; 345  :       return false;
; 346  :   current_ += patternLength;

	lea	rax, QWORD PTR [r10+r9]
	mov	QWORD PTR [r11+128], rax

; 347  :   return true;

	mov	al, 1

; 348  : }

	ret	0
?match@Reader@Json@@AEAA_NPEBDH@Z ENDP			; Json::Reader::match
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readComment@Reader@Json@@AEAA_NXZ
_TEXT	SEGMENT
this$ = 48
?readComment@Reader@Json@@AEAA_NXZ PROC			; Json::Reader::readComment, COMDAT

; 350  : bool Reader::readComment() {

$LN81:
	sub	rsp, 40					; 00000028H

; 351  :   Location commentBegin = current_ - 1;

	mov	rax, QWORD PTR [rcx+128]

; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;
; 427  : }
; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {
; 454  :     c = getNextChar();
; 455  :     if (c == '\\')
; 456  :       getNextChar();
; 457  :     else if (c == '"')
; 458  :       break;
; 459  :   }
; 460  :   return c == '"';
; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)

	mov	rdx, QWORD PTR [rcx+120]

; 351  :   Location commentBegin = current_ - 1;

	lea	r11, QWORD PTR [rax-1]

; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;
; 427  : }
; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {
; 454  :     c = getNextChar();
; 455  :     if (c == '\\')
; 456  :       getNextChar();
; 457  :     else if (c == '"')
; 458  :       break;
; 459  :   }
; 460  :   return c == '"';
; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)

	cmp	rax, rdx
	je	SHORT $LN71@readCommen

; 788  :   return *current_++;

	movzx	r9d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 352  :   Char c = getNextChar();
; 353  :   bool successful = false;
; 354  :   if (c == '*')

	cmp	r9b, 42					; 0000002aH
	jne	SHORT $LN8@readCommen

; 372  : 
; 373  : static JSONCPP_STRING normalizeEOL(Reader::Location begin, Reader::Location end) {
; 374  :   JSONCPP_STRING normalized;
; 375  :   normalized.reserve(static_cast<size_t>(end - begin));
; 376  :   Reader::Location current = begin;
; 377  :   while (current != end) {
; 378  :     char c = *current++;
; 379  :     if (c == '\r') {
; 380  :       if (current != end && *current == '\n')
; 381  :          // convert dos EOL
; 382  :          ++current;
; 383  :       // convert Mac EOL
; 384  :       normalized += '\n';
; 385  :     } else {
; 386  :       normalized += c;
; 387  :     }
; 388  :   }
; 389  :   return normalized;
; 390  : }
; 391  : 
; 392  : void
; 393  : Reader::addComment(Location begin, Location end, CommentPlacement placement) {
; 394  :   assert(collectComments_);
; 395  :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
; 396  :   if (placement == commentAfterOnSameLine) {
; 397  :     assert(lastValue_ != 0);
; 398  :     lastValue_->setComment(normalized, placement);
; 399  :   } else {
; 400  :     commentsBefore_ += normalized;
; 401  :   }
; 402  : }
; 403  : 
; 404  : bool Reader::readCStyleComment() {
; 405  :   while ((current_ + 1) < end_) {

	inc	rax
	cmp	rax, rdx
	jae	SHORT $LN56@readCommen
$LL16@readCommen:

; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;
; 427  : }
; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {
; 454  :     c = getNextChar();
; 455  :     if (c == '\\')
; 456  :       getNextChar();
; 457  :     else if (c == '"')
; 458  :       break;
; 459  :   }
; 460  :   return c == '"';
; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)

	mov	r8, QWORD PTR [rcx+128]
	cmp	r8, rdx
	je	SHORT $LN14@readCommen

; 788  :   return *current_++;

	movzx	eax, BYTE PTR [r8]
	inc	r8
	mov	QWORD PTR [rcx+128], r8

; 406  :     Char c = getNextChar();
; 407  :     if (c == '*' && *current_ == '/')

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN14@readCommen
	cmp	BYTE PTR [r8], 47			; 0000002fH
	je	SHORT $LN56@readCommen
$LN14@readCommen:

; 372  : 
; 373  : static JSONCPP_STRING normalizeEOL(Reader::Location begin, Reader::Location end) {
; 374  :   JSONCPP_STRING normalized;
; 375  :   normalized.reserve(static_cast<size_t>(end - begin));
; 376  :   Reader::Location current = begin;
; 377  :   while (current != end) {
; 378  :     char c = *current++;
; 379  :     if (c == '\r') {
; 380  :       if (current != end && *current == '\n')
; 381  :          // convert dos EOL
; 382  :          ++current;
; 383  :       // convert Mac EOL
; 384  :       normalized += '\n';
; 385  :     } else {
; 386  :       normalized += c;
; 387  :     }
; 388  :   }
; 389  :   return normalized;
; 390  : }
; 391  : 
; 392  : void
; 393  : Reader::addComment(Location begin, Location end, CommentPlacement placement) {
; 394  :   assert(collectComments_);
; 395  :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
; 396  :   if (placement == commentAfterOnSameLine) {
; 397  :     assert(lastValue_ != 0);
; 398  :     lastValue_->setComment(normalized, placement);
; 399  :   } else {
; 400  :     commentsBefore_ += normalized;
; 401  :   }
; 402  : }
; 403  : 
; 404  : bool Reader::readCStyleComment() {
; 405  :   while ((current_ + 1) < end_) {

	mov	rax, QWORD PTR [rcx+128]
	inc	rax
	cmp	rax, rdx
	jb	SHORT $LL16@readCommen
$LN56@readCommen:

; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;
; 427  : }
; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {
; 454  :     c = getNextChar();
; 455  :     if (c == '\\')
; 456  :       getNextChar();
; 457  :     else if (c == '"')
; 458  :       break;
; 459  :   }
; 460  :   return c == '"';
; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)

	mov	rax, QWORD PTR [rcx+128]
	cmp	rax, rdx
	jne	SHORT $LN22@readCommen

; 787  :     return 0;

	xor	dl, dl
	jmp	SHORT $LN23@readCommen
$LN22@readCommen:

; 788  :   return *current_++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+128], rax
$LN23@readCommen:

; 408  :       break;
; 409  :   }
; 410  :   return getNextChar() == '/';

	cmp	dl, 47					; 0000002fH
	sete	al

; 357  :     successful = readCppStyleComment();
; 358  :   if (!successful)

	test	al, al
	jne	SHORT $LN5@readCommen
$LN71@readCommen:

; 359  :     return false;

	xor	al, al

; 371  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@readCommen:

; 355  :     successful = readCStyleComment();
; 356  :   else if (c == '/')

	cmp	r9b, 47					; 0000002fH
	jne	SHORT $LN71@readCommen

; 411  : }
; 412  : 
; 413  : bool Reader::readCppStyleComment() {
; 414  :   while (current_ != end_) {

	cmp	rax, rdx
	je	SHORT $LN5@readCommen
$LN79@readCommen:

; 788  :   return *current_++;

	movzx	r8d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 415  :     Char c = getNextChar();
; 416  :     if (c == '\n')

	cmp	r8b, 10
	je	SHORT $LN5@readCommen

; 417  :       break;
; 418  :     if (c == '\r') {

	cmp	r8b, 13
	je	SHORT $LN58@readCommen

; 411  : }
; 412  : 
; 413  : bool Reader::readCppStyleComment() {
; 414  :   while (current_ != end_) {

	cmp	rax, rdx
	jne	SHORT $LN79@readCommen

; 86   :     if (*begin == '\n' || *begin == '\r')

	jmp	SHORT $LN5@readCommen
$LN58@readCommen:

; 419  :       // Consume DOS EOL. It will be normalized in addComment.
; 420  :       if (current_ != end_ && *current_ == '\n')

	cmp	rax, rdx
	je	SHORT $LN5@readCommen
	cmp	BYTE PTR [rax], 10
	jne	SHORT $LN5@readCommen

; 788  :   return *current_++;

	inc	rax
	mov	QWORD PTR [rcx+128], rax
$LN5@readCommen:

; 360  : 
; 361  :   if (collectComments_) {

	cmp	BYTE PTR [rcx+188], 0
	je	SHORT $LN4@readCommen

; 362  :     CommentPlacement placement = commentBefore;
; 363  :     if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {

	mov	rax, QWORD PTR [rcx+136]
	xor	r10d, r10d
	test	rax, rax
	je	SHORT $LN2@readCommen

; 85   :   for (; begin < end; ++begin)

	cmp	rax, r11
	jae	SHORT $LN40@readCommen
$LL42@readCommen:

; 86   :     if (*begin == '\n' || *begin == '\r')

	movzx	edx, BYTE PTR [rax]
	cmp	dl, 10
	je	SHORT $LN2@readCommen
	cmp	dl, 13
	je	SHORT $LN2@readCommen

; 85   :   for (; begin < end; ++begin)

	inc	rax
	cmp	rax, r11
	jb	SHORT $LL42@readCommen
$LN40@readCommen:

; 364  :       if (c != '*' || !containsNewLine(commentBegin, current_))

	cmp	r9b, 42					; 0000002aH
	jne	SHORT $LN47@readCommen

; 85   :   for (; begin < end; ++begin)

	mov	r9, QWORD PTR [rcx+128]

; 364  :       if (c != '*' || !containsNewLine(commentBegin, current_))

	mov	rax, r11

; 85   :   for (; begin < end; ++begin)

	cmp	r11, r9
	jae	SHORT $LN47@readCommen
	npad	4
$LL49@readCommen:

; 86   :     if (*begin == '\n' || *begin == '\r')

	movzx	r8d, BYTE PTR [rax]
	cmp	r8b, 10
	je	SHORT $LN2@readCommen
	cmp	r8b, 13
	je	SHORT $LN2@readCommen

; 85   :   for (; begin < end; ++begin)

	inc	rax
	cmp	rax, r9
	jb	SHORT $LL49@readCommen
$LN47@readCommen:

; 365  :         placement = commentAfterOnSameLine;

	mov	r10d, 1
$LN2@readCommen:

; 366  :     }
; 367  : 
; 368  :     addComment(commentBegin, current_, placement);

	mov	r8, QWORD PTR [rcx+128]
	mov	r9d, r10d
	mov	rdx, r11
	call	?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
$LN4@readCommen:

; 369  :   }
; 370  :   return true;

	mov	al, 1

; 371  : }

	add	rsp, 40					; 00000028H
	ret	0
?readComment@Reader@Json@@AEAA_NXZ ENDP			; Json::Reader::readComment
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
__$ReturnUdt$ = 64
begin$ = 72
end$ = 80
?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z PROC ; Json::normalizeEOL, COMDAT

; 373  : static JSONCPP_STRING normalizeEOL(Reader::Location begin, Reader::Location end) {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+88], rsi
	mov	rsi, r8
	mov	rbx, rdx
	mov	rdi, rcx
	xor	eax, eax
	mov	DWORD PTR $T1[rsp], eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], al
	mov	DWORD PTR $T1[rsp], 1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 375  :   normalized.reserve(static_cast<size_t>(end - begin));

	mov	rdx, r8
	sub	rdx, rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)

	mov	ebp, eax
	cmp	rax, rdx
	ja	SHORT $LN60@normalizeE
	cmp	QWORD PTR [rcx+24], rdx
	je	SHORT $LN60@normalizeE

; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))

	mov	r8b, 1
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN60@normalizeE

; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], rbp

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN56@normalizeE
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rdi]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN57@normalizeE
$LN56@normalizeE:
	mov	rax, rdi
$LN57@normalizeE:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax+rbp], bpl
$LN60@normalizeE:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 377  :   while (current != end) {

	cmp	rbx, rsi
	je	SHORT $LN69@normalizeE
$LL5@normalizeE:

; 378  :     char c = *current++;

	movzx	r8d, BYTE PTR [rbx]
	inc	rbx

; 379  :     if (c == '\r') {

	cmp	r8b, 13
	jne	SHORT $LN3@normalizeE

; 380  :       if (current != end && *current == '\n')

	cmp	rbx, rsi
	je	SHORT $LN2@normalizeE
	cmp	BYTE PTR [rbx], 10
	jne	SHORT $LN2@normalizeE

; 381  :          // convert dos EOL
; 382  :          ++current;

	inc	rbx
$LN2@normalizeE:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 10
$LN3@normalizeE:
	mov	edx, 1
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 377  :   while (current != end) {

	cmp	rbx, rsi
	jne	SHORT $LL5@normalizeE
$LN69@normalizeE:

; 383  :       // convert Mac EOL
; 384  :       normalized += '\n';
; 385  :     } else {
; 386  :       normalized += c;
; 387  :     }
; 388  :   }
; 389  :   return normalized;

	mov	rax, rdi

; 390  : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
	int	3
?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z ENDP ; Json::normalizeEOL
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
__$ReturnUdt$ = 64
begin$ = 72
end$ = 80
?dtor$0@?0??normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z@4HA PROC ; `Json::normalizeEOL'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN9@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z@4HA ENDP ; `Json::normalizeEOL'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
_TEXT	SEGMENT
$T1 = 32
$S1$ = 40
__$ArrayPad$ = 72
this$ = 112
begin$ = 120
end$ = 128
placement$ = 136
?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z PROC ; Json::Reader::addComment, COMDAT

; 393  : Reader::addComment(Location begin, Location end, CommentPlacement placement) {

$LN54:
	push	rbx
	push	rdi
	sub	rsp, 88					; 00000058H
	mov	QWORD PTR $T1[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	ebx, r9d
	mov	rdi, rcx

; 394  :   assert(collectComments_);
; 395  :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);

	lea	rcx, QWORD PTR $S1$[rsp]
	call	?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z ; Json::normalizeEOL
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rdx, QWORD PTR $S1$[rsp]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 396  :   if (placement == commentAfterOnSameLine) {

	cmp	ebx, 1
	jne	SHORT $LN2@addComment
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR $S1$[rsp+24], 16
	cmovae	rdx, QWORD PTR $S1$[rsp]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1407 :   setComment(comment.c_str(), comment.length(), placement);

	mov	r9d, ebx
	mov	r8, QWORD PTR $S1$[rsp+16]
	mov	rcx, QWORD PTR [rdi+144]
	call	?setComment@Value@Json@@QEAAXPEBD_KW4CommentPlacement@2@@Z ; Json::Value::setComment
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 399  :   } else {

	jmp	SHORT $LN18@addComment
$LN2@addComment:

; 400  :     commentsBefore_ += normalized;

	lea	rcx, QWORD PTR [rdi+152]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN18@addComment:

; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $S1$[rsp+24], 16
	jb	SHORT $LN42@addComment
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $S1$[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN42@addComment:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 402  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rbx
	ret	0
?addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z ENDP ; Json::Reader::addComment
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$S1$ = 40
__$ArrayPad$ = 72
this$ = 112
begin$ = 120
end$ = 128
placement$ = 136
?dtor$0@?0??addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z@4HA PROC ; `Json::Reader::addComment'::`1'::dtor$0
	lea	rcx, QWORD PTR $S1$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??addComment@Reader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z@4HA ENDP ; `Json::Reader::addComment'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readCStyleComment@Reader@Json@@AEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?readCStyleComment@Reader@Json@@AEAA_NXZ PROC		; Json::Reader::readCStyleComment, COMDAT

; 405  :   while ((current_ + 1) < end_) {

	mov	rax, QWORD PTR [rcx+128]
	mov	r8, QWORD PTR [rcx+120]
	lea	rdx, QWORD PTR [rax+1]
	cmp	rdx, r8
	jae	SHORT $LN13@readCStyle
$LL3@readCStyle:

; 412  : 
; 413  : bool Reader::readCppStyleComment() {
; 414  :   while (current_ != end_) {
; 415  :     Char c = getNextChar();
; 416  :     if (c == '\n')
; 417  :       break;
; 418  :     if (c == '\r') {
; 419  :       // Consume DOS EOL. It will be normalized in addComment.
; 420  :       if (current_ != end_ && *current_ == '\n')
; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;
; 427  : }
; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {
; 454  :     c = getNextChar();
; 455  :     if (c == '\\')
; 456  :       getNextChar();
; 457  :     else if (c == '"')
; 458  :       break;
; 459  :   }
; 460  :   return c == '"';
; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)

	cmp	rax, r8
	je	SHORT $LN1@readCStyle

; 788  :   return *current_++;

	movzx	eax, BYTE PTR [rax]
	mov	QWORD PTR [rcx+128], rdx

; 406  :     Char c = getNextChar();
; 407  :     if (c == '*' && *current_ == '/')

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN1@readCStyle
	cmp	BYTE PTR [rdx], 47			; 0000002fH
	je	SHORT $LN13@readCStyle
$LN1@readCStyle:

; 405  :   while ((current_ + 1) < end_) {

	mov	rax, QWORD PTR [rcx+128]
	lea	rdx, QWORD PTR [rax+1]
	cmp	rdx, r8
	jb	SHORT $LL3@readCStyle
$LN13@readCStyle:

; 412  : 
; 413  : bool Reader::readCppStyleComment() {
; 414  :   while (current_ != end_) {
; 415  :     Char c = getNextChar();
; 416  :     if (c == '\n')
; 417  :       break;
; 418  :     if (c == '\r') {
; 419  :       // Consume DOS EOL. It will be normalized in addComment.
; 420  :       if (current_ != end_ && *current_ == '\n')
; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;
; 427  : }
; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {
; 454  :     c = getNextChar();
; 455  :     if (c == '\\')
; 456  :       getNextChar();
; 457  :     else if (c == '"')
; 458  :       break;
; 459  :   }
; 460  :   return c == '"';
; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)

	mov	rax, QWORD PTR [rcx+128]
	cmp	rax, r8
	jne	SHORT $LN9@readCStyle

; 787  :     return 0;

	xor	dl, dl

; 408  :       break;
; 409  :   }
; 410  :   return getNextChar() == '/';

	cmp	dl, 47					; 0000002fH
	sete	al

; 411  : }

	ret	0
$LN9@readCStyle:

; 788  :   return *current_++;

	movzx	edx, BYTE PTR [rax]
	inc	rax

; 408  :       break;
; 409  :   }
; 410  :   return getNextChar() == '/';

	cmp	dl, 47					; 0000002fH

; 788  :   return *current_++;

	mov	QWORD PTR [rcx+128], rax

; 408  :       break;
; 409  :   }
; 410  :   return getNextChar() == '/';

	sete	al

; 411  : }

	ret	0
?readCStyleComment@Reader@Json@@AEAA_NXZ ENDP		; Json::Reader::readCStyleComment
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readCppStyleComment@Reader@Json@@AEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?readCppStyleComment@Reader@Json@@AEAA_NXZ PROC		; Json::Reader::readCppStyleComment, COMDAT

; 414  :   while (current_ != end_) {

	mov	rax, QWORD PTR [rcx+128]
	mov	rdx, QWORD PTR [rcx+120]
	cmp	rax, rdx
	je	SHORT $LN25@readCppSty
$LN29@readCppSty:

; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {
; 454  :     c = getNextChar();
; 455  :     if (c == '\\')
; 456  :       getNextChar();
; 457  :     else if (c == '"')
; 458  :       break;
; 459  :   }
; 460  :   return c == '"';
; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)
; 787  :     return 0;
; 788  :   return *current_++;

	movzx	r8d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 415  :     Char c = getNextChar();
; 416  :     if (c == '\n')

	cmp	r8b, 10
	je	SHORT $LN25@readCppSty

; 417  :       break;
; 418  :     if (c == '\r') {

	cmp	r8b, 13
	je	SHORT $LN16@readCppSty

; 414  :   while (current_ != end_) {

	cmp	rax, rdx
	jne	SHORT $LN29@readCppSty

; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;

	mov	al, 1

; 427  : }

	ret	0
$LN16@readCppSty:

; 419  :       // Consume DOS EOL. It will be normalized in addComment.
; 420  :       if (current_ != end_ && *current_ == '\n')

	cmp	rax, rdx
	je	SHORT $LN25@readCppSty
	cmp	BYTE PTR [rax], 10
	jne	SHORT $LN25@readCppSty

; 428  : 
; 429  : void Reader::readNumber() {
; 430  :   const char *p = current_;
; 431  :   char c = '0'; // stopgap for already consumed character
; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')
; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 435  :   // fractional part
; 436  :   if (c == '.') {
; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 438  :     while (c >= '0' && c <= '9')
; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';
; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 446  :     while (c >= '0' && c <= '9')
; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';
; 448  :   }
; 449  : }
; 450  : 
; 451  : bool Reader::readString() {
; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {
; 454  :     c = getNextChar();
; 455  :     if (c == '\\')
; 456  :       getNextChar();
; 457  :     else if (c == '"')
; 458  :       break;
; 459  :   }
; 460  :   return c == '"';
; 461  : }
; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)
; 787  :     return 0;
; 788  :   return *current_++;

	inc	rax
	mov	QWORD PTR [rcx+128], rax
$LN25@readCppSty:

; 421  :         getNextChar();
; 422  :       // Break on Moc OS 9 EOL.
; 423  :       break;
; 424  :     }
; 425  :   }
; 426  :   return true;

	mov	al, 1

; 427  : }

	ret	0
?readCppStyleComment@Reader@Json@@AEAA_NXZ ENDP		; Json::Reader::readCppStyleComment
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readNumber@Reader@Json@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?readNumber@Reader@Json@@AEAAXXZ PROC			; Json::Reader::readNumber, COMDAT

; 430  :   const char *p = current_;

	mov	rax, QWORD PTR [rcx+128]
	mov	r8, rcx

; 431  :   char c = '0'; // stopgap for already consumed character

	mov	dl, 48					; 00000030H
	npad	4
$LL11@readNumber:

; 432  :   // integral part
; 433  :   while (c >= '0' && c <= '9')

	cmp	dl, 57					; 00000039H
	jg	SHORT $LN10@readNumber

; 434  :     c = (current_ = p) < end_ ? *p++ : '\0';

	mov	QWORD PTR [rcx+128], rax
	cmp	rax, QWORD PTR [rcx+120]
	jae	$LN24@readNumber
	movzx	edx, BYTE PTR [rax]
	inc	rax
	cmp	dl, 48					; 00000030H
	jge	SHORT $LL11@readNumber
$LN10@readNumber:

; 435  :   // fractional part
; 436  :   if (c == '.') {

	cmp	dl, 46					; 0000002eH
	jne	SHORT $LN7@readNumber

; 437  :     c = (current_ = p) < end_ ? *p++ : '\0';

	mov	QWORD PTR [rcx+128], rax
	mov	rcx, QWORD PTR [rcx+120]
	cmp	rax, rcx
	jae	$LN24@readNumber
	movzx	edx, BYTE PTR [rax]
	inc	rax

; 438  :     while (c >= '0' && c <= '9')

	cmp	dl, 48					; 00000030H
	jl	SHORT $LN7@readNumber
$LL8@readNumber:
	cmp	dl, 57					; 00000039H
	jg	SHORT $LN7@readNumber

; 439  :       c = (current_ = p) < end_ ? *p++ : '\0';

	mov	QWORD PTR [r8+128], rax
	cmp	rax, rcx
	jae	SHORT $LN24@readNumber
	movzx	edx, BYTE PTR [rax]
	inc	rax
	cmp	dl, 48					; 00000030H
	jge	SHORT $LL8@readNumber
$LN7@readNumber:
	sub	dl, 69					; 00000045H
	test	dl, 223					; 000000dfH
	jne	SHORT $LN24@readNumber

; 440  :   }
; 441  :   // exponential part
; 442  :   if (c == 'e' || c == 'E') {
; 443  :     c = (current_ = p) < end_ ? *p++ : '\0';

	mov	r9, QWORD PTR [r8+120]
	mov	QWORD PTR [r8+128], rax
	cmp	rax, r9
	jae	SHORT $LN24@readNumber
	movzx	edx, BYTE PTR [rax]
	inc	rax
	lea	ecx, DWORD PTR [rdx-43]
	test	cl, 253					; 000000fdH
	jne	SHORT $LN23@readNumber

; 444  :     if (c == '+' || c == '-')
; 445  :       c = (current_ = p) < end_ ? *p++ : '\0';

	mov	QWORD PTR [r8+128], rax
	cmp	rax, r9
	jae	SHORT $LN24@readNumber
	movzx	edx, BYTE PTR [rax]
	inc	rax
$LN23@readNumber:

; 446  :     while (c >= '0' && c <= '9')

	cmp	dl, 48					; 00000030H
	jl	SHORT $LN24@readNumber
	npad	2
$LL2@readNumber:
	cmp	dl, 57					; 00000039H
	jg	SHORT $LN24@readNumber

; 447  :       c = (current_ = p) < end_ ? *p++ : '\0';

	mov	QWORD PTR [r8+128], rax
	cmp	rax, r9
	jae	SHORT $LN24@readNumber
	movzx	edx, BYTE PTR [rax]
	inc	rax
	cmp	dl, 48					; 00000030H
	jge	SHORT $LL2@readNumber
$LN24@readNumber:

; 448  :   }
; 449  : }

	ret	0
?readNumber@Reader@Json@@AEAAXXZ ENDP			; Json::Reader::readNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readString@Reader@Json@@AEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?readString@Reader@Json@@AEAA_NXZ PROC			; Json::Reader::readString, COMDAT

; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {

	mov	rax, QWORD PTR [rcx+128]
	mov	r8, QWORD PTR [rcx+120]
	xor	dl, dl
	cmp	rax, r8
	je	SHORT $LN15@readString
$LN8@readString:

; 787  :     return 0;
; 788  :   return *current_++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 454  :     c = getNextChar();
; 455  :     if (c == '\\')

	cmp	dl, 92					; 0000005cH
	jne	SHORT $LN3@readString

; 462  : 
; 463  : bool Reader::readObject(Token& tokenStart) {
; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 469  :   while (readToken(tokenName)) {
; 470  :     bool initialTokenOk = true;
; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 472  :       initialTokenOk = readToken(tokenName);
; 473  :     if (!initialTokenOk)
; 474  :       break;
; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 476  :       return true;
; 477  :     name.clear();
; 478  :     if (tokenName.type_ == tokenString) {
; 479  :       if (!decodeString(tokenName, name))
; 480  :         return recoverFromError(tokenObjectEnd);
; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 482  :       Value numberName;
; 483  :       if (!decodeNumber(tokenName, numberName))
; 484  :         return recoverFromError(tokenObjectEnd);
; 485  :       name = JSONCPP_STRING(numberName.asCString());
; 486  :     } else {
; 487  :       break;
; 488  :     }
; 489  : 
; 490  :     Token colon;
; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 494  :     }
; 495  :     Value& value = currentValue()[name];
; 496  :     nodes_.push(&value);
; 497  :     bool ok = readValue();
; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set
; 500  :       return recoverFromError(tokenObjectEnd);
; 501  : 
; 502  :     Token comma;
; 503  :     if (!readToken(comma) ||
; 504  :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 505  :          comma.type_ != tokenComment)) {
; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 508  :     }
; 509  :     bool finalizeTokenOk = true;
; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 511  :       finalizeTokenOk = readToken(comma);
; 512  :     if (comma.type_ == tokenObjectEnd)
; 513  :       return true;
; 514  :   }
; 515  :   return addErrorAndRecover(
; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 517  : }
; 518  : 
; 519  : bool Reader::readArray(Token& tokenStart) {
; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array
; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);
; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;
; 531  :   for (;;) {
; 532  :     Value& value = currentValue()[index++];
; 533  :     nodes_.push(&value);
; 534  :     bool ok = readValue();
; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set
; 537  :       return recoverFromError(tokenArrayEnd);
; 538  : 
; 539  :     Token token;
; 540  :     // Accept Comment after last item in the array.
; 541  :     ok = readToken(token);
; 542  :     while (token.type_ == tokenComment && ok) {
; 543  :       ok = readToken(token);
; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 547  :     if (!ok || badTokenType) {
; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)
; 552  :       break;
; 553  :   }
; 554  :   return true;
; 555  : }
; 556  : 
; 557  : bool Reader::decodeNumber(Token& token) {
; 558  :   Value decoded;
; 559  :   if (!decodeNumber(token, decoded))
; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);
; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 564  :   return true;
; 565  : }
; 566  : 
; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {
; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;
; 572  :   bool isNegative = *current == '-';
; 573  :   if (isNegative)
; 574  :     ++current;
; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;
; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;
; 581  :   while (current < token.end_) {
; 582  :     Char c = *current++;
; 583  :     if (c < '0' || c > '9')
; 584  :       return decodeDouble(token, decoded);
; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 586  :     if (value >= threshold) {
; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {
; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;
; 597  :   }
; 598  :   if (isNegative && value == maxIntegerValue)
; 599  :     decoded = Value::minLargestInt;
; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);
; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))
; 603  :     decoded = Value::LargestInt(value);
; 604  :   else
; 605  :     decoded = value;
; 606  :   return true;
; 607  : }
; 608  : 
; 609  : bool Reader::decodeDouble(Token& token) {
; 610  :   Value decoded;
; 611  :   if (!decodeDouble(token, decoded))
; 612  :     return false;
; 613  :   currentValue().swapPayload(decoded);
; 614  :   currentValue().setOffsetStart(token.start_ - begin_);
; 615  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 616  :   return true;
; 617  : }
; 618  : 
; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {
; 620  :   double value = 0;
; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);
; 622  :   JSONCPP_ISTRINGSTREAM is(buffer);
; 623  :   if (!(is >> value))
; 624  :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 625  :                         "' is not a number.",
; 626  :                     token);
; 627  :   decoded = value;
; 628  :   return true;
; 629  : }
; 630  : 
; 631  : bool Reader::decodeString(Token& token) {
; 632  :   JSONCPP_STRING decoded_string;
; 633  :   if (!decodeString(token, decoded_string))
; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);
; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);
; 639  :   return true;
; 640  : }
; 641  : 
; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 644  :   Location current = token.start_ + 1; // skip '"'
; 645  :   Location end = token.end_ - 1;       // do not include '"'
; 646  :   while (current != end) {
; 647  :     Char c = *current++;
; 648  :     if (c == '"')
; 649  :       break;
; 650  :     else if (c == '\\') {
; 651  :       if (current == end)
; 652  :         return addError("Empty escape sequence in string", token, current);
; 653  :       Char escape = *current++;
; 654  :       switch (escape) {
; 655  :       case '"':
; 656  :         decoded += '"';
; 657  :         break;
; 658  :       case '/':
; 659  :         decoded += '/';
; 660  :         break;
; 661  :       case '\\':
; 662  :         decoded += '\\';
; 663  :         break;
; 664  :       case 'b':
; 665  :         decoded += '\b';
; 666  :         break;
; 667  :       case 'f':
; 668  :         decoded += '\f';
; 669  :         break;
; 670  :       case 'n':
; 671  :         decoded += '\n';
; 672  :         break;
; 673  :       case 'r':
; 674  :         decoded += '\r';
; 675  :         break;
; 676  :       case 't':
; 677  :         decoded += '\t';
; 678  :         break;
; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 682  :           return false;
; 683  :         decoded += codePointToUTF8(unicode);
; 684  :       } break;
; 685  :       default:
; 686  :         return addError("Bad escape sequence in string", token, current);
; 687  :       }
; 688  :     } else {
; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;
; 693  : }
; 694  : 
; 695  : bool Reader::decodeUnicodeCodePoint(Token& token,
; 696  :                                     Location& current,
; 697  :                                     Location end,
; 698  :                                     unsigned int& unicode) {
; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 701  :     return false;
; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)
; 705  :       return addError(
; 706  :           "additional six characters expected to parse unicode surrogate pair.",
; 707  :           token,
; 708  :           current);
; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {
; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 713  :       } else
; 714  :         return false;
; 715  :     } else
; 716  :       return addError("expecting another \\u token to begin the second half of "
; 717  :                       "a unicode surrogate pair",
; 718  :                       token,
; 719  :                       current);
; 720  :   }
; 721  :   return true;
; 722  : }
; 723  : 
; 724  : bool Reader::decodeUnicodeEscapeSequence(Token& token,
; 725  :                                          Location& current,
; 726  :                                          Location end,
; 727  :                                          unsigned int& ret_unicode) {
; 728  :   if (end - current < 4)
; 729  :     return addError(
; 730  :         "Bad unicode escape sequence in string: four digits expected.",
; 731  :         token,
; 732  :         current);
; 733  :   int unicode = 0;
; 734  :   for (int index = 0; index < 4; ++index) {
; 735  :     Char c = *current++;
; 736  :     unicode *= 16;
; 737  :     if (c >= '0' && c <= '9')
; 738  :       unicode += c - '0';
; 739  :     else if (c >= 'a' && c <= 'f')
; 740  :       unicode += c - 'a' + 10;
; 741  :     else if (c >= 'A' && c <= 'F')
; 742  :       unicode += c - 'A' + 10;
; 743  :     else
; 744  :       return addError(
; 745  :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 746  :           token,
; 747  :           current);
; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);
; 750  :   return true;
; 751  : }
; 752  : 
; 753  : bool
; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 755  :   ErrorInfo info;
; 756  :   info.token_ = token;
; 757  :   info.message_ = message;
; 758  :   info.extra_ = extra;
; 759  :   errors_.push_back(info);
; 760  :   return false;
; 761  : }
; 762  : 
; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {
; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))
; 768  :       errors_.resize(errorCount); // discard errors caused by recovery
; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);
; 773  :   return false;
; 774  : }
; 775  : 
; 776  : bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
; 777  :                                 Token& token,
; 778  :                                 TokenType skipUntilToken) {
; 779  :   addError(message, token);
; 780  :   return recoverFromError(skipUntilToken);
; 781  : }
; 782  : 
; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }
; 784  : 
; 785  : Reader::Char Reader::getNextChar() {
; 786  :   if (current_ == end_)

	cmp	rax, r8
	je	SHORT $LN1@readString

; 787  :     return 0;
; 788  :   return *current_++;

	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 789  : }

	jmp	SHORT $LN1@readString
$LN3@readString:

; 456  :       getNextChar();
; 457  :     else if (c == '"')

	cmp	dl, 34					; 00000022H
	je	SHORT $LN19@readString
$LN1@readString:

; 452  :   Char c = '\0';
; 453  :   while (current_ != end_) {

	mov	rax, QWORD PTR [rcx+128]
	cmp	rax, r8
	jne	SHORT $LN8@readString
$LN15@readString:

; 458  :       break;
; 459  :   }
; 460  :   return c == '"';

	cmp	dl, 34					; 00000022H
$LN19@readString:
	sete	al

; 461  : }

	ret	0
?readString@Reader@Json@@AEAA_NXZ ENDP			; Json::Reader::readString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z
_TEXT	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z PROC	; Json::Reader::readObject, COMDAT

; 463  : bool Reader::readObject(Token& tokenStart) {

$LN1516:
	mov	rax, rsp
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-360]
	sub	rsp, 592				; 00000250H
	mov	QWORD PTR $T11[rbp-256], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r14, rdx
	mov	rdi, rcx
	xor	r15d, r15d
	mov	DWORD PTR $T6[rsp], r15d
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR name$[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR name$[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR name$[rbp-256], r15b
	mov	esi, DWORD PTR init$[rbp-248]
	and	esi, -505				; fffffe07H
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	or	esi, 7
	mov	DWORD PTR init$[rbp-248], esi
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR init$[rbp-240], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR init$[rbp-224], r15

; 364  :     value_.map_ = new ObjectValues();

	lea	ecx, QWORD PTR [r15+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	rbx, rax
	mov	QWORD PTR $T7[rsp], rax
	test	rax, rax
	je	SHORT $LN86@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

	mov	QWORD PTR [rax], r15

; 570  : 		this->_Mysize = 0;

	mov	QWORD PTR [rax+8], r15

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Buyheadnode
	mov	QWORD PTR [rbx], rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 364  :     value_.map_ = new ObjectValues();

	jmp	SHORT $LN87@readObject
$LN86@readObject:
	mov	rbx, r15
$LN87@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T9[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	mov	r8, r15
	je	SHORT $LN122@readObject
	mov	r8, QWORD PTR [rcx]
$LN122@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	r8, QWORD PTR [rcx+rdx*8]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	ecx, BYTE PTR [r8+8]

; 518  :   type_ = other.type_;

	movzx	eax, BYTE PTR init$[rbp-248]
	mov	BYTE PTR [r8+8], al

; 519  :   other.type_ = temp;

	mov	eax, esi
	xor	eax, ecx
	movzx	eax, al
	xor	esi, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rax, QWORD PTR [r8]

; 53   : 	_Left = _Move(_Right);

	mov	QWORD PTR [r8], rbx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR init$[rsp], rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [r8+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, esi
	xor	eax, ecx
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, esi
	and	edx, 256				; 00000100H
	xor	esi, edx
	mov	DWORD PTR init$[rbp-248], esi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T8[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN147@readObject
	mov	r8, r15
	jmp	SHORT $LN148@readObject
$LN147@readObject:
	mov	r8, QWORD PTR [r8]
$LN148@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 464  :   Token tokenName;
; 465  :   JSONCPP_STRING name;
; 466  :   Value init(objectValue);
; 467  :   currentValue().swapPayload(init);
; 468  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [rdi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rdx+24], rax
$LN1514@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 469  :   while (readToken(tokenName)) {

	lea	rdx, QWORD PTR tokenName$[rsp]
	mov	rcx, rdi
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	$LN11@readObject

; 470  :     bool initialTokenOk = true;

	mov	al, 1

; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)

	mov	ecx, DWORD PTR tokenName$[rsp]
	cmp	ecx, 12
	jne	SHORT $LN1507@readObject
$LL18@readObject:
	test	al, al
	je	$LN11@readObject

; 472  :       initialTokenOk = readToken(tokenName);

	lea	rdx, QWORD PTR tokenName$[rsp]
	mov	rcx, rdi
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken

; 471  :     while (tokenName.type_ == tokenComment && initialTokenOk)

	mov	ecx, DWORD PTR tokenName$[rsp]
	cmp	ecx, 12
	je	SHORT $LL18@readObject

; 473  :     if (!initialTokenOk)

	test	al, al
	je	$LN11@readObject
$LN1507@readObject:

; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object

	cmp	ecx, 2
	jne	SHORT $LN15@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR name$[rbp-240], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 475  :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object

	je	$LN1484@readObject
$LN15@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR name$[rbp-240], r15

; 513  : 			: this->_Bx._Buf);

	lea	rax, QWORD PTR name$[rbp-256]
	cmp	QWORD PTR name$[rbp-232], 16
	cmovae	rax, QWORD PTR name$[rbp-256]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 478  :     if (tokenName.type_ == tokenString) {

	cmp	ecx, 5
	jne	SHORT $LN14@readObject

; 479  :       if (!decodeString(tokenName, name))

	lea	r8, QWORD PTR name$[rbp-256]
	lea	rdx, QWORD PTR tokenName$[rsp]
	mov	rcx, rdi
	call	?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
	test	al, al
	je	$LN1485@readObject

; 481  :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {

	jmp	$LN713@readObject
$LN14@readObject:
	cmp	ecx, 6
	jne	$LN11@readObject
	cmp	BYTE PTR [rdi+187], 0
	je	$LN11@readObject
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	and	DWORD PTR numberName$15[rbp-248], -512	; fffffe00H
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR numberName$15[rbp-240], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR numberName$15[rbp-224], r15
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 483  :       if (!decodeNumber(tokenName, numberName))

	lea	r8, QWORD PTR numberName$15[rbp-256]
	lea	rdx, QWORD PTR tokenName$[rsp]
	mov	rcx, rdi
	call	?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ; Json::Reader::decodeNumber
	test	al, al
	je	$LN1486@readObject
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 645  :                       "in Json::Value::asCString(): requires stringValue");

	cmp	BYTE PTR numberName$15[rbp-248], 4
	jne	$LN1487@readObject

; 646  :   if (value_.string_ == 0) return 0;

	mov	esi, DWORD PTR numberName$15[rbp-248]
	mov	rbx, QWORD PTR numberName$15[rbp-256]
	test	rbx, rbx
	jne	SHORT $LN297@readObject
	mov	rdx, r15
	jmp	SHORT $LN299@readObject
$LN297@readObject:

; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);

	mov	eax, esi
	shr	eax, 8
	and	al, 1

; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;

	mov	rdx, rbx

; 143  :   if (!isPrefixed) {

	je	SHORT $LN299@readObject

; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);

	lea	rdx, QWORD PTR [rbx+4]
$LN299@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T19[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T19[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T19[rbp-256], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [rdx], 0
	jne	SHORT $LN429@readObject
	mov	r8, r15
	jmp	SHORT $LN430@readObject
$LN429@readObject:
	or	r8, -1
$LL1510@readObject:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL1510@readObject
$LN430@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	rcx, QWORD PTR $T19[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR name$[rbp-232], 16
	jb	SHORT $LN455@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR name$[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN455@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR name$[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR name$[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR name$[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	mov	rcx, QWORD PTR $T19[rbp-232]
	cmp	rcx, 16
	jae	SHORT $LN546@readObject

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	r8, QWORD PTR $T19[rbp-240]
	inc	r8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN545@readObject
	lea	rdx, QWORD PTR $T19[rbp-256]
	lea	rcx, QWORD PTR name$[rbp-256]
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

	mov	rcx, QWORD PTR $T19[rbp-232]
	jmp	SHORT $LN545@readObject
$LN546@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR $T19[rbp-256]
	mov	QWORD PTR name$[rbp-256], rax
$LN545@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 944  : 		this->_Mysize = _Right._Mysize;

	mov	rax, QWORD PTR $T19[rbp-240]
	mov	QWORD PTR name$[rbp-240], rax

; 945  : 		this->_Myres = _Right._Myres;

	mov	QWORD PTR name$[rbp-232], rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 495  :     if (allocated_)

	bt	esi, 8
	jae	SHORT $LN646@readObject

; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN646@readObject:

; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;

	mov	rcx, QWORD PTR numberName$15[rbp-240]
	test	rcx, rcx
	je	SHORT $LN713@readObject
	lea	rbx, QWORD PTR [rcx-8]
	lea	r9, OFFSET FLAT:??1CommentInfo@Value@Json@@QEAA@XZ ; Json::Value::CommentInfo::~CommentInfo
	mov	r8d, DWORD PTR [rbx]
	mov	edx, 8
	call	??_M@YAXPEAX_KHP6AX0@Z@Z
	mov	rcx, rbx
	call	QWORD PTR __imp_??_V@YAXPEAX@Z
$LN713@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 491  :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {

	lea	rdx, QWORD PTR colon$5[rsp]
	mov	rcx, rdi
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	$LN7@readObject
	cmp	DWORD PTR colon$5[rsp], 11
	jne	$LN7@readObject

; 494  :     }
; 495  :     Value& value = currentValue()[name];

	mov	rcx, rdi
	call	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ; Json::Reader::currentValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	r9, QWORD PTR name$[rbp-256]
	cmp	QWORD PTR name$[rbp-232], 16
	cmovae	r9, QWORD PTR name$[rbp-256]
	lea	rdx, QWORD PTR name$[rbp-256]
	cmovae	rdx, QWORD PTR name$[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1106 :   return resolveReference(key.data(), key.data() + key.length());

	mov	r8, QWORD PTR name$[rbp-240]
	add	r8, r9
	mov	rcx, rax
	call	?resolveReference@Value@Json@@AEAAAEAV12@PEBD0@Z ; Json::Value::resolveReference
	mov	r14, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rdx, QWORD PTR [rdi+32]
	movzx	ecx, BYTE PTR [rdi+24]
	add	cl, dl
	test	cl, 1
	jne	SHORT $LN1002@readObject
	lea	rcx, QWORD PTR [rdx+2]
	shr	rcx, 1
	cmp	QWORD PTR [rdi+16], rcx
	ja	SHORT $LN1002@readObject
	mov	rcx, rdi
	call	?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Growmap
$LN1002@readObject:
	mov	rdx, QWORD PTR [rdi+16]
	lea	rax, QWORD PTR [rdx*2-1]
	and	QWORD PTR [rdi+24], rax
	mov	rsi, QWORD PTR [rdi+24]
	add	rsi, QWORD PTR [rdi+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rbx, rsi
	shr	rbx, 1
	lea	rax, QWORD PTR [rdx-1]
	and	rbx, rax

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rdi+8]
	cmp	QWORD PTR [rax+rbx*8], 0
	jne	SHORT $LN1001@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	je	$LN1489@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rcx, QWORD PTR [rdi+8]
	mov	QWORD PTR [rcx+rbx*8], rax
$LN1001@readObject:

; 1132 : 		this->_Getal().construct(
; 1133 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 			_STD forward<value_type>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	and	esi, 1
	mov	rax, QWORD PTR [rax+rbx*8]
	lea	rcx, QWORD PTR [rax+rsi*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN1038@readObject
	mov	QWORD PTR [rcx], r14
$LN1038@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1135 : 		_PUSH_BACK_END;

	inc	QWORD PTR [rdi+32]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 497  :     bool ok = readValue();

	mov	rcx, rdi
	call	?readValue@Reader@Json@@AEAA_NXZ	; Json::Reader::readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1491 : 		if (--this->_Mysize == 0)

	dec	QWORD PTR [rdi+32]
	jne	SHORT $LN1047@readObject

; 1492 : 			this->_Myoff = 0;

	mov	QWORD PTR [rdi+24], r15
$LN1047@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 505  :          comma.type_ != tokenComment)) {

	mov	rcx, rdi

; 498  :     nodes_.pop();
; 499  :     if (!ok) // error already set

	test	al, al
	je	$LN1490@readObject

; 505  :          comma.type_ != tokenComment)) {

	lea	rdx, QWORD PTR comma$10[rsp]
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	SHORT $LN4@readObject
	mov	ecx, DWORD PTR comma$10[rsp]
	lea	eax, DWORD PTR [rcx-2]
	test	eax, -11				; fffffff5H
	jne	SHORT $LN4@readObject
	cmp	ecx, 4
	je	SHORT $LN4@readObject

; 508  :     }
; 509  :     bool finalizeTokenOk = true;

	mov	al, 1

; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)

	cmp	ecx, 12
	jne	SHORT $LN2@readObject
	npad	1
$LL3@readObject:
	test	al, al
	je	SHORT $LN2@readObject

; 511  :       finalizeTokenOk = readToken(comma);

	lea	rdx, QWORD PTR comma$10[rsp]
	mov	rcx, rdi
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken

; 510  :     while (comma.type_ == tokenComment && finalizeTokenOk)

	mov	ecx, DWORD PTR comma$10[rsp]
	cmp	ecx, 12
	je	SHORT $LL3@readObject
$LN2@readObject:

; 512  :     if (comma.type_ == tokenObjectEnd)

	cmp	ecx, 2
	jne	$LN1514@readObject
$LN1484@readObject:
	mov	bl, 1
	jmp	$LN1444@readObject
$LN1485@readObject:

; 480  :         return recoverFromError(tokenObjectEnd);

	mov	edx, 2
	mov	rcx, rdi
	call	?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	movzx	ebx, al
	jmp	$LN1444@readObject
$LN1489@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN4@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T17[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T17[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T17[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 40					; 00000028H
	lea	rdx, OFFSET FLAT:??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
	lea	rcx, QWORD PTR $T17[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR info$13[rbp-208], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$13[rbp-216], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$13[rbp-232], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 756  :   info.token_ = token;

	movups	xmm0, XMMWORD PTR comma$10[rsp]
	movaps	XMMWORD PTR info$13[rbp-256], xmm0
	movsdx	xmm1, QWORD PTR comma$10[rsp+16]
	movsdx	QWORD PTR info$13[rbp-240], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T17[rbp-256]
	lea	rcx, QWORD PTR info$13[rbp-232]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 758  :   info.extra_ = extra;

	mov	QWORD PTR info$13[rbp-200], r15

; 759  :   errors_.push_back(info);

	lea	rbx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR info$13[rbp-256]
	mov	rcx, rbx
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$13[rbp-208], 16
	jb	SHORT $LN1251@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$13[rbp-232]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN1251@readObject:
	mov	QWORD PTR info$13[rbp-208], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$13[rbp-216], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$13[rbp-232], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1352 : 		return (this->_Mysize);

	mov	rsi, QWORD PTR [rdi+72]
	npad	11
$LL1267@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 767  :     if (!readToken(skip))

	lea	rdx, QWORD PTR skip$1[rsp]
	mov	rcx, rdi
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN1265@readObject

; 768  :       errors_.resize(errorCount); // discard errors caused by recovery

	mov	rdx, rsi
	mov	rcx, rbx
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN1265@readObject:

; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)

	mov	eax, DWORD PTR skip$1[rsp]
	cmp	eax, 2
	je	SHORT $LN1493@readObject
	test	eax, eax
	jne	SHORT $LL1267@readObject
$LN1493@readObject:

; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize

; 506  :       return addErrorAndRecover(
; 507  :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);

	xor	bl, bl
$LN1515@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T17[rbp-232], 16
	jb	$LN1444@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T17[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	jmp	$LN1444@readObject
$LN1490@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 500  :       return recoverFromError(tokenObjectEnd);

	mov	edx, 2
	call	?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	movzx	ebx, al
	jmp	$LN1444@readObject
$LN7@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T18[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T18[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T18[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 36					; 00000024H
	lea	rdx, OFFSET FLAT:??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
	lea	rcx, QWORD PTR $T18[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR info$14[rbp-208], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$14[rbp-216], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$14[rbp-232], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 756  :   info.token_ = token;

	movups	xmm0, XMMWORD PTR colon$5[rsp]
	movaps	XMMWORD PTR info$14[rbp-256], xmm0
	movsdx	xmm1, QWORD PTR colon$5[rsp+16]
	movsdx	QWORD PTR info$14[rbp-240], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T18[rbp-256]
	lea	rcx, QWORD PTR info$14[rbp-232]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 758  :   info.extra_ = extra;

	mov	QWORD PTR info$14[rbp-200], r15

; 759  :   errors_.push_back(info);

	lea	rbx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR info$14[rbp-256]
	mov	rcx, rbx
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$14[rbp-208], 16
	jb	SHORT $LN888@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$14[rbp-232]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN888@readObject:
	mov	QWORD PTR info$14[rbp-208], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$14[rbp-216], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$14[rbp-232], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1352 : 		return (this->_Mysize);

	mov	rsi, QWORD PTR [rdi+72]
	npad	9
$LL904@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 767  :     if (!readToken(skip))

	lea	rdx, QWORD PTR skip$2[rsp]
	mov	rcx, rdi
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN902@readObject

; 768  :       errors_.resize(errorCount); // discard errors caused by recovery

	mov	rdx, rsi
	mov	rcx, rbx
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN902@readObject:

; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)

	mov	eax, DWORD PTR skip$2[rsp]
	cmp	eax, 2
	je	SHORT $LN1494@readObject
	test	eax, eax
	jne	SHORT $LL904@readObject
$LN1494@readObject:

; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize

; 492  :       return addErrorAndRecover(
; 493  :           "Missing ':' after object member name", colon, tokenObjectEnd);

	xor	bl, bl
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	jmp	$LN1515@readObject
$LN1487@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 492  : 		{	// construct empty writable character buffer

	lea	rax, OFFSET FLAT:??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	mov	QWORD PTR oss$12[rbp-256], rax
	lea	rcx, QWORD PTR oss$12[rbp-120]
	call	QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	mov	DWORD PTR $T6[rsp], 1
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, QWORD PTR oss$12[rbp-248]
	lea	rcx, QWORD PTR oss$12[rbp-256]
	call	QWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	npad	1
	mov	rax, QWORD PTR oss$12[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR oss$12[rbp+rcx-256], rax
	mov	rax, QWORD PTR oss$12[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-136]
	mov	DWORD PTR oss$12[rbp+rcx-260], edx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

	lea	rcx, QWORD PTR oss$12[rbp-248]
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR oss$12[rbp-248], rax

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode
; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}
; 33   : 
; 34   : 	explicit basic_stringbuf(const _Mystr& _Str,
; 35   : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 36   : 		{	// construct character buffer from string, mode
; 37   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
; 38   : 		}
; 39   : 
; 40   : 	basic_stringbuf(_Myt&& _Right)
; 41   : 		{	// construct by moving _Right
; 42   : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 43   : 		}
; 44   : 
; 45   : 	_Myt& operator=(_Myt&& _Right)
; 46   : 		{	// assign from _Right
; 47   : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 48   : 		return (*this);
; 49   : 		}
; 50   : 
; 51   : 	void _Assign_rv(_Myt&& _Right)
; 52   : 		{	// assign by moving _Right
; 53   : 		if (this != &_Right)
; 54   : 			{	// different, worth moving
; 55   : 			_Tidy();
; 56   : 			this->swap(_Right);
; 57   : 			}
; 58   : 		}
; 59   : 
; 60   : 	void swap(_Myt& _Right)
; 61   : 		{	// swap with _Right
; 62   : 		if (this != &_Right)
; 63   : 			{	// different, worth swapping
; 64   : 			_Mysb::swap(_Right);
; 65   : 			_STD swap(_Seekhigh, _Right._Seekhigh);
; 66   : 			_STD swap(_Mystate, _Right._Mystate);
; 67   : 			_Swap_adl(_Al, _Right._Al);
; 68   : 			}
; 69   : 		}
; 70   : 
; 71   : 	basic_stringbuf(const _Myt&) = delete;
; 72   : 	_Myt& operator=(const _Myt&) = delete;
; 73   : 
; 74   : 	virtual ~basic_stringbuf() _NOEXCEPT
; 75   : 		{	// destroy the object
; 76   : 		_Tidy();
; 77   : 		}
; 78   : 
; 79   : 	enum
; 80   : 		{	// constants for bits in stream state
; 81   : 		_Allocated = 1,	// set if character array storage has been allocated
; 82   : 		_Constant = 2,	// set if character array nonmutable
; 83   : 		_Noread = 4,	// set if character array cannot be read
; 84   : 		_Append = 8,	// set if all writes are appends
; 85   : 		_Atend = 16};	// set if initial writes are appends
; 86   : 	typedef int _Strstate;
; 87   : 
; 88   : 	typedef typename _Traits::int_type int_type;
; 89   : 	typedef typename _Traits::pos_type pos_type;
; 90   : 	typedef typename _Traits::off_type off_type;
; 91   : 
; 92   : 	_Mystr str() const
; 93   : 		{	// return string copy of character array
; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)
; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);
; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)
; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());
; 103  : 			return (_Str);
; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;
; 108  : 			return (_Nul);
; 109  : 			}
; 110  : 		}
; 111  : 
; 112  : 	void str(const _Mystr& _Newstr)
; 113  : 		{	// replace character array from string
; 114  : 		_Tidy();
; 115  : 		_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
; 116  : 		}
; 117  : 
; 118  : protected:
; 119  : 	virtual int_type overflow(int_type _Meta = _Traits::eof())
; 120  : 		{	// put an element to stream
; 121  : 		if (_Mystate & _Constant)
; 122  : 			return (_Traits::eof());	// array nonmutable, fail
; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))
; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code
; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)
; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());
; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())
; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 134  : 			return (_Meta);
; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0
; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE
; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)
; 145  : 				_Inc /= 2;	// increment causes overflow, halve it
; 146  : 			if (_Inc == 0)
; 147  : 				return (_Traits::eof());	// buffer can't grow, fail
; 148  : 
; 149  : 			_Newsize += _Inc;
; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);
; 152  : 			_Elem *_Oldptr = _Mysb::eback();
; 153  : 
; 154  : 			if (0 < _Oldsize)
; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);
; 156  : 
; 157  : 			if (_Oldsize == 0)
; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);
; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 163  : 				else
; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);
; 165  : 				}
; 166  : 			else
; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)
; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 174  : 				else
; 175  : 					_Mysb::setg(_Newptr,
; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)
; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);
; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}
; 188  : 
; 189  : 	virtual int_type pbackfail(int_type _Meta = _Traits::eof())
; 190  : 		{	// put an element back to stream
; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)
; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail
; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);
; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);
; 202  : 			return (_Traits::not_eof(_Meta));
; 203  : 			}
; 204  : 		}
; 205  : 
; 206  : 	virtual int_type underflow()
; 207  : 		{	// get an element from stream, but don't point past it
; 208  : 		if (_Mysb::gptr() == 0)
; 209  : 			return (_Traits::eof());	// no character buffer, fail
; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())
; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered
; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))
; 214  : 			return (_Traits::eof());	// can't read, fail
; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())
; 218  : 				_Seekhigh = _Mysb::pptr();
; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));
; 221  : 			}
; 222  : 		}
; 223  : 
; 224  : 	virtual pos_type seekoff(off_type _Off,
; 225  : 		ios_base::seekdir _Way,
; 226  : 		ios_base::openmode _Which = ios_base::in | ios_base::out)
; 227  : 		{	// change position by _Off, according to _Way, _Mode
; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)
; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)
; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 235  : 			else if (_Way == ios_base::cur
; 236  : 				&& (_Which & ios_base::out) == 0)
; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());
; 238  : 			else if (_Way != ios_base::beg)
; 239  : 				_Off = _BADOFF;
; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else
; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)
; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 255  : 			else if (_Way == ios_base::cur)
; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());
; 257  : 			else if (_Way != ios_base::beg)
; 258  : 				_Off = _BADOFF;
; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 261  : 				_Mysb::pbump((int)(_Mysb::eback()
; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else
; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)
; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 271  : 		return (pos_type(_Off));
; 272  : 		}
; 273  : 
; 274  : 	virtual pos_type seekpos(pos_type _Ptr,
; 275  : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 276  : 		{	// change position to _Pos, according to _Mode
; 277  : 		streamoff _Off = (streamoff)_Ptr;
; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 280  : 
; 281  : 		if (_Off == _BADOFF)
; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)
; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else
; 293  : 				_Off = _BADOFF;
; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 298  : 				_Mysb::pbump((int)(_Mysb::eback()
; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else
; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 305  : 		return (streampos(_Off));
; 306  : 		}
; 307  : 
; 308  : 	void _Init(const _Elem *_Ptr,
; 309  : 		size_t _Count, _Strstate _State)
; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state
; 311  : 		_Seekhigh = 0;

	mov	QWORD PTR oss$12[rbp-144], r15

; 312  : 		_Mystate = _State;

	mov	DWORD PTR oss$12[rbp-136], 4
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 645  :                       "in Json::Value::asCString(): requires stringValue");

	lea	rdx, OFFSET FLAT:??_C@_0DC@KHAHPDOM@in?5Json?3?3Value?3?3asCString?$CI?$CJ?3?5req@
	lea	rcx, QWORD PTR oss$12[rbp-256]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, QWORD PTR $T20[rbp-256]
	lea	rcx, QWORD PTR oss$12[rbp-256]
	call	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
	npad	1
	mov	rcx, rax
	call	?throwLogicError@Json@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::throwLogicError
	npad	1
$LN1486@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 484  :         return recoverFromError(tokenObjectEnd);

	mov	edx, 2
	mov	rcx, rdi
	call	?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	movzx	ebx, al
	lea	rcx, QWORD PTR numberName$15[rbp-256]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	jmp	$LN1444@readObject
$LN11@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T16[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T16[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T16[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 33					; 00000021H
	lea	rdx, OFFSET FLAT:??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
	lea	rcx, QWORD PTR $T16[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 779  :   addError(message, token);

	xor	r9d, r9d
	lea	r8, QWORD PTR tokenName$[rsp]
	lea	rdx, QWORD PTR $T16[rbp-256]
	mov	rcx, rdi
	call	?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::Reader::addError

; 780  :   return recoverFromError(skipUntilToken);

	mov	edx, 2
	mov	rcx, rdi
	call	?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	movzx	ebx, al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T16[rbp-232], 16
	jb	SHORT $LN1434@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T16[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN1434@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T16[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T16[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T16[rbp-256], 0
$LN1444@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);

	lea	rcx, QWORD PTR init$[rsp]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR name$[rbp-232], 16
	jb	SHORT $LN1466@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR name$[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN1466@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 516  :       "Missing '}' or object member name", tokenName, tokenObjectEnd);

	movzx	eax, bl

; 517  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+592]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rdi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
$LN1512@readObject:
?readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z ENDP	; Json::Reader::readObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$0@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$0
	lea	rcx, QWORD PTR name$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$7@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$7
	mov	rcx, QWORD PTR $T7[rdx]
	rex_jmp	QWORD PTR __imp_??3@YAXPEAX@Z
?dtor$7@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$1@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$1
	lea	rcx, QWORD PTR init$[rdx]
	jmp	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
?dtor$1@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$2@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$2
	lea	rcx, QWORD PTR numberName$15[rdx]
	jmp	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
?dtor$2@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$19@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$19
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T6[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN307@dtor$19
	and	DWORD PTR $T6[rbp], -2
	lea	rcx, QWORD PTR oss$12[rbp]
	add	rcx, 136				; 00000088H
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN307@dtor$19:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$19@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$20@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$20
	lea	rcx, QWORD PTR oss$12[rdx]
	add	rcx, 16
	rex_jmp	QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$20@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$22@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$22
	mov	rcx, QWORD PTR this$21[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$22@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$17@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$17
	lea	rcx, QWORD PTR oss$12[rdx]
	jmp	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$17@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$18@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$18
	lea	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$18@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$4@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$4
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$23@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$23
	lea	rcx, QWORD PTR info$14[rdx]
	jmp	??1ErrorInfo@Reader@Json@@QEAA@XZ
?dtor$23@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$23
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$5@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$5
	lea	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$24@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$24
	lea	rcx, QWORD PTR info$13[rdx]
	jmp	??1ErrorInfo@Reader@Json@@QEAA@XZ
?dtor$24@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$24
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
skip$1 = 40
skip$2 = 40
$T3 = 40
$T4 = 40
colon$5 = 40
$T6 = 64
$T7 = 64
$T8 = 72
$T9 = 72
comma$10 = 72
tokenName$ = 96
init$ = 120
$T11 = 160
oss$12 = 176
info$13 = 416
info$14 = 416
numberName$15 = 416
$T16 = 480
$T17 = 480
$T18 = 480
$T19 = 480
name$ = 512
$T20 = 544
this$21 = 576
__$ArrayPad$ = 584
this$ = 624
tokenStart$ = 632
?dtor$6@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readObject'::`1'::dtor$6
	lea	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??readObject@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readObject'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z PROC	; Json::Reader::readArray, COMDAT

; 519  : bool Reader::readArray(Token& tokenStart) {

$LN579:
	mov	rax, rsp
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-248]
	sub	rsp, 464				; 000001d0H
	mov	QWORD PTR $T8[rsp], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r14, rdx
	mov	rdi, rcx
	xor	r12d, r12d
	mov	DWORD PTR $T2[rsp], r12d
	mov	r13d, DWORD PTR init$[rsp+8]
	and	r13d, -506				; fffffe06H
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	or	r13d, 6
	mov	DWORD PTR init$[rsp+8], r13d
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR init$[rsp+16], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR init$[rsp+32], r12

; 364  :     value_.map_ = new ObjectValues();

	lea	ecx, QWORD PTR [r12+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	rsi, rax
	mov	QWORD PTR $T3[rsp], rax
	test	rax, rax
	je	SHORT $LN30@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

	mov	QWORD PTR [rax], r12

; 570  : 		this->_Mysize = 0;

	mov	QWORD PTR [rax+8], r12

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Buyheadnode
	mov	QWORD PTR [rsi], rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 364  :     value_.map_ = new ObjectValues();

	jmp	SHORT $LN31@readArray
$LN30@readArray:
	mov	rsi, r12
$LN31@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T13[rbp-256]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	mov	r8, r12
	je	SHORT $LN66@readArray
	mov	r8, QWORD PTR [rcx]
$LN66@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	r8, QWORD PTR [rcx+rdx*8]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	ecx, BYTE PTR [r8+8]

; 518  :   type_ = other.type_;

	movzx	eax, BYTE PTR init$[rsp+8]
	mov	BYTE PTR [r8+8], al

; 519  :   other.type_ = temp;

	mov	eax, r13d
	xor	eax, ecx
	movzx	eax, al
	xor	r13d, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rbx, QWORD PTR [r8]

; 53   : 	_Left = _Move(_Right);

	mov	QWORD PTR [r8], rsi

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR init$[rsp], rbx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [r8+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, ecx
	xor	eax, r13d
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, r13d
	and	edx, 256				; 00000100H
	xor	r13d, edx
	mov	DWORD PTR init$[rsp+8], r13d
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T12[rbp-256]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T5[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN91@readArray
	mov	r8, r12
	jmp	SHORT $LN92@readArray
$LN91@readArray:
	mov	r8, QWORD PTR [r8]
$LN92@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 520  :   Value init(arrayValue);
; 521  :   currentValue().swapPayload(init);
; 522  :   currentValue().setOffsetStart(tokenStart.start_ - begin_);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [rdi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rdx+24], rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 330  :   while (current_ != end_) {

	mov	rdx, QWORD PTR [rdi+120]
	cmp	QWORD PTR [rdi+128], rdx
	je	SHORT $LN99@readArray
	mov	r8, 4294977024				; 0000000100002600H
$LL101@readArray:

; 331  :     Char c = *current_;

	mov	rcx, QWORD PTR [rdi+128]
	movzx	eax, BYTE PTR [rcx]
	cmp	al, 32					; 00000020H
	ja	SHORT $LN99@readArray
	bt	r8, rax
	jae	SHORT $LN99@readArray

; 332  :     if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
; 333  :       ++current_;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+128], rax

; 330  :   while (current_ != end_) {

	cmp	rax, rdx
	jne	SHORT $LL101@readArray
$LN99@readArray:

; 523  :   skipSpaces();
; 524  :   if (current_ != end_ && *current_ == ']') // empty array

	mov	rax, QWORD PTR [rdi+128]
	cmp	rax, rdx
	je	SHORT $LN9@readArray
	cmp	BYTE PTR [rax], 93			; 0000005dH
	jne	SHORT $LN9@readArray

; 525  :   {
; 526  :     Token endArray;
; 527  :     readToken(endArray);

	lea	rdx, QWORD PTR endArray$15[rbp-256]
	mov	rcx, rdi
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken
$LN562@readArray:
	mov	dil, 1
	jmp	$LN18@readArray
$LN9@readArray:

; 528  :     return true;
; 529  :   }
; 530  :   int index = 0;

	mov	r15d, r12d

; 532  :     Value& value = currentValue()[index++];

	mov	esi, r12d
	mov	rcx, rdi
	call	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ; Json::Reader::currentValue
	npad	6
$LL8@readArray:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 998  :   return (*this)[ArrayIndex(index)];

	mov	edx, esi
	mov	rcx, rax
	call	??AValue@Json@@QEAAAEAV01@I@Z		; Json::Value::operator[]
	mov	r12, rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 532  :     Value& value = currentValue()[index++];

	inc	r15d
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rdx, QWORD PTR [rdi+32]
	movzx	ecx, BYTE PTR [rdi+24]
	add	cl, dl
	test	cl, 1
	jne	SHORT $LN194@readArray
	lea	rcx, QWORD PTR [rdx+2]
	shr	rcx, 1
	cmp	QWORD PTR [rdi+16], rcx
	ja	SHORT $LN194@readArray
	mov	rcx, rdi
	call	?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Growmap
$LN194@readArray:
	mov	rdx, QWORD PTR [rdi+16]
	lea	rax, QWORD PTR [rdx*2-1]
	and	QWORD PTR [rdi+24], rax
	mov	r14, QWORD PTR [rdi+24]
	add	r14, QWORD PTR [rdi+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	lea	rsi, QWORD PTR [rdx-1]
	mov	rax, r14
	shr	rax, 1
	and	rsi, rax

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rdi+8]
	cmp	QWORD PTR [rax+rsi*8], 0
	jne	SHORT $LN193@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	je	$LN559@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rcx, QWORD PTR [rdi+8]
	mov	QWORD PTR [rcx+rsi*8], rax
$LN193@readArray:

; 1132 : 		this->_Getal().construct(
; 1133 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 			_STD forward<value_type>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	and	r14d, 1
	mov	rax, QWORD PTR [rax+rsi*8]
	lea	rcx, QWORD PTR [rax+r14*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN230@readArray
	mov	QWORD PTR [rcx], r12
$LN230@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1135 : 		_PUSH_BACK_END;

	inc	QWORD PTR [rdi+32]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 534  :     bool ok = readValue();

	mov	rcx, rdi
	call	?readValue@Reader@Json@@AEAA_NXZ	; Json::Reader::readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1492 : 			this->_Myoff = 0;

	xor	r14d, r14d

; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1491 : 		if (--this->_Mysize == 0)

	dec	QWORD PTR [rdi+32]
	jne	SHORT $LN239@readArray

; 1492 : 			this->_Myoff = 0;

	mov	QWORD PTR [rdi+24], r14
$LN239@readArray:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 541  :     ok = readToken(token);

	mov	rcx, rdi

; 535  :     nodes_.pop();
; 536  :     if (!ok) // error already set

	test	al, al
	je	$LN560@readArray

; 541  :     ok = readToken(token);

	lea	rdx, QWORD PTR token$7[rsp]
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken

; 542  :     while (token.type_ == tokenComment && ok) {

	mov	ecx, DWORD PTR token$7[rsp]
	cmp	ecx, 12
	jne	SHORT $LN4@readArray
	npad	1
$LL5@readArray:
	test	al, al
	je	SHORT $LN4@readArray

; 543  :       ok = readToken(token);

	lea	rdx, QWORD PTR token$7[rsp]
	mov	rcx, rdi
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken

; 542  :     while (token.type_ == tokenComment && ok) {

	mov	ecx, DWORD PTR token$7[rsp]
	cmp	ecx, 12
	je	SHORT $LL5@readArray
$LN4@readArray:

; 544  :     }
; 545  :     bool badTokenType =
; 546  :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);

	cmp	ecx, 10
	je	SHORT $LN12@readArray
	cmp	ecx, 4
	je	SHORT $LN12@readArray
	mov	dl, 1
	jmp	SHORT $LN13@readArray
$LN12@readArray:
	xor	dl, dl
$LN13@readArray:

; 547  :     if (!ok || badTokenType) {

	test	al, al
	je	$LN2@readArray
	test	dl, dl
	jne	$LN2@readArray

; 550  :     }
; 551  :     if (token.type_ == tokenArrayEnd)

	cmp	ecx, 4
	je	$LN562@readArray

; 532  :     Value& value = currentValue()[index++];

	mov	esi, r15d
	mov	rcx, rdi
	call	?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ; Json::Reader::currentValue
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 997  :       "in Json::Value::operator[](int index): index cannot be negative");

	test	r15d, r15d
	js	SHORT $LN574@readArray
	jmp	$LL8@readArray
$LN559@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN574@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 492  : 		{	// construct empty writable character buffer

	lea	rax, OFFSET FLAT:??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	mov	QWORD PTR oss$9[rsp], rax
	lea	rcx, QWORD PTR oss$9[rbp-120]
	call	QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	mov	DWORD PTR $T2[rsp], 1
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, QWORD PTR oss$9[rsp+8]
	lea	rcx, QWORD PTR oss$9[rsp]
	call	QWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	npad	1
	mov	rax, QWORD PTR oss$9[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR oss$9[rsp+rcx], rax
	mov	rax, QWORD PTR oss$9[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-136]
	mov	DWORD PTR oss$9[rsp+rcx-4], edx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

	lea	rcx, QWORD PTR oss$9[rsp+8]
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR oss$9[rsp+8], rax

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode
; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}
; 33   : 
; 34   : 	explicit basic_stringbuf(const _Mystr& _Str,
; 35   : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 36   : 		{	// construct character buffer from string, mode
; 37   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
; 38   : 		}
; 39   : 
; 40   : 	basic_stringbuf(_Myt&& _Right)
; 41   : 		{	// construct by moving _Right
; 42   : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 43   : 		}
; 44   : 
; 45   : 	_Myt& operator=(_Myt&& _Right)
; 46   : 		{	// assign from _Right
; 47   : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 48   : 		return (*this);
; 49   : 		}
; 50   : 
; 51   : 	void _Assign_rv(_Myt&& _Right)
; 52   : 		{	// assign by moving _Right
; 53   : 		if (this != &_Right)
; 54   : 			{	// different, worth moving
; 55   : 			_Tidy();
; 56   : 			this->swap(_Right);
; 57   : 			}
; 58   : 		}
; 59   : 
; 60   : 	void swap(_Myt& _Right)
; 61   : 		{	// swap with _Right
; 62   : 		if (this != &_Right)
; 63   : 			{	// different, worth swapping
; 64   : 			_Mysb::swap(_Right);
; 65   : 			_STD swap(_Seekhigh, _Right._Seekhigh);
; 66   : 			_STD swap(_Mystate, _Right._Mystate);
; 67   : 			_Swap_adl(_Al, _Right._Al);
; 68   : 			}
; 69   : 		}
; 70   : 
; 71   : 	basic_stringbuf(const _Myt&) = delete;
; 72   : 	_Myt& operator=(const _Myt&) = delete;
; 73   : 
; 74   : 	virtual ~basic_stringbuf() _NOEXCEPT
; 75   : 		{	// destroy the object
; 76   : 		_Tidy();
; 77   : 		}
; 78   : 
; 79   : 	enum
; 80   : 		{	// constants for bits in stream state
; 81   : 		_Allocated = 1,	// set if character array storage has been allocated
; 82   : 		_Constant = 2,	// set if character array nonmutable
; 83   : 		_Noread = 4,	// set if character array cannot be read
; 84   : 		_Append = 8,	// set if all writes are appends
; 85   : 		_Atend = 16};	// set if initial writes are appends
; 86   : 	typedef int _Strstate;
; 87   : 
; 88   : 	typedef typename _Traits::int_type int_type;
; 89   : 	typedef typename _Traits::pos_type pos_type;
; 90   : 	typedef typename _Traits::off_type off_type;
; 91   : 
; 92   : 	_Mystr str() const
; 93   : 		{	// return string copy of character array
; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)
; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);
; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)
; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());
; 103  : 			return (_Str);
; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;
; 108  : 			return (_Nul);
; 109  : 			}
; 110  : 		}
; 111  : 
; 112  : 	void str(const _Mystr& _Newstr)
; 113  : 		{	// replace character array from string
; 114  : 		_Tidy();
; 115  : 		_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
; 116  : 		}
; 117  : 
; 118  : protected:
; 119  : 	virtual int_type overflow(int_type _Meta = _Traits::eof())
; 120  : 		{	// put an element to stream
; 121  : 		if (_Mystate & _Constant)
; 122  : 			return (_Traits::eof());	// array nonmutable, fail
; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))
; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code
; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)
; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());
; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())
; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 134  : 			return (_Meta);
; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0
; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE
; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)
; 145  : 				_Inc /= 2;	// increment causes overflow, halve it
; 146  : 			if (_Inc == 0)
; 147  : 				return (_Traits::eof());	// buffer can't grow, fail
; 148  : 
; 149  : 			_Newsize += _Inc;
; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);
; 152  : 			_Elem *_Oldptr = _Mysb::eback();
; 153  : 
; 154  : 			if (0 < _Oldsize)
; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);
; 156  : 
; 157  : 			if (_Oldsize == 0)
; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);
; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 163  : 				else
; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);
; 165  : 				}
; 166  : 			else
; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)
; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 174  : 				else
; 175  : 					_Mysb::setg(_Newptr,
; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)
; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);
; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}
; 188  : 
; 189  : 	virtual int_type pbackfail(int_type _Meta = _Traits::eof())
; 190  : 		{	// put an element back to stream
; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)
; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail
; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);
; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);
; 202  : 			return (_Traits::not_eof(_Meta));
; 203  : 			}
; 204  : 		}
; 205  : 
; 206  : 	virtual int_type underflow()
; 207  : 		{	// get an element from stream, but don't point past it
; 208  : 		if (_Mysb::gptr() == 0)
; 209  : 			return (_Traits::eof());	// no character buffer, fail
; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())
; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered
; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))
; 214  : 			return (_Traits::eof());	// can't read, fail
; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())
; 218  : 				_Seekhigh = _Mysb::pptr();
; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));
; 221  : 			}
; 222  : 		}
; 223  : 
; 224  : 	virtual pos_type seekoff(off_type _Off,
; 225  : 		ios_base::seekdir _Way,
; 226  : 		ios_base::openmode _Which = ios_base::in | ios_base::out)
; 227  : 		{	// change position by _Off, according to _Way, _Mode
; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)
; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)
; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 235  : 			else if (_Way == ios_base::cur
; 236  : 				&& (_Which & ios_base::out) == 0)
; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());
; 238  : 			else if (_Way != ios_base::beg)
; 239  : 				_Off = _BADOFF;
; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else
; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)
; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 255  : 			else if (_Way == ios_base::cur)
; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());
; 257  : 			else if (_Way != ios_base::beg)
; 258  : 				_Off = _BADOFF;
; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 261  : 				_Mysb::pbump((int)(_Mysb::eback()
; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else
; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)
; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 271  : 		return (pos_type(_Off));
; 272  : 		}
; 273  : 
; 274  : 	virtual pos_type seekpos(pos_type _Ptr,
; 275  : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 276  : 		{	// change position to _Pos, according to _Mode
; 277  : 		streamoff _Off = (streamoff)_Ptr;
; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 280  : 
; 281  : 		if (_Off == _BADOFF)
; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)
; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else
; 293  : 				_Off = _BADOFF;
; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 298  : 				_Mysb::pbump((int)(_Mysb::eback()
; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else
; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 305  : 		return (streampos(_Off));
; 306  : 		}
; 307  : 
; 308  : 	void _Init(const _Elem *_Ptr,
; 309  : 		size_t _Count, _Strstate _State)
; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state
; 311  : 		_Seekhigh = 0;

	mov	QWORD PTR oss$9[rbp-144], r14

; 312  : 		_Mystate = _State;

	mov	DWORD PTR oss$9[rbp-136], 4
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 997  :       "in Json::Value::operator[](int index): index cannot be negative");

	lea	rdx, OFFSET FLAT:??_C@_0EA@BFHDEBDG@in?5Json?3?3Value?3?3operator?$FL?$FN?$CIint?5i@
	lea	rcx, QWORD PTR oss$9[rsp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, QWORD PTR $T11[rbp-256]
	lea	rcx, QWORD PTR oss$9[rsp]
	call	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
	npad	1
	mov	rcx, rax
	call	?throwLogicError@Json@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::throwLogicError
	npad	1
$LN2@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T14[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T14[rbp-240], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T14[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 39					; 00000027H
	lea	rdx, OFFSET FLAT:??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR info$10[rbp-208], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$10[rbp-216], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$10[rbp-232], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 756  :   info.token_ = token;

	movups	xmm0, XMMWORD PTR token$7[rsp]
	movaps	XMMWORD PTR info$10[rbp-256], xmm0
	movsdx	xmm1, QWORD PTR token$7[rsp+16]
	movsdx	QWORD PTR info$10[rbp-240], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T14[rbp-256]
	lea	rcx, QWORD PTR info$10[rbp-232]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 758  :   info.extra_ = extra;

	mov	QWORD PTR info$10[rbp-200], r14

; 759  :   errors_.push_back(info);

	lea	rdx, QWORD PTR info$10[rbp-256]
	lea	rcx, QWORD PTR [rdi+40]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$10[rbp-208], 16
	jb	SHORT $LN411@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$10[rbp-232]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN411@readArray:
	mov	QWORD PTR info$10[rbp-208], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$10[rbp-216], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$10[rbp-232], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1352 : 		return (this->_Mysize);

	mov	r14, QWORD PTR [rdi+72]
$LL427@readArray:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 767  :     if (!readToken(skip))

	lea	rdx, QWORD PTR skip$4[rsp]
	mov	rcx, rdi
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN425@readArray

; 768  :       errors_.resize(errorCount); // discard errors caused by recovery

	mov	rdx, r14
	lea	rcx, QWORD PTR [rdi+40]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN425@readArray:

; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)

	mov	eax, DWORD PTR skip$4[rsp]
	cmp	eax, 4
	je	SHORT $LN563@readArray
	test	eax, eax
	jne	SHORT $LL427@readArray
$LN563@readArray:

; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);

	mov	rdx, r14
	lea	rcx, QWORD PTR [rdi+40]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize

; 548  :       return addErrorAndRecover(
; 549  :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);

	xor	dil, dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T14[rbp-232], 16
	jb	SHORT $LN18@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T14[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	jmp	SHORT $LN18@readArray
$LN560@readArray:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 537  :       return recoverFromError(tokenArrayEnd);

	mov	edx, 4
	call	?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	movzx	edi, al
$LN18@readArray:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 487  :   switch (type_) {

	movsx	eax, BYTE PTR init$[rsp+8]
	cmp	eax, 4
	je	SHORT $LN467@readArray
	add	eax, -6					; fffffffaH
	cmp	eax, 1
	ja	SHORT $LN477@readArray

; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;

	test	rbx, rbx
	je	SHORT $LN477@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

	mov	r8, QWORD PTR [rbx]
	mov	r9, r8
	mov	r8, QWORD PTR [r8]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	mov	rcx, rbx
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 501  :     break;

	jmp	SHORT $LN477@readArray
$LN467@readArray:

; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)

	bt	r13d, 8
	jae	SHORT $LN477@readArray

; 170  :   free(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN477@readArray:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 554  :   return true;

	movzx	eax, dil

; 555  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+464]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN578@readArray:
?readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z ENDP	; Json::Reader::readArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$2@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readArray'::`1'::dtor$2
	mov	rcx, QWORD PTR $T3[rdx]
	rex_jmp	QWORD PTR __imp_??3@YAXPEAX@Z
?dtor$2@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readArray'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$0@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readArray'::`1'::dtor$0
	lea	rcx, QWORD PTR init$[rdx]
	jmp	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
?dtor$0@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readArray'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$9@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readArray'::`1'::dtor$9
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN113@dtor$9
	and	DWORD PTR $T2[rbp], -2
	lea	rcx, QWORD PTR oss$9[rbp]
	add	rcx, 136				; 00000088H
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN113@dtor$9:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$9@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readArray'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$10@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readArray'::`1'::dtor$10
	lea	rcx, QWORD PTR oss$9[rdx]
	add	rcx, 16
	rex_jmp	QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$10@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readArray'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$12@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readArray'::`1'::dtor$12
	mov	rcx, QWORD PTR this$16[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$12@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readArray'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$7@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readArray'::`1'::dtor$7
	lea	rcx, QWORD PTR oss$9[rdx]
	jmp	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$7@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readArray'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$8@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readArray'::`1'::dtor$8
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readArray'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$1@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readArray'::`1'::dtor$1
	lea	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readArray'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$13@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::readArray'::`1'::dtor$13
	lea	rcx, QWORD PTR info$10[rdx]
	jmp	??1ErrorInfo@Reader@Json@@QEAA@XZ
?dtor$13@?0??readArray@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::readArray'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z
_TEXT	SEGMENT
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 64
$T5 = 64
$T6 = 64
decoded$ = 88
this$ = 160
token$ = 168
$T7 = 176
?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z PROC	; Json::Reader::decodeNumber, COMDAT

; 557  : bool Reader::decodeNumber(Token& token) {

$LN193:
	mov	rax, rsp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 128				; 00000080H
	mov	QWORD PTR [rax-120], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	r14, rdx
	mov	rsi, rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	and	DWORD PTR [rax-56], -512		; fffffe00H
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR [rax-48], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	xor	edi, edi
	mov	QWORD PTR [rax-32], rdi
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 559  :   if (!decodeNumber(token, decoded))

	lea	r8, QWORD PTR [rax-64]
	call	?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ; Json::Reader::decodeNumber
	test	al, al
	jne	SHORT $LN1@decodeNumb
	mov	ebp, DWORD PTR decoded$[rsp+8]
	mov	rbx, QWORD PTR decoded$[rsp]
	jmp	$LN5@decodeNumb
$LN1@decodeNumb:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rsi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T6[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	mov	r8, rdi
	je	SHORT $LN53@decodeNumb
	mov	r8, QWORD PTR [rcx]
$LN53@decodeNumb:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	r8, QWORD PTR [rcx+rdx*8]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	ecx, BYTE PTR [r8+8]

; 518  :   type_ = other.type_;

	movzx	eax, BYTE PTR decoded$[rsp+8]
	mov	BYTE PTR [r8+8], al

; 519  :   other.type_ = temp;

	mov	ebp, DWORD PTR decoded$[rsp+8]
	mov	eax, ebp
	xor	eax, ecx
	movzx	eax, al
	xor	ebp, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rbx, QWORD PTR [r8]

; 53   : 	_Left = _Move(_Right);

	mov	rax, QWORD PTR decoded$[rsp]
	mov	QWORD PTR [r8], rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [r8+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, ecx
	xor	eax, ebp
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, ebp
	and	edx, 256				; 00000100H
	xor	ebp, edx
	mov	DWORD PTR decoded$[rsp+8], ebp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, rsi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T2[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN78@decodeNumb
	mov	r8, rdi
	jmp	SHORT $LN79@decodeNumb
$LN78@decodeNumb:
	mov	r8, QWORD PTR [r8]
$LN79@decodeNumb:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 560  :     return false;
; 561  :   currentValue().swapPayload(decoded);
; 562  :   currentValue().setOffsetStart(token.start_ - begin_);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [rsi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rdx+24], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rsi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T1[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN97@decodeNumb
	mov	rdi, QWORD PTR [rcx]
$LN97@decodeNumb:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [rdi+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 563  :   currentValue().setOffsetLimit(token.end_ - begin_);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, QWORD PTR [rsi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1422 : void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

	mov	QWORD PTR [rdx+32], rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 564  :   return true;

	mov	dil, 1
$LN5@decodeNumb:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 487  :   switch (type_) {

	movsx	eax, BYTE PTR decoded$[rsp+8]
	cmp	eax, 4
	je	SHORT $LN105@decodeNumb
	add	eax, -6					; fffffffaH
	cmp	eax, 1
	ja	SHORT $LN115@decodeNumb

; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;

	test	rbx, rbx
	je	SHORT $LN115@decodeNumb
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

	mov	r8, QWORD PTR [rbx]
	mov	r9, r8
	mov	r8, QWORD PTR [r8]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, rbx
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	mov	rcx, rbx
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 501  :     break;

	jmp	SHORT $LN115@decodeNumb
$LN105@decodeNumb:

; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)

	bt	ebp, 8
	jae	SHORT $LN115@decodeNumb

; 170  :   free(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN115@decodeNumb:

; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;

	mov	rcx, QWORD PTR decoded$[rsp+16]
	test	rcx, rcx
	je	SHORT $LN192@decodeNumb
	lea	rbx, QWORD PTR [rcx-8]
	lea	r9, OFFSET FLAT:??1CommentInfo@Value@Json@@QEAA@XZ ; Json::Value::CommentInfo::~CommentInfo
	mov	r8d, DWORD PTR [rbx]
	mov	edx, 8
	call	??_M@YAXPEAX_KHP6AX0@Z@Z
	mov	rcx, rbx
	call	QWORD PTR __imp_??_V@YAXPEAX@Z
$LN192@decodeNumb:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 564  :   return true;

	movzx	eax, dil

; 565  : }

	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z ENDP	; Json::Reader::decodeNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 64
$T5 = 64
$T6 = 64
decoded$ = 88
this$ = 160
token$ = 168
$T7 = 176
?dtor$0@?0??decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::decodeNumber'::`1'::dtor$0
	lea	rcx, QWORD PTR decoded$[rdx]
	jmp	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
?dtor$0@?0??decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::decodeNumber'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
this$ = 128
token$ = 136
decoded$ = 144
?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z PROC ; Json::Reader::decodeNumber, COMDAT

; 567  : bool Reader::decodeNumber(Token& token, Value& decoded) {

$LN49:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H

; 568  :   // Attempts to parse the number as an integer. If the number is
; 569  :   // larger than the maximum supported value of an integer then
; 570  :   // we decode the number as a double.
; 571  :   Location current = token.start_;

	mov	r9, QWORD PTR [rdx+8]
	mov	r11, r8
	mov	rsi, rdx

; 572  :   bool isNegative = *current == '-';

	cmp	BYTE PTR [r9], 45			; 0000002dH
	mov	r15, rcx

; 573  :   if (isNegative)

	mov	r13, -9223372036854775808		; 8000000000000000H
	sete	r14b
	test	r14b, r14b
	je	SHORT $LN17@decodeNumb

; 574  :     ++current;

	inc	r9

; 575  :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 576  :   Value::LargestUInt maxIntegerValue =
; 577  :       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
; 578  :                  : Value::maxLargestUInt;

	mov	rbx, r13
	jmp	SHORT $LN18@decodeNumb
$LN17@decodeNumb:
	or	rbx, -1
$LN18@decodeNumb:
	mov	rdi, QWORD PTR [rsi+16]

; 579  :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 580  :   Value::LargestUInt value = 0;

	xor	r12d, r12d
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	mov	r8d, r12d
	mul	rbx
	mov	r10, rdx
	shr	r10, 3

; 581  :   while (current < token.end_) {

	cmp	r9, rdi
	jae	SHORT $LN12@decodeNumb
$LL13@decodeNumb:

; 582  :     Char c = *current++;

	movzx	eax, BYTE PTR [r9]
	inc	r9

; 583  :     if (c < '0' || c > '9')

	cmp	al, 48					; 00000030H
	jl	SHORT $LN10@decodeNumb
	cmp	al, 57					; 00000039H
	jg	SHORT $LN10@decodeNumb

; 585  :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));

	movsx	edx, al
	sub	edx, 48					; 00000030H

; 586  :     if (value >= threshold) {

	cmp	r8, r10
	jb	SHORT $LN8@decodeNumb

; 587  :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 588  :       // a) we've only just touched the limit, b) this is the last digit, and
; 589  :       // c) it's small enough to fit in that rounding delta, we're okay.
; 590  :       // Otherwise treat this number as a double to avoid overflow.
; 591  :       if (value > threshold || current != token.end_ ||
; 592  :           digit > maxIntegerValue % 10) {

	ja	SHORT $LN10@decodeNumb
	cmp	r9, rdi
	jne	SHORT $LN10@decodeNumb
	lea	rax, QWORD PTR [r10+r10*4]
	mov	rcx, rbx
	add	rax, rax
	sub	rcx, rax
	mov	eax, edx
	cmp	rax, rcx
	ja	SHORT $LN10@decodeNumb
$LN8@decodeNumb:

; 593  :         return decodeDouble(token, decoded);
; 594  :       }
; 595  :     }
; 596  :     value = value * 10 + digit;

	lea	rcx, QWORD PTR [r8+r8*4]
	mov	eax, edx
	lea	r8, QWORD PTR [rdx+rcx*2]
	cmp	r9, rdi
	jb	SHORT $LL13@decodeNumb
$LN12@decodeNumb:
	xorps	xmm0, xmm0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1022 :   type_ = vtype;

	mov	BYTE PTR $T2[rbp-72], 1

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR $T2[rbp-48], r12
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 599  :     decoded = Value::minLargestInt;

	lea	rdx, QWORD PTR $T2[rbp-80]
	mov	rcx, r11
	movdqu	XMMWORD PTR $T2[rbp-64], xmm0
	test	r14b, r14b
	je	SHORT $LN4@decodeNumb
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	and	DWORD PTR $T2[rbp-72], -257		; fffffeffH
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 598  :   if (isNegative && value == maxIntegerValue)

	cmp	r8, rbx
	jne	SHORT $LN6@decodeNumb
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 386  :   value_.int_ = value;

	mov	QWORD PTR $T2[rbp-80], r13
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 599  :     decoded = Value::minLargestInt;

	jmp	SHORT $LN45@decodeNumb
$LN10@decodeNumb:

; 584  :       return decodeDouble(token, decoded);

	mov	r8, r11
	mov	rdx, rsi
	mov	rcx, r15
	call	?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ; Json::Reader::decodeDouble
	jmp	SHORT $LN15@decodeNumb
$LN6@decodeNumb:

; 600  :   else if (isNegative)
; 601  :     decoded = -Value::LargestInt(value);

	neg	r8
	jmp	SHORT $LN46@decodeNumb
$LN4@decodeNumb:

; 602  :   else if (value <= Value::LargestUInt(Value::maxInt))

	cmp	r8, 2147483647				; 7fffffffH
	jbe	SHORT $LN47@decodeNumb
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1022 :   type_ = vtype;

	mov	BYTE PTR $T1[rbp-72], 2
$LN47@decodeNumb:

; 1023 :   allocated_ = allocated;

	and	DWORD PTR $T1[rbp-72], -257		; fffffeffH
$LN46@decodeNumb:

; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;

	mov	QWORD PTR $T1[rbp-80], r8
$LN45@decodeNumb:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 605  :     decoded = value;

	call	??4Value@Json@@QEAAAEAV01@V01@@Z	; Json::Value::operator=

; 606  :   return true;

	mov	al, 1
$LN15@decodeNumb:

; 607  : }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?decodeNumber@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ENDP ; Json::Reader::decodeNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
_TEXT	SEGMENT
$T1 = 32
value$ = 40
$T2 = 48
this$ = 56
is$ = 64
$T3 = 304
$T4 = 304
buffer$ = 344
$T5 = 376
$T6 = 408
__$ArrayPad$ = 440
this$ = 496
token$ = 504
decoded$ = 512
?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z PROC ; Json::Reader::decodeDouble, COMDAT

; 619  : bool Reader::decodeDouble(Token& token, Value& decoded) {

$LN303:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rsp-192]
	sub	rsp, 448				; 000001c0H
	mov	QWORD PTR $T2[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rdi, r8
	mov	rbx, rdx
	mov	rsi, rcx
	xor	r14d, r14d
	mov	DWORD PTR $T1[rsp], r14d
	xorps	xmm0, xmm0

; 620  :   double value = 0;

	movsdx	QWORD PTR value$[rsp], xmm0

; 621  :   JSONCPP_STRING buffer(token.start_, token.end_);

	mov	r8, QWORD PTR [rdx+16]
	mov	rdx, QWORD PTR [rdx+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR buffer$[rbp-232], 15

; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR buffer$[rbp-240], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR buffer$[rbp-256], r14b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 862  : 		if (_First != _Last)

	cmp	rdx, r8
	je	SHORT $LN11@decodeDoub

; 863  : 			assign(&*_First, _Last - _First);

	sub	r8, rdx
	lea	rcx, QWORD PTR buffer$[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
$LN11@decodeDoub:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 406  : 		{	// construct readable character buffer from NTCS

	lea	rax, OFFSET FLAT:??_8?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	mov	QWORD PTR is$[rsp], rax
	lea	rcx, QWORD PTR is$[rbp-112]
	call	QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	mov	DWORD PTR $T1[rsp], 1
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, QWORD PTR is$[rsp+16]
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	npad	1
	mov	rax, QWORD PTR is$[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR is$[rsp+rcx], rax
	mov	rax, QWORD PTR is$[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-144]
	mov	DWORD PTR is$[rsp+rcx-4], edx
	lea	rax, QWORD PTR is$[rsp+16]
	mov	QWORD PTR this$[rsp], rax

; 34   : 	explicit basic_stringbuf(const _Mystr& _Str,

	lea	rcx, QWORD PTR is$[rsp+16]
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR is$[rsp+16], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rdx, QWORD PTR buffer$[rbp-256]
	cmp	QWORD PTR buffer$[rbp-232], 16
	cmovae	rdx, QWORD PTR buffer$[rbp-256]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 311  : 		_Seekhigh = 0;

	mov	QWORD PTR is$[rbp-136], r14

; 312  : 		_Mystate = _State;

	mov	DWORD PTR is$[rbp-128], 2

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))

	mov	r8, QWORD PTR buffer$[rbp-240]
	test	r8, r8
	je	SHORT $LN81@decodeDoub
	lea	rcx, QWORD PTR is$[rsp+16]
	call	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
	npad	1
$LN81@decodeDoub:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 623  :   if (!(is >> value))

	lea	rdx, QWORD PTR value$[rsp]
	lea	rcx, QWORD PTR is$[rsp]
	call	QWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@AEAN@Z
	mov	rcx, QWORD PTR [rax]
	movsxd	rdx, DWORD PTR [rcx+4]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 341  : 			& ((int)badbit | (int)failbit)) != 0);

	test	BYTE PTR [rdx+rax+16], 6
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 623  :   if (!(is >> value))

	je	$LN1@decodeDoub

; 626  :                     token);

	mov	r8, QWORD PTR [rbx+16]
	mov	rdx, QWORD PTR [rbx+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-232], 15

; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-240], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 862  : 		if (_First != _Last)

	cmp	rdx, r8
	je	SHORT $LN95@decodeDoub

; 863  : 			assign(&*_First, _Last - _First);

	sub	r8, rdx
	lea	rcx, QWORD PTR $T5[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
$LN95@decodeDoub:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 626  :                     token);

	lea	r8, QWORD PTR $T5[rbp-256]
	lea	rdx, OFFSET FLAT:??_C@_01GEODFPGF@?8?$AA@
	lea	rcx, QWORD PTR $T4[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	mov	rdx, rax
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@PEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	xor	r9d, r9d
	mov	r8, rbx
	mov	rdx, rax
	mov	rcx, rsi
	call	?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::Reader::addError
	movzx	ebx, al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T6[rbp-232], 16
	jb	SHORT $LN154@decodeDoub
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T6[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN154@decodeDoub:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T6[rbp-232], 15

; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T6[rbp-240], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T6[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-232], 16
	jb	SHORT $LN186@decodeDoub
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN186@decodeDoub:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-232], 15

; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-240], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T5[rbp-232], 16
	jb	SHORT $LN10@decodeDoub
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T5[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	jmp	SHORT $LN10@decodeDoub
$LN1@decodeDoub:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1022 :   type_ = vtype;

	mov	BYTE PTR $T3[rbp-248], 3

; 1023 :   allocated_ = allocated;

	and	DWORD PTR $T3[rbp-248], -257		; fffffeffH
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR $T3[rbp-240], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR $T3[rbp-224], r14

; 396  :   value_.real_ = value;

	movsdx	xmm0, QWORD PTR value$[rsp]
	movsdx	QWORD PTR $T3[rbp-256], xmm0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 627  :   decoded = value;

	lea	rdx, QWORD PTR $T3[rbp-256]
	mov	rcx, rdi
	call	??4Value@Json@@QEAAAEAV01@V01@@Z	; Json::Value::operator=

; 628  :   return true;

	mov	bl, 1
$LN10@decodeDoub:
	lea	rcx, QWORD PTR is$[rbp-112]
	call	??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_istringstream<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, QWORD PTR is$[rbp-112]
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR buffer$[rbp-232], 16
	jb	SHORT $LN302@decodeDoub
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR buffer$[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN302@decodeDoub:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 628  :   return true;

	movzx	eax, bl

; 629  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 448				; 000001c0H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ENDP ; Json::Reader::decodeDouble
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
value$ = 40
$T2 = 48
this$ = 56
is$ = 64
$T3 = 304
$T4 = 304
buffer$ = 344
$T5 = 376
$T6 = 408
__$ArrayPad$ = 440
this$ = 496
token$ = 504
decoded$ = 512
?dtor$0@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::Reader::decodeDouble'::`1'::dtor$0
	lea	rcx, QWORD PTR buffer$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::Reader::decodeDouble'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
value$ = 40
$T2 = 48
this$ = 56
is$ = 64
$T3 = 304
$T4 = 304
buffer$ = 344
$T5 = 376
$T6 = 408
__$ArrayPad$ = 440
this$ = 496
token$ = 504
decoded$ = 512
?dtor$6@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::Reader::decodeDouble'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN54@dtor$6
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR is$[rbp]
	add	rcx, 144				; 00000090H
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN54@dtor$6:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::Reader::decodeDouble'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
value$ = 40
$T2 = 48
this$ = 56
is$ = 64
$T3 = 304
$T4 = 304
buffer$ = 344
$T5 = 376
$T6 = 408
__$ArrayPad$ = 440
this$ = 496
token$ = 504
decoded$ = 512
?dtor$7@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::Reader::decodeDouble'::`1'::dtor$7
	lea	rcx, QWORD PTR is$[rdx]
	add	rcx, 24
	rex_jmp	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$7@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::Reader::decodeDouble'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
value$ = 40
$T2 = 48
this$ = 56
is$ = 64
$T3 = 304
$T4 = 304
buffer$ = 344
$T5 = 376
$T6 = 408
__$ArrayPad$ = 440
this$ = 496
token$ = 504
decoded$ = 512
?dtor$9@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::Reader::decodeDouble'::`1'::dtor$9
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$9@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::Reader::decodeDouble'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
value$ = 40
$T2 = 48
this$ = 56
is$ = 64
$T3 = 304
$T4 = 304
buffer$ = 344
$T5 = 376
$T6 = 408
__$ArrayPad$ = 440
this$ = 496
token$ = 504
decoded$ = 512
?dtor$1@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::Reader::decodeDouble'::`1'::dtor$1
	lea	rcx, QWORD PTR is$[rdx]
	jmp	??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$1@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::Reader::decodeDouble'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
value$ = 40
$T2 = 48
this$ = 56
is$ = 64
$T3 = 304
$T4 = 304
buffer$ = 344
$T5 = 376
$T6 = 408
__$ArrayPad$ = 440
this$ = 496
token$ = 504
decoded$ = 512
?dtor$2@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::Reader::decodeDouble'::`1'::dtor$2
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::Reader::decodeDouble'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
value$ = 40
$T2 = 48
this$ = 56
is$ = 64
$T3 = 304
$T4 = 304
buffer$ = 344
$T5 = 376
$T6 = 408
__$ArrayPad$ = 440
this$ = 496
token$ = 504
decoded$ = 512
?dtor$3@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::Reader::decodeDouble'::`1'::dtor$3
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::Reader::decodeDouble'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
value$ = 40
$T2 = 48
this$ = 56
is$ = 64
$T3 = 304
$T4 = 304
buffer$ = 344
$T5 = 376
$T6 = 408
__$ArrayPad$ = 440
this$ = 496
token$ = 504
decoded$ = 512
?dtor$4@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::Reader::decodeDouble'::`1'::dtor$4
	lea	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??decodeDouble@Reader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::Reader::decodeDouble'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 80
decoded$ = 88
decoded_string$ = 136
__$ArrayPad$ = 168
this$ = 224
token$ = 232
?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z PROC	; Json::Reader::decodeString, COMDAT

; 631  : bool Reader::decodeString(Token& token) {

$LN278:
	mov	r11, rsp
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 176				; 000000b0H
	mov	QWORD PTR [r11-88], -2
	mov	QWORD PTR [r11+24], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, rdx
	mov	rbp, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [r11-56], 15

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	edi, edi
	mov	QWORD PTR [r11-64], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [r11-80], dil
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 633  :   if (!decodeString(token, decoded_string))

	lea	r8, QWORD PTR [r11-80]
	call	?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
	test	al, al
	je	$LN168@decodeStri
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1022 :   type_ = vtype;

	mov	esi, DWORD PTR decoded$[rsp+8]
	and	esi, -252				; ffffff04H

; 1023 :   allocated_ = allocated;

	or	esi, 260				; 00000104H
	mov	DWORD PTR decoded$[rsp+8], esi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rcx, QWORD PTR decoded_string$[rsp]
	cmp	QWORD PTR decoded_string$[rsp+24], 16
	cmovae	rcx, QWORD PTR decoded_string$[rsp]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));

	mov	edx, DWORD PTR decoded_string$[rsp+16]
	call	?duplicateAndPrefixStringValue@Json@@YAPEADPEBDI@Z ; Json::duplicateAndPrefixStringValue
	mov	r15, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rbp
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T6[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	mov	r8, rdi
	je	SHORT $LN106@decodeStri
	mov	r8, QWORD PTR [rcx]
$LN106@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	r8, QWORD PTR [rcx+rdx*8]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	ecx, BYTE PTR [r8+8]

; 518  :   type_ = other.type_;

	movzx	eax, BYTE PTR decoded$[rsp+8]
	mov	BYTE PTR [r8+8], al

; 519  :   other.type_ = temp;

	mov	eax, esi
	xor	eax, ecx
	movzx	eax, al
	xor	esi, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rbx, QWORD PTR [r8]

; 53   : 	_Left = _Move(_Right);

	mov	QWORD PTR [r8], r15
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [r8+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, ecx
	xor	eax, esi
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, esi
	and	edx, 256				; 00000100H
	xor	esi, edx
	mov	DWORD PTR decoded$[rsp+8], esi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, rbp
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T2[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN131@decodeStri
	mov	r8, rdi
	jmp	SHORT $LN132@decodeStri
$LN131@decodeStri:
	mov	r8, QWORD PTR [r8]
$LN132@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 634  :     return false;
; 635  :   Value decoded(decoded_string);
; 636  :   currentValue().swapPayload(decoded);
; 637  :   currentValue().setOffsetStart(token.start_ - begin_);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [rbp+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rdx+24], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rbp
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T1[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN150@decodeStri
	mov	rdi, QWORD PTR [rcx]
$LN150@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [rdi+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 638  :   currentValue().setOffsetLimit(token.end_ - begin_);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, QWORD PTR [rbp+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1422 : void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

	mov	QWORD PTR [rdx+32], rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 639  :   return true;

	mov	dil, 1
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 487  :   switch (type_) {

	movsx	eax, BYTE PTR decoded$[rsp+8]
	cmp	eax, 4
	je	SHORT $LN158@decodeStri
	add	eax, -6					; fffffffaH
	cmp	eax, 1
	ja	SHORT $LN168@decodeStri

; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;

	test	rbx, rbx
	je	SHORT $LN168@decodeStri
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

	mov	r8, QWORD PTR [rbx]

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();
; 774  : 		}
; 775  : 
; 776  : 	~_Tree_alloc() _NOEXCEPT
; 777  : 		{	// destroy head node
; 778  : 		_Freeheadnode(this->_Myhead);
; 779  : 		}
; 780  : 
; 781  : 	void _Change_alloc(const _Alty&)
; 782  : 		{	// replace old allocator
; 783  : 		}
; 784  : 
; 785  : 	void _Swap_alloc(_Myt&)
; 786  : 		{	// swap allocators
; 787  : 		}
; 788  : 
; 789  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 790  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 791  : 		{	// construct allocators from _Al
; 792  : 		this->_Myhead = _Buyheadnode();
; 793  : 		_TRY_BEGIN
; 794  : 		_Alloc_proxy();
; 795  : 		_CATCH_ALL
; 796  : 		_Freeheadnode(this->_Myhead);
; 797  : 		_RERAISE;
; 798  : 		_CATCH_END
; 799  : 		}
; 800  : 
; 801  : 	~_Tree_alloc() _NOEXCEPT
; 802  : 		{	// destroy proxy
; 803  : 		_Freeheadnode(this->_Myhead);
; 804  : 		_Free_proxy();
; 805  : 		}
; 806  : 
; 807  : 	void _Change_alloc(const _Alty&)
; 808  : 		{	// replace old allocator
; 809  : 		}
; 810  : 
; 811  : 	void _Swap_alloc(_Myt&)
; 812  : 		{	// swap allocators
; 813  : 		}
; 814  : 
; 815  : 	void _Alloc_proxy()
; 816  : 		{	// construct proxy from _Alnod
; 817  : 		typename _Alty::template rebind<_Container_proxy>::other
; 818  : 			_Alproxy(_Getal());
; 819  : 		this->_Myproxy = _Alproxy.allocate(1);
; 820  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 821  : 		this->_Myproxy->_Mycont = this;
; 822  : 		}
; 823  : 
; 824  : 	void _Free_proxy()
; 825  : 		{	// destroy proxy
; 826  : 		typename _Alty::template rebind<_Container_proxy>::other
; 827  : 			_Alproxy(_Getal());
; 828  : 		this->_Orphan_all();
; 829  : 		_Alproxy.destroy(this->_Myproxy);
; 830  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 831  : 		this->_Myproxy = 0;
; 832  : 		}
; 833  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 834  : 
; 835  : 	_Nodeptr _Buyheadnode()
; 836  : 		{	// get head node using current allocator
; 837  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 838  : 
; 839  : 		_TRY_BEGIN
; 840  : 		this->_Getal().construct(
; 841  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 842  : 		this->_Getal().construct(
; 843  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 844  : 		this->_Getal().construct(
; 845  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 846  : 		_CATCH_ALL
; 847  : 		this->_Getal().deallocate(_Pnode, 1);
; 848  : 		_RERAISE;
; 849  : 		_CATCH_END
; 850  : 
; 851  : 		this->_Color(_Pnode) = this->_Black;
; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}
; 855  : 
; 856  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 857  : 		{	// free head node using current allocator
; 858  : 		this->_Getal().destroy(
; 859  : 			_STD addressof(this->_Left(_Pnode)));
; 860  : 		this->_Getal().destroy(
; 861  : 			_STD addressof(this->_Parent(_Pnode)));
; 862  : 		this->_Getal().destroy(
; 863  : 			_STD addressof(this->_Right(_Pnode)));
; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());
; 870  : 		}
; 871  : 	};
; 872  : 
; 873  : 		// TEMPLATE CLASS _Tree_buy
; 874  : template<class _Ty,
; 875  : 	class _Alloc>
; 876  : 	class _Tree_buy
; 877  : 		: public _Tree_alloc<!is_empty<_Alloc>::value,
; 878  : 			_Tree_base_types<_Ty, _Alloc> >
; 879  : 	{	// base class for tree to hold buynode/freenode functions
; 880  : public:
; 881  : 	typedef _Tree_alloc<!is_empty<_Alloc>::value,
; 882  : 		_Tree_base_types<_Ty, _Alloc> > _Mybase;
; 883  : 	typedef typename _Mybase::_Alty _Alty;
; 884  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 885  : 	typedef typename _Mybase::value_type value_type;
; 886  : 
; 887  : 	_Tree_buy(const _Alloc& _Al = _Alloc())
; 888  : 		: _Mybase(_Al)
; 889  : 		{	// construct from allocator
; 890  : 		}
; 891  : 
; 892  : 	_Nodeptr _Buynode0()
; 893  : 		{	// allocate a non-value node
; 894  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 895  : 
; 896  : 		_TRY_BEGIN
; 897  : 		this->_Getal().construct(
; 898  : 			_STD addressof(this->_Left(_Pnode)), this->_Myhead);
; 899  : 		this->_Getal().construct(
; 900  : 			_STD addressof(this->_Parent(_Pnode)), this->_Myhead);
; 901  : 		this->_Getal().construct(
; 902  : 			_STD addressof(this->_Right(_Pnode)), this->_Myhead);
; 903  : 		_CATCH_ALL
; 904  : 		this->_Getal().deallocate(_Pnode, 1);
; 905  : 		_RERAISE;
; 906  : 		_CATCH_END
; 907  : 
; 908  : 		return (_Pnode);
; 909  : 		}
; 910  : 
; 911  : 	void _Freenode0(_Nodeptr _Pnode)
; 912  : 		{	// free non-value node using current allocator
; 913  : 		this->_Getal().destroy(
; 914  : 			_STD addressof(this->_Left(_Pnode)));
; 915  : 		this->_Getal().destroy(
; 916  : 			_STD addressof(this->_Parent(_Pnode)));
; 917  : 		this->_Getal().destroy(
; 918  : 			_STD addressof(this->_Right(_Pnode)));
; 919  : 		this->_Getal().deallocate(_Pnode, 1);
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)
; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();
; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;
; 928  : 		this->_Isnil(_Pnode) = false;
; 929  : 
; 930  : 		_TRY_BEGIN
; 931  : 		this->_Getal().construct(
; 932  : 			_STD addressof(this->_Myval(_Pnode)),
; 933  : 				_STD forward<_Valty>(_Val)...);
; 934  : 		_CATCH_ALL
; 935  : 		_Freenode0(_Pnode);
; 936  : 		_RERAISE;
; 937  : 		_CATCH_END
; 938  : 
; 939  : 		return (_Pnode);
; 940  : 		}
; 941  : 
; 942  : 	};
; 943  : 
; 944  : 		// TEMPLATE CLASS _Tree_comp
; 945  : template<bool _Pr_has_storage,
; 946  : 	class _Traits>
; 947  : 	class _Tree_comp
; 948  : 		: public _Tree_buy<typename _Traits::value_type,
; 949  : 			typename _Traits::allocator_type>
; 950  : 	{	// base class for _Tree to hold ordering predicate with storage
; 951  : public:
; 952  : 	typedef _Tree_comp<_Pr_has_storage, _Traits> _Myt;
; 953  : 	typedef _Tree_buy<typename _Traits::value_type,
; 954  : 		typename _Traits::allocator_type> _Mybase;
; 955  : 
; 956  : 	typedef typename _Traits::allocator_type allocator_type;
; 957  : 	typedef typename _Traits::key_compare key_compare;
; 958  : 
; 959  : 	_Tree_comp(const key_compare& _Parg, const allocator_type& _Al)
; 960  : 		: _Mybase(_Al), comp(_Parg)
; 961  : 		{	// construct ordering predicate
; 962  : 		}
; 963  : 
; 964  : 	key_compare& _Getcomp()
; 965  : 		{	// get reference to ordering predicate
; 966  : 		return (comp);
; 967  : 		}
; 968  : 
; 969  : 	const key_compare& _Getcomp() const
; 970  : 		{	// get reference to ordering predicate
; 971  : 		return (comp);
; 972  : 		}
; 973  : 
; 974  : 	void _Setcomp(const key_compare& _Right)
; 975  : 		{	// copy ordering predicate
; 976  : 		comp = _Right;
; 977  : 		}
; 978  : 
; 979  : 	void _Swapcomp(key_compare& _Right)
; 980  : 		{	// swap ordering predicate
; 981  : 		_Swap_adl(comp, _Right);
; 982  : 		}
; 983  : 
; 984  : 	key_compare comp;
; 985  : 	};
; 986  : 
; 987  : template<class _Traits>
; 988  : 	class _Tree_comp<false, _Traits>
; 989  : 		: public _Tree_buy<typename _Traits::value_type,
; 990  : 			typename _Traits::allocator_type>
; 991  : 	{	// base class for _Tree to hold ordering predicate with no storage
; 992  : public:
; 993  : 	typedef _Tree_comp<false, _Traits> _Myt;
; 994  : 	typedef _Tree_buy<typename _Traits::value_type,
; 995  : 		typename _Traits::allocator_type> _Mybase;
; 996  : 
; 997  : 	typedef typename _Traits::allocator_type allocator_type;
; 998  : 	typedef typename _Traits::key_compare key_compare;
; 999  : 
; 1000 : 	_Tree_comp(const key_compare&, const allocator_type& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct ordering predicate
; 1003 : 		}
; 1004 : 
; 1005 : 	key_compare _Getcomp() const
; 1006 : 		{	// get ordering predicate
; 1007 : 		return (key_compare());
; 1008 : 		}
; 1009 : 
; 1010 : 	void _Setcomp(const key_compare&)
; 1011 : 		{	// copy ordering predicate
; 1012 : 		}
; 1013 : 
; 1014 : 	void _Swapcomp(const key_compare&)
; 1015 : 		{	// swap ordering predicate
; 1016 : 		}
; 1017 : 	};
; 1018 : 
; 1019 : 		// TEMPLATE CLASS _Tree
; 1020 : template<class _Traits>
; 1021 : 	class _Tree
; 1022 : 		: public _Tree_comp<
; 1023 : 			!is_empty<typename _Traits::key_compare>::value, _Traits>
; 1024 : 	{	// ordered red-black tree for [multi_]{map set}
; 1025 : public:
; 1026 : 	typedef _Tree<_Traits> _Myt;
; 1027 : 	typedef _Tree_comp<
; 1028 : 		!is_empty<typename _Traits::key_compare>::value, _Traits> _Mybase;
; 1029 : 
; 1030 : 	typedef typename _Traits::key_type key_type;
; 1031 : 	typedef typename _Traits::value_compare value_compare;
; 1032 : 	enum
; 1033 : 		{	// get multi parameter
; 1034 : 		_Multi = _Traits::_Multi};
; 1035 : 
; 1036 : 	typedef typename _Mybase::_Node _Node;
; 1037 : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 1038 : 	typedef typename _Mybase::_Alty _Alty;
; 1039 : 
; 1040 : 	typedef typename _Mybase::key_compare key_compare;
; 1041 : 	typedef typename _Mybase::allocator_type allocator_type;
; 1042 : 
; 1043 : 	typedef typename _Mybase::value_type value_type;
; 1044 : 	typedef typename _Mybase::size_type size_type;
; 1045 : 	typedef typename _Mybase::difference_type difference_type;
; 1046 : 	typedef typename _Mybase::pointer pointer;
; 1047 : 	typedef typename _Mybase::const_pointer const_pointer;
; 1048 : 	typedef typename _Mybase::reference reference;
; 1049 : 	typedef typename _Mybase::const_reference const_reference;
; 1050 : 
; 1051 : 	typedef typename _Mybase::const_iterator const_iterator;
; 1052 : 	typedef typename _If<is_same<key_type, value_type>::value,
; 1053 : 		typename _Mybase::const_iterator,
; 1054 : 		typename _Mybase::iterator>::type iterator;
; 1055 : 
; 1056 : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 1057 : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 1058 : 
; 1059 : 	typedef pair<iterator, bool> _Pairib;
; 1060 : 	typedef pair<iterator, iterator> _Pairii;
; 1061 : 	typedef pair<const_iterator, const_iterator> _Paircc;
; 1062 : 
; 1063 : 	_Tree(const key_compare& _Parg,
; 1064 : 		const allocator_type& _Al)
; 1065 : 		: _Mybase(_Parg, _Al)
; 1066 : 		{	// construct empty tree
; 1067 : 		}
; 1068 : 
; 1069 : 	_Tree(const value_type *_First, const value_type *_Last,
; 1070 : 		const key_compare& _Parg, const allocator_type& _Al)
; 1071 : 		: _Mybase(_Parg, _Al)
; 1072 : 		{	// construct tree from [_First, _Last) array
; 1073 : 		_TRY_BEGIN
; 1074 : 		insert(_First, _Last);
; 1075 : 		_CATCH_ALL
; 1076 : 		_Tidy();
; 1077 : 		_RERAISE;
; 1078 : 		_CATCH_END
; 1079 : 		}
; 1080 : 
; 1081 : 	_Tree(const _Myt& _Right, const allocator_type& _Al)
; 1082 : 		: _Mybase(_Right.key_comp(), _Al)
; 1083 : 		{	// construct tree by copying _Right, allocator
; 1084 : 		_TRY_BEGIN
; 1085 : 		_Copy(_Right, false_type());
; 1086 : 		_CATCH_ALL
; 1087 : 		_Tidy();
; 1088 : 		_RERAISE;
; 1089 : 		_CATCH_END
; 1090 : 		}
; 1091 : 
; 1092 : 	_Tree(_Myt&& _Right)
; 1093 : 		: _Mybase(_Right.key_comp(), _Right._Getal())
; 1094 : 		{	// construct tree by moving _Right
; 1095 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1096 : 		}
; 1097 : 
; 1098 : 	_Tree(_Myt&& _Right, const allocator_type& _Al)
; 1099 : 		: _Mybase(_Right.key_comp(), _Al)
; 1100 : 		{	// construct tree by moving _Right, allocator
; 1101 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1102 : 		}
; 1103 : 
; 1104 : 	_Myt& operator=(_Myt&& _Right)
; 1105 : 		{	// assign by moving _Right
; 1106 : 		if (this != &_Right)
; 1107 : 			{	// different, move it
; 1108 : 			clear();
; 1109 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1110 : 				&& this->_Getal() != _Right._Getal())
; 1111 : 				this->_Change_alloc(_Right._Getal());
; 1112 : 
; 1113 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1114 : 			}
; 1115 : 		return (*this);
; 1116 : 		}
; 1117 : 
; 1118 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1119 : 		{	// move from _Right, stealing its contents
; 1120 : 		this->_Swap_all(_Right);
; 1121 : 		this->_Swapcomp(_Right._Getcomp());
; 1122 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1123 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1124 : 		}
; 1125 : 
; 1126 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1127 : 		{	// move from _Right, possibly moving its contents
; 1128 : 		if (get_allocator() == _Right.get_allocator())
; 1129 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1130 : 		else
; 1131 : 			_Copy(_Right, true_type());
; 1132 : 		}
; 1133 : 
; 1134 : 	void _Assign_rv(_Myt&& _Right)
; 1135 : 		{	// assign by moving _Right
; 1136 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1137 : 			typename _Alty::propagate_on_container_move_assignment());
; 1138 : 		}
; 1139 : 
; 1140 : 
; 1141 : 	_Pairib insert(value_type&& _Val)
; 1142 : 		{	// try to insert node with value _Val, favoring right side
; 1143 : 		return (_Insert_nohint(false,
; 1144 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1145 : 		}
; 1146 : 
; 1147 : 	iterator insert(const_iterator _Where, value_type&& _Val)
; 1148 : 		{	// try to insert node with value _Val using _Where as a hint
; 1149 : 		return (_Insert_hint(_Where,
; 1150 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1151 : 		}
; 1152 : 
; 1153 : 	template<class _Valty>
; 1154 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1155 : 			_Pairib>::type
; 1156 : 		insert(_Valty&& _Val)
; 1157 : 		{	// try to insert node with value _Val, favoring right side
; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));
; 1161 : 		}
; 1162 : 
; 1163 : 	template<class _Valty>
; 1164 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1165 : 			iterator>::type
; 1166 : 		insert(const_iterator _Where, _Valty&& _Val)
; 1167 : 		{	// try to insert node with value _Val using _Where as a hint
; 1168 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1169 : 		return (_Insert_hint(_Where,
; 1170 : 			this->_Myval(_Newnode), _Newnode));
; 1171 : 		}
; 1172 : 
; 1173 : 	template<class... _Valty>
; 1174 : 		_Pairib emplace(_Valty&&... _Val)
; 1175 : 		{	// try to insert value_type(_Val...), favoring right side
; 1176 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1177 : 		return (_Insert_nohint(false,
; 1178 : 			this->_Myval(_Newnode), _Newnode));
; 1179 : 		}
; 1180 : 
; 1181 : 	template<class... _Valty>
; 1182 : 		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
; 1183 : 		{	// insert value_type(_Val...) at _Where
; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));
; 1187 : 		}
; 1188 : 
; 1189 : 
; 1190 : 	~_Tree() _NOEXCEPT
; 1191 : 		{	// destroy tree
; 1192 : 		_Tidy();
; 1193 : 		}
; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

	mov	r9, r8
	mov	r8, QWORD PTR [r8]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, rbx
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	mov	rcx, rbx
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 501  :     break;

	jmp	SHORT $LN168@decodeStri
$LN158@decodeStri:

; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)

	bt	esi, 8
	jae	SHORT $LN168@decodeStri

; 170  :   free(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
	npad	1
$LN168@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR decoded_string$[rsp+24], 16
	jb	SHORT $LN277@decodeStri
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR decoded_string$[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN277@decodeStri:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 639  :   return true;

	movzx	eax, dil

; 640  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+240]
	add	rsp, 176				; 000000b0H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z ENDP	; Json::Reader::decodeString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 80
decoded$ = 88
decoded_string$ = 136
__$ArrayPad$ = 168
this$ = 224
token$ = 232
?dtor$0@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::Reader::decodeString'::`1'::dtor$0
	lea	rcx, QWORD PTR decoded_string$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::Reader::decodeString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
unicode$1 = 48
current$ = 56
$T2 = 64
$T3 = 72
$T4 = 72
$T5 = 104
__$ArrayPad$ = 136
this$ = 208
token$ = 216
decoded$ = 224
?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Reader::decodeString, COMDAT

; 642  : bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {

$LN257:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 144				; 00000090H
	mov	QWORD PTR $T2[rbp-105], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax
	mov	rdi, r8
	mov	r14, rdx
	mov	r15, rcx

; 643  :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));

	mov	rdx, QWORD PTR [rdx+16]
	sub	rdx, QWORD PTR [r14+8]
	sub	rdx, 2
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)

	mov	rbx, QWORD PTR [r8+16]
	cmp	rbx, rdx
	ja	SHORT $LN38@decodeStri
	cmp	QWORD PTR [r8+24], rdx
	je	SHORT $LN38@decodeStri

; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))

	mov	r8b, 1
	mov	rcx, rdi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN38@decodeStri

; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], rbx

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN34@decodeStri
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rdi]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN35@decodeStri
$LN34@decodeStri:
	mov	rax, rdi
$LN35@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax+rbx], 0
$LN38@decodeStri:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 644  :   Location current = token.start_ + 1; // skip '"'

	mov	rbx, QWORD PTR [r14+8]
	inc	rbx

; 645  :   Location end = token.end_ - 1;       // do not include '"'

	mov	rsi, QWORD PTR [r14+16]
	dec	rsi

; 646  :   while (current != end) {

	cmp	rbx, rsi
	je	$LN252@decodeStri
	lea	r12, OFFSET FLAT:__ImageBase
$LL20@decodeStri:

; 647  :     Char c = *current++;

	movzx	r8d, BYTE PTR [rbx]
	inc	rbx

; 648  :     if (c == '"')

	cmp	r8b, 34					; 00000022H
	je	$LN252@decodeStri

; 649  :       break;
; 650  :     else if (c == '\\') {

	cmp	r8b, 92					; 0000005cH
	jne	$LN16@decodeStri

; 651  :       if (current == end)

	cmp	rbx, rsi
	je	$LN248@decodeStri

; 653  :       Char escape = *current++;

	movsx	eax, BYTE PTR [rbx]
	inc	rbx
	mov	QWORD PTR current$[rbp-105], rbx

; 654  :       switch (escape) {

	add	eax, -34				; ffffffffffffffdeH
	cmp	eax, 83					; 00000053H
	ja	$LN2@decodeStri
	cdqe
	movzx	eax, BYTE PTR $LN253@decodeStri[r12+rax]
	mov	ecx, DWORD PTR $LN254@decodeStri[r12+rax*4]
	add	rcx, r12
	jmp	rcx
$LN12@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 34					; 00000022H
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 657  :         break;

	jmp	$LN16@decodeStri
$LN11@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 47					; 0000002fH
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 660  :         break;

	jmp	SHORT $LN16@decodeStri
$LN10@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 92					; 0000005cH
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 663  :         break;

	jmp	SHORT $LN16@decodeStri
$LN9@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 8
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 666  :         break;

	jmp	SHORT $LN16@decodeStri
$LN8@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 12
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 669  :         break;

	jmp	SHORT $LN16@decodeStri
$LN7@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 10
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 672  :         break;

	jmp	SHORT $LN16@decodeStri
$LN6@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 13
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 675  :         break;

	jmp	SHORT $LN16@decodeStri
$LN5@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 9
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 678  :         break;

	jmp	SHORT $LN16@decodeStri
$LN4@decodeStri:

; 679  :       case 'u': {
; 680  :         unsigned int unicode;
; 681  :         if (!decodeUnicodeCodePoint(token, current, end, unicode))

	lea	rax, QWORD PTR unicode$1[rbp-105]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, rsi
	lea	r8, QWORD PTR current$[rbp-105]
	mov	rdx, r14
	mov	rcx, r15
	call	?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ; Json::Reader::decodeUnicodeCodePoint
	test	al, al
	je	SHORT $LN249@decodeStri

; 683  :         decoded += codePointToUTF8(unicode);

	mov	edx, DWORD PTR unicode$1[rbp-105]
	lea	rcx, QWORD PTR $T5[rbp-105]
	call	?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::codePointToUTF8
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T5[rbp-81], 16
	jb	SHORT $LN255@decodeStri
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T5[rbp-105]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN255@decodeStri:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 688  :     } else {

	mov	rbx, QWORD PTR current$[rbp-105]
	jmp	SHORT $LN244@decodeStri
$LN16@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	edx, 1
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN244@decodeStri:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 646  :   while (current != end) {

	cmp	rbx, rsi
	je	$LN252@decodeStri
	jmp	$LL20@decodeStri
$LN249@decodeStri:

; 682  :           return false;

	xor	al, al
	jmp	$LN21@decodeStri
$LN2@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rbp-81], 15

; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rbp-89], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rbp-105], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 29
	lea	rdx, OFFSET FLAT:??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
	lea	rcx, QWORD PTR $T3[rbp-105]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 686  :         return addError("Bad escape sequence in string", token, current);

	mov	r9, rbx
	mov	r8, r14
	lea	rdx, QWORD PTR $T3[rbp-105]
	mov	rcx, r15
	call	?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::Reader::addError
	movzx	ebx, al
	jmp	SHORT $LN256@decodeStri
$LN248@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-81], 15

; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-89], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rbp-105], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 31
	lea	rdx, OFFSET FLAT:??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
	lea	rcx, QWORD PTR $T4[rbp-105]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 652  :         return addError("Empty escape sequence in string", token, current);

	mov	r9, rbx
	mov	r8, r14
	lea	rdx, QWORD PTR $T4[rbp-105]
	mov	rcx, r15
	call	?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::Reader::addError
	movzx	ebx, al
$LN256@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-81], 16
	jb	SHORT $LN104@decodeStri
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rbp-105]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN104@decodeStri:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 652  :         return addError("Empty escape sequence in string", token, current);

	movzx	eax, bl
	jmp	SHORT $LN21@decodeStri
$LN252@decodeStri:

; 689  :       decoded += c;
; 690  :     }
; 691  :   }
; 692  :   return true;

	mov	al, 1
$LN21@decodeStri:

; 693  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
	npad	2
$LN254@decodeStri:
	DD	$LN12@decodeStri
	DD	$LN11@decodeStri
	DD	$LN10@decodeStri
	DD	$LN9@decodeStri
	DD	$LN8@decodeStri
	DD	$LN7@decodeStri
	DD	$LN6@decodeStri
	DD	$LN5@decodeStri
	DD	$LN4@decodeStri
	DD	$LN2@decodeStri
$LN253@decodeStri:
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	7
	DB	8
?decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Reader::decodeString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
unicode$1 = 48
current$ = 56
$T2 = 64
$T3 = 72
$T4 = 72
$T5 = 104
__$ArrayPad$ = 136
this$ = 208
token$ = 216
decoded$ = 224
?dtor$0@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Reader::decodeString'::`1'::dtor$0
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Reader::decodeString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
unicode$1 = 48
current$ = 56
$T2 = 64
$T3 = 72
$T4 = 72
$T5 = 104
__$ArrayPad$ = 136
this$ = 208
token$ = 216
decoded$ = 224
?dtor$1@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Reader::decodeString'::`1'::dtor$1
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Reader::decodeString'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
unicode$1 = 48
current$ = 56
$T2 = 64
$T3 = 72
$T4 = 72
$T5 = 104
__$ArrayPad$ = 136
this$ = 208
token$ = 216
decoded$ = 224
?dtor$2@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Reader::decodeString'::`1'::dtor$2
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??decodeString@Reader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Reader::decodeString'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
_TEXT	SEGMENT
surrogatePair$1 = 48
$T2 = 56
$T3 = 64
$T4 = 64
__$ArrayPad$ = 96
this$ = 160
token$ = 168
current$ = 176
end$ = 184
unicode$ = 192
?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z PROC ; Json::Reader::decodeUnicodeCodePoint, COMDAT

; 698  :                                     unsigned int& unicode) {

$LN166:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 112				; 00000070H
	mov	QWORD PTR $T2[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, r9
	mov	rbx, r8
	mov	rbp, rdx
	mov	rsi, rcx
	mov	rdi, QWORD PTR unicode$[rsp]

; 699  : 
; 700  :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))

	mov	QWORD PTR [rsp+32], rdi
	call	?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
	test	al, al
	jne	SHORT $LN7@decodeUnic
$LN3@decodeUnic:

; 701  :     return false;

	xor	al, al
	jmp	$LN8@decodeUnic
$LN7@decodeUnic:
	mov	eax, DWORD PTR [rdi]
	sub	eax, 55296				; 0000d800H
	cmp	eax, 1023				; 000003ffH
	ja	$LN1@decodeUnic

; 702  :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 703  :     // surrogate pairs
; 704  :     if (end - current < 6)

	mov	rcx, QWORD PTR [rbx]
	mov	rax, r14
	sub	rax, rcx
	cmp	rax, 6
	jge	SHORT $LN5@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rsp+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rsp+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 67					; 00000043H
	lea	rdx, OFFSET FLAT:??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
	lea	rcx, QWORD PTR $T4[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 708  :           current);

	mov	r9, QWORD PTR [rbx]
	mov	r8, rbp
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rsi
	call	?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::Reader::addError
	movzx	ebx, al
$LN165@decodeUnic:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rsp+24], 16
	jb	SHORT $LN76@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN76@decodeUnic:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 708  :           current);

	movzx	eax, bl
	jmp	$LN8@decodeUnic
$LN5@decodeUnic:

; 709  :     unsigned int surrogatePair;
; 710  :     if (*(current++) == '\\' && *(current++) == 'u') {

	movzx	eax, BYTE PTR [rcx]
	lea	rdx, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rdx
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN4@decodeUnic
	movzx	ecx, BYTE PTR [rdx]
	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rbx], rax
	cmp	cl, 117					; 00000075H
	jne	SHORT $LN4@decodeUnic

; 711  :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {

	lea	rax, QWORD PTR surrogatePair$1[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, r14
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, rsi
	call	?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
	test	al, al
	je	$LN3@decodeUnic

; 712  :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);

	mov	ecx, DWORD PTR [rdi]
	and	ecx, 1023				; 000003ffH
	add	ecx, 64					; 00000040H
	shl	ecx, 10
	mov	eax, DWORD PTR surrogatePair$1[rsp]
	and	eax, 1023				; 000003ffH
	add	ecx, eax
	mov	DWORD PTR [rdi], ecx

; 713  :       } else
; 714  :         return false;
; 715  :     } else

	jmp	SHORT $LN1@decodeUnic
$LN4@decodeUnic:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 79					; 0000004fH
	lea	rdx, OFFSET FLAT:??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 719  :                       current);

	mov	r9, QWORD PTR [rbx]
	mov	r8, rbp
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rsi
	call	?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::Reader::addError
	movzx	ebx, al
	jmp	$LN165@decodeUnic
$LN1@decodeUnic:

; 720  :   }
; 721  :   return true;

	mov	al, 1
$LN8@decodeUnic:

; 722  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ENDP ; Json::Reader::decodeUnicodeCodePoint
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
surrogatePair$1 = 48
$T2 = 56
$T3 = 64
$T4 = 64
__$ArrayPad$ = 96
this$ = 160
token$ = 168
current$ = 176
end$ = 184
unicode$ = 192
?dtor$0@?0??decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::Reader::decodeUnicodeCodePoint'::`1'::dtor$0
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::Reader::decodeUnicodeCodePoint'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
surrogatePair$1 = 48
$T2 = 56
$T3 = 64
$T4 = 64
__$ArrayPad$ = 96
this$ = 160
token$ = 168
current$ = 176
end$ = 184
unicode$ = 192
?dtor$1@?0??decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::Reader::decodeUnicodeCodePoint'::`1'::dtor$1
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??decodeUnicodeCodePoint@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::Reader::decodeUnicodeCodePoint'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
_TEXT	SEGMENT
$T1 = 32
info$2 = 48
info$3 = 48
$T4 = 112
$T5 = 112
__$ArrayPad$ = 144
this$ = 192
token$ = 200
current$ = 208
end$ = 216
ret_unicode$ = 224
?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z PROC ; Json::Reader::decodeUnicodeEscapeSequence, COMDAT

; 727  :                                          unsigned int& ret_unicode) {

$LN437:
	push	rbp
	push	rsi
	push	r14
	lea	rbp, QWORD PTR [rsp-63]
	sub	rsp, 160				; 000000a0H
	mov	QWORD PTR $T1[rbp-97], -2
	mov	QWORD PTR [rsp+216], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-97], rax
	mov	rbx, r8
	mov	rsi, rdx
	mov	r14, rcx
	mov	r10, QWORD PTR ret_unicode$[rbp-97]

; 728  :   if (end - current < 4)

	sub	r9, QWORD PTR [r8]
	cmp	r9, 4
	jge	$LN10@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-73], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-81], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-97], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 60					; 0000003cH
	lea	rdx, OFFSET FLAT:??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	rcx, QWORD PTR $T5[rbp-97]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 732  :         current);

	mov	rbx, QWORD PTR [rbx]
	mov	QWORD PTR info$3[rbp-49], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$3[rbp-57], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$3[rbp-73], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 756  :   info.token_ = token;

	movups	xmm0, XMMWORD PTR [rsi]
	movaps	XMMWORD PTR info$3[rbp-97], xmm0
	movsdx	xmm1, QWORD PTR [rsi+16]
	movsdx	QWORD PTR info$3[rbp-81], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T5[rbp-97]
	lea	rcx, QWORD PTR info$3[rbp-73]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 758  :   info.extra_ = extra;

	mov	QWORD PTR info$3[rbp-41], rbx

; 759  :   errors_.push_back(info);

	lea	rcx, QWORD PTR [r14+40]
	lea	rdx, QWORD PTR info$3[rbp-97]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$3[rbp-49], 16
	jb	SHORT $LN178@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$3[rbp-73]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN178@decodeUnic:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 732  :         current);

	jmp	$LN435@decodeUnic
$LN10@decodeUnic:

; 733  :   int unicode = 0;

	xor	eax, eax

; 734  :   for (int index = 0; index < 4; ++index) {

	xor	r8d, r8d
	npad	2
$LL9@decodeUnic:

; 735  :     Char c = *current++;

	mov	rcx, QWORD PTR [rbx]
	movzx	edx, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR [rbx], rcx

; 736  :     unicode *= 16;

	shl	eax, 4

; 737  :     if (c >= '0' && c <= '9')

	lea	ecx, DWORD PTR [rdx-48]
	cmp	cl, 9
	ja	SHORT $LN6@decodeUnic

; 738  :       unicode += c - '0';

	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN436@decodeUnic
$LN6@decodeUnic:

; 739  :     else if (c >= 'a' && c <= 'f')

	lea	ecx, DWORD PTR [rdx-97]
	cmp	cl, 5
	ja	SHORT $LN4@decodeUnic

; 740  :       unicode += c - 'a' + 10;

	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN436@decodeUnic
$LN4@decodeUnic:

; 741  :     else if (c >= 'A' && c <= 'F')

	lea	ecx, DWORD PTR [rdx-65]
	cmp	cl, 5
	ja	SHORT $LN2@decodeUnic

; 742  :       unicode += c - 'A' + 10;

	add	eax, -55				; ffffffffffffffc9H
$LN436@decodeUnic:
	movsx	ecx, dl
	add	eax, ecx

; 734  :   for (int index = 0; index < 4; ++index) {

	inc	r8d
	cmp	r8d, 4
	jl	SHORT $LL9@decodeUnic

; 748  :   }
; 749  :   ret_unicode = static_cast<unsigned int>(unicode);

	mov	DWORD PTR [r10], eax

; 750  :   return true;

	mov	al, 1
	jmp	$LN11@decodeUnic
$LN2@decodeUnic:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-73], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-81], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rbp-97], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 66					; 00000042H
	lea	rdx, OFFSET FLAT:??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	rcx, QWORD PTR $T4[rbp-97]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 747  :           current);

	mov	rbx, QWORD PTR [rbx]
	mov	QWORD PTR info$2[rbp-49], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$2[rbp-57], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$2[rbp-73], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 756  :   info.token_ = token;

	movups	xmm0, XMMWORD PTR [rsi]
	movaps	XMMWORD PTR info$2[rbp-97], xmm0
	movsdx	xmm1, QWORD PTR [rsi+16]
	movsdx	QWORD PTR info$2[rbp-81], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T4[rbp-97]
	lea	rcx, QWORD PTR info$2[rbp-73]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 758  :   info.extra_ = extra;

	mov	QWORD PTR info$2[rbp-41], rbx

; 759  :   errors_.push_back(info);

	lea	rcx, QWORD PTR [r14+40]
	lea	rdx, QWORD PTR info$2[rbp-97]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$2[rbp-49], 16
	jb	SHORT $LN385@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$2[rbp-73]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN385@decodeUnic:
$LN435@decodeUnic:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-73], 16
	jb	SHORT $LN417@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rbp-97]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN417@decodeUnic:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 747  :           current);

	xor	al, al
$LN11@decodeUnic:

; 751  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-97]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+216]
	add	rsp, 160				; 000000a0H
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
?decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ENDP ; Json::Reader::decodeUnicodeEscapeSequence
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
info$2 = 48
info$3 = 48
$T4 = 112
$T5 = 112
__$ArrayPad$ = 144
this$ = 192
token$ = 200
current$ = 208
end$ = 216
ret_unicode$ = 224
?dtor$0@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::Reader::decodeUnicodeEscapeSequence'::`1'::dtor$0
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::Reader::decodeUnicodeEscapeSequence'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
info$2 = 48
info$3 = 48
$T4 = 112
$T5 = 112
__$ArrayPad$ = 144
this$ = 192
token$ = 200
current$ = 208
end$ = 216
ret_unicode$ = 224
?dtor$2@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::Reader::decodeUnicodeEscapeSequence'::`1'::dtor$2
	lea	rcx, QWORD PTR info$3[rdx]
	jmp	??1ErrorInfo@Reader@Json@@QEAA@XZ
?dtor$2@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::Reader::decodeUnicodeEscapeSequence'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
info$2 = 48
info$3 = 48
$T4 = 112
$T5 = 112
__$ArrayPad$ = 144
this$ = 192
token$ = 200
current$ = 208
end$ = 216
ret_unicode$ = 224
?dtor$1@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::Reader::decodeUnicodeEscapeSequence'::`1'::dtor$1
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::Reader::decodeUnicodeEscapeSequence'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
info$2 = 48
info$3 = 48
$T4 = 112
$T5 = 112
__$ArrayPad$ = 144
this$ = 192
token$ = 200
current$ = 208
end$ = 216
ret_unicode$ = 224
?dtor$3@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::Reader::decodeUnicodeEscapeSequence'::`1'::dtor$3
	lea	rcx, QWORD PTR info$2[rdx]
	jmp	??1ErrorInfo@Reader@Json@@QEAA@XZ
?dtor$3@?0??decodeUnicodeEscapeSequence@Reader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::Reader::decodeUnicodeEscapeSequence'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
_TEXT	SEGMENT
$T1 = 32
info$ = 48
__$ArrayPad$ = 112
this$ = 160
message$ = 168
token$ = 176
extra$ = 184
?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z PROC ; Json::Reader::addError, COMDAT

; 754  : Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {

$LN133:
	push	rbx
	push	rdi
	sub	rsp, 136				; 00000088H
	mov	QWORD PTR $T1[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r9
	mov	rbx, rcx
	mov	QWORD PTR info$[rsp+48], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$[rsp+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$[rsp+24], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 756  :   info.token_ = token;

	movups	xmm0, XMMWORD PTR [r8]
	movaps	XMMWORD PTR info$[rsp], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR info$[rsp+16], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 998  : 		if (this != &_Right)

	lea	rax, QWORD PTR info$[rsp+24]
	cmp	rax, rdx
	je	SHORT $LN96@addError

; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rcx, QWORD PTR info$[rsp+24]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN96@addError:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 758  :   info.extra_ = extra;

	mov	QWORD PTR info$[rsp+56], rdi

; 759  :   errors_.push_back(info);

	lea	rcx, QWORD PTR [rbx+40]
	lea	rdx, QWORD PTR info$[rsp]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$[rsp+48], 16
	jb	SHORT $LN132@addError
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$[rsp+24]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN132@addError:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 760  :   return false;

	xor	al, al

; 761  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	pop	rdi
	pop	rbx
	ret	0
?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ENDP ; Json::Reader::addError
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
info$ = 48
__$ArrayPad$ = 112
this$ = 160
message$ = 168
token$ = 176
extra$ = 184
?dtor$0@?0??addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z@4HA PROC ; `Json::Reader::addError'::`1'::dtor$0
	lea	rcx, QWORD PTR info$[rdx]
	jmp	??1ErrorInfo@Reader@Json@@QEAA@XZ
?dtor$0@?0??addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z@4HA ENDP ; `Json::Reader::addError'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??0ErrorInfo@Reader@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ErrorInfo@Reader@Json@@QEAA@XZ PROC			; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+40], 0
	mov	rax, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx+24], 0
	ret	0
??0ErrorInfo@Reader@Json@@QEAA@XZ ENDP			; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z
_TEXT	SEGMENT
skip$ = 32
this$ = 80
skipUntilToken$ = 88
?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z PROC ; Json::Reader::recoverFromError, COMDAT

; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1352 : 		return (this->_Mysize);

	mov	rdi, QWORD PTR [rcx+72]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 763  : bool Reader::recoverFromError(TokenType skipUntilToken) {

	mov	esi, edx
	mov	rbx, rcx
	npad	8
$LL5@recoverFro:

; 764  :   size_t const errorCount = errors_.size();
; 765  :   Token skip;
; 766  :   for (;;) {
; 767  :     if (!readToken(skip))

	lea	rdx, QWORD PTR skip$[rsp]
	mov	rcx, rbx
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN3@recoverFro

; 768  :       errors_.resize(errorCount); // discard errors caused by recovery

	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN3@recoverFro:

; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)

	mov	eax, DWORD PTR skip$[rsp]
	cmp	eax, esi
	je	SHORT $LN11@recoverFro
	test	eax, eax
	jne	SHORT $LL5@recoverFro
$LN11@recoverFro:

; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);

	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize

; 773  :   return false;
; 774  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	xor	al, al
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?recoverFromError@Reader@Json@@AEAA_NW4TokenType@12@@Z ENDP ; Json::Reader::recoverFromError
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?addErrorAndRecover@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z
_TEXT	SEGMENT
skip$1 = 32
this$ = 80
message$ = 88
token$ = 96
skipUntilToken$ = 104
?addErrorAndRecover@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z PROC ; Json::Reader::addErrorAndRecover, COMDAT

; 778  :                                 TokenType skipUntilToken) {

$LN17:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	esi, r9d

; 779  :   addError(message, token);

	xor	r9d, r9d
	mov	rbx, rcx
	call	?addError@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::Reader::addError
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1352 : 		return (this->_Mysize);

	mov	rdi, QWORD PTR [rbx+72]
$LL7@addErrorAn:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 767  :     if (!readToken(skip))

	lea	rdx, QWORD PTR skip$1[rsp]
	mov	rcx, rbx
	call	?readToken@Reader@Json@@AEAA_NAEAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN5@addErrorAn

; 768  :       errors_.resize(errorCount); // discard errors caused by recovery

	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN5@addErrorAn:

; 769  :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)

	mov	eax, DWORD PTR skip$1[rsp]
	cmp	eax, esi
	je	SHORT $LN13@addErrorAn
	test	eax, eax
	jne	SHORT $LL7@addErrorAn
$LN13@addErrorAn:

; 770  :       break;
; 771  :   }
; 772  :   errors_.resize(errorCount);

	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize

; 780  :   return recoverFromError(skipUntilToken);
; 781  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	xor	al, al
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?addErrorAndRecover@Reader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z ENDP ; Json::Reader::addErrorAndRecover
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 56
this$ = 96
?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ PROC	; Json::Reader::currentValue, COMDAT

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

$LN18:
	sub	rsp, 88					; 00000058H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T1[rsp]
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
	mov	r8, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	je	SHORT $LN14@currentVal
	mov	rax, QWORD PTR [rax]
$LN14@currentVal:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rcx, QWORD PTR [rax+16]
	mov	r8, QWORD PTR [r8+16]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	rax, QWORD PTR [rax+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, r8
	dec	rcx
	shr	rdx, 1
	and	rdx, rcx

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	r8d, 1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 783  : Value& Reader::currentValue() { return *(nodes_.top()); }

	mov	rax, QWORD PTR [rax+rdx*8]
	mov	rax, QWORD PTR [rax+r8*8]
	add	rsp, 88					; 00000058H
	ret	0
?currentValue@Reader@Json@@AEAAAEAVValue@2@XZ ENDP	; Json::Reader::currentValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?getNextChar@Reader@Json@@AEAADXZ
_TEXT	SEGMENT
this$ = 8
?getNextChar@Reader@Json@@AEAADXZ PROC			; Json::Reader::getNextChar, COMDAT

; 785  : Reader::Char Reader::getNextChar() {

	mov	rdx, rcx

; 786  :   if (current_ == end_)

	mov	rcx, QWORD PTR [rcx+128]
	cmp	rcx, QWORD PTR [rdx+120]
	jne	SHORT $LN1@getNextCha

; 787  :     return 0;

	xor	al, al

; 789  : }

	ret	0
$LN1@getNextCha:

; 788  :   return *current_++;

	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR [rdx+128], rcx

; 789  : }

	ret	0
?getNextChar@Reader@Json@@AEAADXZ ENDP			; Json::Reader::getNextChar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?all@OurFeatures@Json@@SA?AV12@XZ
_TEXT	SEGMENT
$T1 = 8
?all@OurFeatures@Json@@SA?AV12@XZ PROC			; Json::OurFeatures::all, COMDAT

; 915  : OurFeatures OurFeatures::all() { return OurFeatures(); }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	rax, rcx
	ret	0
?all@OurFeatures@Json@@SA?AV12@XZ ENDP			; Json::OurFeatures::all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
features$ = 72
??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z PROC	; Json::OurReader::OurReader, COMDAT

; 1042 :       features_(features), collectComments_() {

$LN181:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+88], rsi
	mov	rsi, rdx
	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	ebp, ebp
	mov	QWORD PTR [rcx], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rbp

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rbp

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rbp

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	lea	ecx, QWORD PTR [rbp+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN28@OurReader

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN28@OurReader:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1042 :       features_(features), collectComments_() {

	lea	rdi, QWORD PTR [rbx+40]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	mov	QWORD PTR [rdi], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rdi+8], rbp

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rdi+16], rbp

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rdi+24], rbp

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rdi+32], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN76@OurReader

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN76@OurReader:
	mov	QWORD PTR [rdi], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rbx+104], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+96], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+80], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1042 :       features_(features), collectComments_() {

	mov	QWORD PTR [rbx+112], rbp
	mov	QWORD PTR [rbx+120], rbp
	mov	QWORD PTR [rbx+128], rbp
	mov	QWORD PTR [rbx+136], rbp
	mov	QWORD PTR [rbx+144], rbp
	mov	QWORD PTR [rbx+176], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+168], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+152], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1042 :       features_(features), collectComments_() {

	movsdx	xmm0, QWORD PTR [rsi]
	movsdx	QWORD PTR [rbx+184], xmm0
	mov	eax, DWORD PTR [rsi+8]
	mov	DWORD PTR [rbx+192], eax
	mov	BYTE PTR [rbx+196], 0

; 1043 : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN180@OurReader:
??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z ENDP	; Json::OurReader::OurReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
features$ = 72
?dtor$0@?0???0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z@4HA PROC ; `Json::OurReader::OurReader'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0???0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z@4HA ENDP ; `Json::OurReader::OurReader'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z
_TEXT	SEGMENT
token$ = 32
root$GSCopy$ = 56
$T1 = 64
info$2 = 80
info$3 = 80
$T4 = 144
$T5 = 144
__$ArrayPad$ = 176
this$ = 272
beginDoc$ = 280
endDoc$ = 288
root$ = 296
collectComments$ = 304
?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z PROC	; Json::OurReader::parse, COMDAT

; 1048 :                    bool collectComments) {

$LN492:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-23]
	sub	rsp, 200				; 000000c8H
	mov	QWORD PTR $T1[rbp-177], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-177], rax
	mov	r15, r9
	mov	r13, r8
	mov	r12, rdx
	mov	rbx, rcx
	mov	QWORD PTR root$GSCopy$[rbp-177], r9

; 1049 :   if (!features_.allowComments_) {

	movzx	eax, BYTE PTR collectComments$[rbp-177]
	xor	esi, esi
	cmp	BYTE PTR [rcx+184], sil
	cmove	eax, esi
	mov	QWORD PTR [rcx+112], rdx

; 1050 :     collectComments = false;
; 1051 :   }
; 1052 : 
; 1053 :   begin_ = beginDoc;
; 1054 :   end_ = endDoc;

	mov	QWORD PTR [rcx+120], r8

; 1055 :   collectComments_ = collectComments;

	mov	BYTE PTR [rcx+196], al

; 1056 :   current_ = begin_;

	mov	QWORD PTR [rcx+128], rdx

; 1057 :   lastValueEnd_ = 0;

	mov	QWORD PTR [rcx+136], rsi

; 1058 :   lastValue_ = 0;

	mov	QWORD PTR [rcx+144], rsi

; 1059 :   commentsBefore_.clear();

	lea	rdi, QWORD PTR [rcx+152]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], rsi

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN20@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rdi]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN21@parse
$LN20@parse:
	mov	rax, rdi
$LN21@parse:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax], sil
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1060 :   errors_.clear();

	lea	r14, QWORD PTR [rcx+40]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1643 : 		_Tidy();

	mov	rcx, r14
	call	?_Tidy@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAXXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Tidy

; 1362 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+32], rsi
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1061 :   while (!nodes_.empty())

	je	SHORT $LN7@parse
	mov	rax, QWORD PTR [rbx+32]
$LL8@parse:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1491 : 		if (--this->_Mysize == 0)

	dec	rax
	jne	SHORT $LN34@parse

; 1492 : 			this->_Myoff = 0;

	mov	QWORD PTR [rbx+24], rsi
$LN34@parse:

; 1362 : 		return (this->_Mysize == 0);

	test	rax, rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1061 :   while (!nodes_.empty())

	jne	SHORT $LL8@parse
	mov	QWORD PTR [rbx+32], rax
$LN7@parse:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	lea	rdx, QWORD PTR root$GSCopy$[rbp-177]
	mov	rcx, rbx
	call	?push_back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::push_back
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1065 :   bool successful = readValue();

	mov	rcx, rbx
	call	?readValue@OurReader@Json@@AEAA_NXZ	; Json::OurReader::readValue
	movzx	esi, al

; 1091 : 
; 1092 : bool OurReader::readValue() {
; 1093 :   //  To preserve the old behaviour we cast size_t to int.
; 1094 :   if (static_cast<int>(nodes_.size()) > features_.stackLimit_) throwRuntimeError("Exceeded stackLimit in readValue().");
; 1095 :   Token token;
; 1096 :   skipCommentTokens(token);
; 1097 :   bool successful = true;
; 1098 : 
; 1099 :   if (collectComments_ && !commentsBefore_.empty()) {
; 1100 :     currentValue().setComment(commentsBefore_, commentBefore);
; 1101 :     commentsBefore_.clear();
; 1102 :   }
; 1103 : 
; 1104 :   switch (token.type_) {
; 1105 :   case tokenObjectBegin:
; 1106 :     successful = readObject(token);
; 1107 :     currentValue().setOffsetLimit(current_ - begin_);
; 1108 :     break;
; 1109 :   case tokenArrayBegin:
; 1110 :     successful = readArray(token);
; 1111 :     currentValue().setOffsetLimit(current_ - begin_);
; 1112 :     break;
; 1113 :   case tokenNumber:
; 1114 :     successful = decodeNumber(token);
; 1115 :     break;
; 1116 :   case tokenString:
; 1117 :     successful = decodeString(token);
; 1118 :     break;
; 1119 :   case tokenTrue:
; 1120 :     {
; 1121 :     Value v(true);
; 1122 :     currentValue().swapPayload(v);
; 1123 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1124 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1125 :     }
; 1126 :     break;
; 1127 :   case tokenFalse:
; 1128 :     {
; 1129 :     Value v(false);
; 1130 :     currentValue().swapPayload(v);
; 1131 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1132 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1133 :     }
; 1134 :     break;
; 1135 :   case tokenNull:
; 1136 :     {
; 1137 :     Value v;
; 1138 :     currentValue().swapPayload(v);
; 1139 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1140 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1141 :     }
; 1142 :     break;
; 1143 :   case tokenNaN:
; 1144 :     {
; 1145 :     Value v(std::numeric_limits<double>::quiet_NaN());
; 1146 :     currentValue().swapPayload(v);
; 1147 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1148 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1149 :     }
; 1150 :     break;
; 1151 :   case tokenPosInf:
; 1152 :     {
; 1153 :     Value v(std::numeric_limits<double>::infinity());
; 1154 :     currentValue().swapPayload(v);
; 1155 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1156 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1157 :     }
; 1158 :     break;
; 1159 :   case tokenNegInf:
; 1160 :     {
; 1161 :     Value v(-std::numeric_limits<double>::infinity());
; 1162 :     currentValue().swapPayload(v);
; 1163 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1164 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1165 :     }
; 1166 :     break;
; 1167 :   case tokenArraySeparator:
; 1168 :   case tokenObjectEnd:
; 1169 :   case tokenArrayEnd:
; 1170 :     if (features_.allowDroppedNullPlaceholders_) {
; 1171 :       // "Un-read" the current token and mark the current value as a null
; 1172 :       // token.
; 1173 :       current_--;
; 1174 :       Value v;
; 1175 :       currentValue().swapPayload(v);
; 1176 :       currentValue().setOffsetStart(current_ - begin_ - 1);
; 1177 :       currentValue().setOffsetLimit(current_ - begin_);
; 1178 :       break;
; 1179 :     } // else, fall through ...
; 1180 :   default:
; 1181 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1182 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1183 :     return addError("Syntax error: value, object or array expected.", token);
; 1184 :   }
; 1185 : 
; 1186 :   if (collectComments_) {
; 1187 :     lastValueEnd_ = current_;
; 1188 :     lastValue_ = &currentValue();
; 1189 :   }
; 1190 : 
; 1191 :   return successful;
; 1192 : }
; 1193 : 
; 1194 : void OurReader::skipCommentTokens(Token& token) {
; 1195 :   if (features_.allowComments_) {

	cmp	BYTE PTR [rbx+184], 0
	je	SHORT $LN49@parse
	npad	9
$LL48@parse:

; 1196 :     do {
; 1197 :       readToken(token);

	lea	rdx, QWORD PTR token$[rsp]
	mov	rcx, rbx
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken

; 1198 :     } while (token.type_ == tokenComment);

	mov	ecx, DWORD PTR token$[rsp]
	cmp	ecx, 15
	je	SHORT $LL48@parse

; 1199 :   } else {

	jmp	SHORT $LN45@parse
$LN49@parse:

; 1200 :     readToken(token);

	lea	rdx, QWORD PTR token$[rsp]
	mov	rcx, rbx
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	mov	ecx, DWORD PTR token$[rsp]
$LN45@parse:

; 1066 :   Token token;
; 1067 :   skipCommentTokens(token);
; 1068 :   if (features_.failIfExtra_) {

	cmp	BYTE PTR [rbx+189], 0
	je	$LN5@parse

; 1069 :     if ((features_.strictRoot_ || token.type_ != tokenError) && token.type_ != tokenEndOfStream) {

	cmp	BYTE PTR [rbx+185], 0
	jne	SHORT $LN4@parse
	cmp	ecx, 16
	je	$LN5@parse
$LN4@parse:
	test	ecx, ecx
	je	$LN5@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-153], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	ebx, ebx
	mov	QWORD PTR $T5[rbp-161], rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-177], bl
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+38]
	lea	rdx, OFFSET FLAT:??_C@_0CH@OHPLAFOE@Extra?5non?9whitespace?5after?5JSON?5@
	lea	rcx, QWORD PTR $T5[rbp-177]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR info$3[rbp-129], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$3[rbp-137], rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$3[rbp-153], bl
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1759 :   info.token_ = token;

	movups	xmm0, XMMWORD PTR token$[rsp]
	movaps	XMMWORD PTR info$3[rbp-177], xmm0
	movsdx	xmm1, QWORD PTR token$[rsp+16]
	movsdx	QWORD PTR info$3[rbp-161], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T5[rbp-177]
	lea	rcx, QWORD PTR info$3[rbp-153]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1761 :   info.extra_ = extra;

	mov	QWORD PTR info$3[rbp-121], rbx

; 1762 :   errors_.push_back(info);

	lea	rdx, QWORD PTR info$3[rbp-177]
	mov	rcx, r14
	call	?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$3[rbp-129], 16
	jb	SHORT $LN215@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$3[rbp-153]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN215@parse:
$LN491@parse:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T5[rbp-153], 16
	jb	SHORT $LN247@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T5[rbp-177]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN247@parse:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1071 :       return false;

	xor	al, al
	jmp	$LN10@parse
$LN5@parse:

; 1074 :   if (collectComments_ && !commentsBefore_.empty())

	cmp	BYTE PTR [rbx+196], 0
	je	SHORT $LN261@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+168], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1074 :   if (collectComments_ && !commentsBefore_.empty())

	je	SHORT $LN261@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1749 : 		return (this->_Mysize);

	mov	r8, QWORD PTR [rdi+16]

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN270@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rdi, QWORD PTR [rdi]
$LN270@parse:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1407 :   setComment(comment.c_str(), comment.length(), placement);

	mov	r9d, 2
	mov	rdx, rdi
	mov	rcx, r15
	call	?setComment@Value@Json@@QEAAXPEBD_KW4CommentPlacement@2@@Z ; Json::Value::setComment
$LN261@parse:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1076 :   if (features_.strictRoot_) {

	cmp	BYTE PTR [rbx+185], 0
	je	$LN1@parse
	movzx	eax, BYTE PTR [r15+8]
	sub	al, 6
	cmp	al, 1
	jbe	$LN1@parse

; 1077 :     if (!root.isArray() && !root.isObject()) {
; 1078 :       // Set error location to start of doc, ideally should be first token found
; 1079 :       // in doc
; 1080 :       token.type_ = tokenError;

	mov	DWORD PTR token$[rsp], 16

; 1081 :       token.start_ = beginDoc;

	mov	QWORD PTR token$[rsp+8], r12

; 1082 :       token.end_ = endDoc;

	mov	QWORD PTR token$[rsp+16], r13
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-153], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	ebx, ebx
	mov	QWORD PTR $T4[rbp-161], rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rbp-177], bl
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+65]
	lea	rdx, OFFSET FLAT:??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
	lea	rcx, QWORD PTR $T4[rbp-177]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR info$2[rbp-129], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$2[rbp-137], rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$2[rbp-153], bl
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1759 :   info.token_ = token;

	movups	xmm0, XMMWORD PTR token$[rsp]
	movaps	XMMWORD PTR info$2[rbp-177], xmm0
	movsdx	xmm1, QWORD PTR token$[rsp+16]
	movsdx	QWORD PTR info$2[rbp-161], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T4[rbp-177]
	lea	rcx, QWORD PTR info$2[rbp-153]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1761 :   info.extra_ = extra;

	mov	QWORD PTR info$2[rbp-121], rbx

; 1762 :   errors_.push_back(info);

	lea	rdx, QWORD PTR info$2[rbp-177]
	mov	rcx, r14
	call	?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$2[rbp-129], 16
	jb	SHORT $LN440@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$2[rbp-153]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN440@parse:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1086 :       return false;

	jmp	$LN491@parse
$LN1@parse:

; 1087 :     }
; 1088 :   }
; 1089 :   return successful;

	movzx	eax, sil
$LN10@parse:

; 1090 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-177]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z ENDP	; Json::OurReader::parse
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
root$GSCopy$ = 56
$T1 = 64
info$2 = 80
info$3 = 80
$T4 = 144
$T5 = 144
__$ArrayPad$ = 176
this$ = 272
beginDoc$ = 280
endDoc$ = 288
root$ = 296
collectComments$ = 304
?dtor$0@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA PROC ; `Json::OurReader::parse'::`1'::dtor$0
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA ENDP ; `Json::OurReader::parse'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
root$GSCopy$ = 56
$T1 = 64
info$2 = 80
info$3 = 80
$T4 = 144
$T5 = 144
__$ArrayPad$ = 176
this$ = 272
beginDoc$ = 280
endDoc$ = 288
root$ = 296
collectComments$ = 304
?dtor$2@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA PROC ; `Json::OurReader::parse'::`1'::dtor$2
	lea	rcx, QWORD PTR info$3[rdx]
	jmp	??1ErrorInfo@OurReader@Json@@QEAA@XZ
?dtor$2@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA ENDP ; `Json::OurReader::parse'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
root$GSCopy$ = 56
$T1 = 64
info$2 = 80
info$3 = 80
$T4 = 144
$T5 = 144
__$ArrayPad$ = 176
this$ = 272
beginDoc$ = 280
endDoc$ = 288
root$ = 296
collectComments$ = 304
?dtor$1@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA PROC ; `Json::OurReader::parse'::`1'::dtor$1
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA ENDP ; `Json::OurReader::parse'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
root$GSCopy$ = 56
$T1 = 64
info$2 = 80
info$3 = 80
$T4 = 144
$T5 = 144
__$ArrayPad$ = 176
this$ = 272
beginDoc$ = 280
endDoc$ = 288
root$ = 296
collectComments$ = 304
?dtor$3@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA PROC ; `Json::OurReader::parse'::`1'::dtor$3
	lea	rcx, QWORD PTR info$2[rdx]
	jmp	??1ErrorInfo@OurReader@Json@@QEAA@XZ
?dtor$3@?0??parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z@4HA ENDP ; `Json::OurReader::parse'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readValue@OurReader@Json@@AEAA_NXZ
_TEXT	SEGMENT
token$ = 32
$T1 = 56
$T2 = 64
$T3 = 64
info$4 = 96
$T5 = 96
$T6 = 96
v$7 = 96
v$8 = 96
v$9 = 96
v$10 = 96
v$11 = 96
v$12 = 96
v$13 = 96
$T14 = 160
$T15 = 160
__$ArrayPad$ = 192
this$ = 240
?readValue@OurReader@Json@@AEAA_NXZ PROC		; Json::OurReader::readValue, COMDAT

; 1092 : bool OurReader::readValue() {

$LN593:
	mov	rax, rsp
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 208				; 000000d0H
	mov	QWORD PTR $T1[rbp-137], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-137], rax
	mov	rdi, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1352 : 		return (this->_Mysize);

	mov	rax, QWORD PTR [rcx+32]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1094 :   if (static_cast<int>(nodes_.size()) > features_.stackLimit_) throwRuntimeError("Exceeded stackLimit in readValue().");

	cmp	eax, DWORD PTR [rcx+192]
	jle	SHORT $LN108@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T15[rbp-113], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	r14d, r14d
	mov	QWORD PTR $T15[rbp-121], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T15[rbp-137], r14b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r14+35]
	lea	rdx, OFFSET FLAT:??_C@_0CE@OOHDBGBA@Exceeded?5stackLimit?5in?5readValue@
	lea	rcx, QWORD PTR $T15[rbp-137]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1094 :   if (static_cast<int>(nodes_.size()) > features_.stackLimit_) throwRuntimeError("Exceeded stackLimit in readValue().");

	lea	rcx, QWORD PTR $T15[rbp-137]
	call	?throwRuntimeError@Json@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::throwRuntimeError
	npad	1
$LN108@readValue:

; 1193 : 
; 1194 : void OurReader::skipCommentTokens(Token& token) {
; 1195 :   if (features_.allowComments_) {

	cmp	BYTE PTR [rcx+184], 0
	je	SHORT $LN114@readValue
	npad	1
$LL113@readValue:

; 1196 :     do {
; 1197 :       readToken(token);

	lea	rdx, QWORD PTR token$[rbp-137]
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken

; 1198 :     } while (token.type_ == tokenComment);

	mov	ebx, DWORD PTR token$[rbp-137]
	cmp	ebx, 15
	je	SHORT $LL113@readValue

; 1199 :   } else {

	jmp	SHORT $LN110@readValue
$LN114@readValue:

; 1200 :     readToken(token);

	lea	rdx, QWORD PTR token$[rbp-137]
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	mov	ebx, DWORD PTR token$[rbp-137]
$LN110@readValue:

; 1095 :   Token token;
; 1096 :   skipCommentTokens(token);
; 1097 :   bool successful = true;

	mov	r15b, 1

; 1099 :   if (collectComments_ && !commentsBefore_.empty()) {

	xor	r14d, r14d
	cmp	BYTE PTR [rdi+196], r14b
	je	SHORT $LN141@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rdi+168], r14
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1099 :   if (collectComments_ && !commentsBefore_.empty()) {

	je	SHORT $LN141@readValue

; 1100 :     currentValue().setComment(commentsBefore_, commentBefore);

	lea	rsi, QWORD PTR [rdi+152]
	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN127@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rdx, QWORD PTR [rsi]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	jmp	SHORT $LN128@readValue
$LN127@readValue:
	mov	rdx, rsi
$LN128@readValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1407 :   setComment(comment.c_str(), comment.length(), placement);

	xor	r9d, r9d
	mov	r8, QWORD PTR [rsi+16]
	mov	rcx, rax
	call	?setComment@Value@Json@@QEAAXPEBD_KW4CommentPlacement@2@@Z ; Json::Value::setComment
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rsi+16], r14

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN138@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rsi, QWORD PTR [rsi]
$LN138@readValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rsi], r14b
$LN141@readValue:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1104 :   switch (token.type_) {

	dec	ebx
	cmp	ebx, 12
	ja	$LN3@readValue
	movsxd	rax, ebx
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN585@readValue[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN14@readValue:

; 1105 :   case tokenObjectBegin:
; 1106 :     successful = readObject(token);

	lea	rdx, QWORD PTR token$[rbp-137]
	mov	rcx, rdi
	call	?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readObject
$LN589@readValue:
	movzx	r15d, al

; 1107 :     currentValue().setOffsetLimit(current_ - begin_);

	mov	rbx, QWORD PTR [rdi+128]
	sub	rbx, QWORD PTR [rdi+112]
	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1422 : void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

	mov	QWORD PTR [rax+32], rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1108 :     break;

	jmp	$LN15@readValue
$LN13@readValue:

; 1109 :   case tokenArrayBegin:
; 1110 :     successful = readArray(token);

	lea	rdx, QWORD PTR token$[rbp-137]
	mov	rcx, rdi
	call	?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readArray

; 1111 :     currentValue().setOffsetLimit(current_ - begin_);
; 1112 :     break;

	jmp	SHORT $LN589@readValue
$LN12@readValue:

; 1113 :   case tokenNumber:
; 1114 :     successful = decodeNumber(token);

	lea	rdx, QWORD PTR token$[rbp-137]
	mov	rcx, rdi
	call	?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::decodeNumber
	movzx	r15d, al

; 1115 :     break;

	jmp	$LN15@readValue
$LN11@readValue:

; 1116 :   case tokenString:
; 1117 :     successful = decodeString(token);

	lea	rdx, QWORD PTR token$[rbp-137]
	mov	rcx, rdi
	call	?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::decodeString
	movzx	r15d, al

; 1118 :     break;

	jmp	$LN15@readValue
$LN10@readValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 431  :   value_.bool_ = value;

	mov	BYTE PTR v$13[rbp-137], 1
$LN590@readValue:
	mov	ebx, DWORD PTR v$13[rbp-129]
	and	ebx, -507				; fffffe05H

; 1023 :   allocated_ = allocated;

	or	ebx, 5
$LN591@readValue:
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR v$13[rbp-121], xmm0
$LN592@readValue:

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR v$13[rbp-105], r14

; 1023 :   allocated_ = allocated;

	mov	DWORD PTR v$13[rbp-129], ebx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1122 :     currentValue().swapPayload(v);

	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
	mov	r8, rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	edx, BYTE PTR [rax+8]

; 518  :   type_ = other.type_;

	movzx	ecx, bl
	mov	BYTE PTR [rax+8], bl

; 519  :   other.type_ = temp;

	mov	ecx, ebx
	xor	ecx, edx
	movzx	ecx, cl
	xor	ebx, ecx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rcx, QWORD PTR [rax]

; 53   : 	_Left = _Move(_Right);

	mov	rdx, QWORD PTR v$13[rbp-137]
	mov	QWORD PTR [rax], rdx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR v$13[rbp-137], rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [rax+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, ebx
	xor	eax, ecx
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, ebx
	and	edx, 256				; 00000100H
	xor	ebx, edx
	mov	DWORD PTR v$13[rbp-129], ebx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1123 :     currentValue().setOffsetStart(token.start_ - begin_);

	mov	rbx, QWORD PTR token$[rbp-129]
	sub	rbx, QWORD PTR [rdi+112]
	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rax+24], rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1124 :     currentValue().setOffsetLimit(token.end_ - begin_);

	mov	rbx, QWORD PTR token$[rbp-121]

; 1125 :     }
; 1126 :     break;

	jmp	$LN587@readValue
$LN9@readValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 431  :   value_.bool_ = value;

	mov	BYTE PTR v$12[rbp-137], r14b
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1134 :     break;

	jmp	$LN590@readValue
$LN8@readValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	mov	ebx, DWORD PTR v$11[rbp-129]
	and	ebx, -512				; fffffe00H
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1142 :     break;

	jmp	$LN591@readValue
$LN7@readValue:
	mov	ebx, DWORD PTR v$10[rbp-129]
	and	ebx, -509				; fffffe03H
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	or	ebx, 3
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR v$10[rbp-121], xmm0

; 396  :   value_.real_ = value;

	mov	rax, QWORD PTR __imp__Nan
	movsdx	xmm0, QWORD PTR [rax]
	movsdx	QWORD PTR v$10[rbp-137], xmm0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1150 :     break;

	jmp	$LN592@readValue
$LN6@readValue:
	mov	ebx, DWORD PTR v$9[rbp-129]
	and	ebx, -509				; fffffe03H
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	or	ebx, 3
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR v$9[rbp-121], xmm0

; 396  :   value_.real_ = value;

	mov	rax, QWORD PTR __imp__Inf
	movsdx	xmm0, QWORD PTR [rax]
	movsdx	QWORD PTR v$9[rbp-137], xmm0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1158 :     break;

	jmp	$LN592@readValue
$LN5@readValue:
	mov	ebx, DWORD PTR v$8[rbp-129]
	and	ebx, -509				; fffffe03H
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	or	ebx, 3
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR v$8[rbp-121], xmm0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1161 :     Value v(-std::numeric_limits<double>::infinity());

	mov	rax, QWORD PTR __imp__Inf
	movsdx	xmm0, QWORD PTR [rax]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 396  :   value_.real_ = value;

	movsdx	QWORD PTR v$8[rbp-137], xmm0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1166 :     break;

	jmp	$LN592@readValue
$LN4@readValue:

; 1167 :   case tokenArraySeparator:
; 1168 :   case tokenObjectEnd:
; 1169 :   case tokenArrayEnd:
; 1170 :     if (features_.allowDroppedNullPlaceholders_) {

	cmp	BYTE PTR [rdi+186], r14b
	je	$LN3@readValue

; 1171 :       // "Un-read" the current token and mark the current value as a null
; 1172 :       // token.
; 1173 :       current_--;

	dec	QWORD PTR [rdi+128]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	mov	ebx, DWORD PTR v$7[rbp-129]
	and	ebx, -512				; fffffe00H
	mov	DWORD PTR v$7[rbp-129], ebx
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR v$7[rbp-121], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR v$7[rbp-105], r14
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1175 :       currentValue().swapPayload(v);

	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
	mov	r8, rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	edx, BYTE PTR [rax+8]

; 518  :   type_ = other.type_;

	movzx	ecx, bl
	mov	BYTE PTR [rax+8], bl

; 519  :   other.type_ = temp;

	mov	ecx, ebx
	xor	ecx, edx
	movzx	ecx, cl
	xor	ebx, ecx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rcx, QWORD PTR [rax]

; 53   : 	_Left = _Move(_Right);

	mov	rdx, QWORD PTR v$7[rbp-137]
	mov	QWORD PTR [rax], rdx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR v$7[rbp-137], rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [rax+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, ebx
	xor	eax, ecx
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, ebx
	and	edx, 256				; 00000100H
	xor	ebx, edx
	mov	DWORD PTR v$7[rbp-129], ebx

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	rbx, QWORD PTR [rdi+128]
	sub	rbx, QWORD PTR [rdi+112]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1176 :       currentValue().setOffsetStart(current_ - begin_ - 1);

	dec	rbx
	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rax+24], rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1177 :       currentValue().setOffsetLimit(current_ - begin_);

	mov	rbx, QWORD PTR [rdi+128]
$LN587@readValue:
	sub	rbx, QWORD PTR [rdi+112]
	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1422 : void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

	mov	QWORD PTR [rax+32], rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1178 :       break;

	lea	rcx, QWORD PTR v$7[rbp-137]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
$LN15@readValue:

; 1184 :   }
; 1185 : 
; 1186 :   if (collectComments_) {

	cmp	BYTE PTR [rdi+196], r14b
	je	SHORT $LN1@readValue

; 1187 :     lastValueEnd_ = current_;

	mov	rax, QWORD PTR [rdi+128]
	mov	QWORD PTR [rdi+136], rax

; 1188 :     lastValue_ = &currentValue();

	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
	mov	QWORD PTR [rdi+144], rax
$LN1@readValue:

; 1189 :   }
; 1190 : 
; 1191 :   return successful;

	movzx	eax, r15b
	jmp	$LN19@readValue
$LN3@readValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T3[rbp-137]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T6[rbp-137]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN351@readValue
	mov	r8, r14
	jmp	SHORT $LN352@readValue
$LN351@readValue:
	mov	r8, QWORD PTR [r8]
$LN352@readValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 1179 :     } // else, fall through ...
; 1180 :   default:
; 1181 :     currentValue().setOffsetStart(token.start_ - begin_);

	mov	rax, QWORD PTR token$[rbp-129]
	sub	rax, QWORD PTR [rdi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rdx+24], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T5[rbp-137]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T2[rbp-137]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN369@readValue
	mov	r8, r14
	jmp	SHORT $LN370@readValue
$LN369@readValue:
	mov	r8, QWORD PTR [r8]
$LN370@readValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 1182 :     currentValue().setOffsetLimit(token.end_ - begin_);

	mov	rax, QWORD PTR token$[rbp-121]
	sub	rax, QWORD PTR [rdi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1422 : void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

	mov	QWORD PTR [rdx+32], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T14[rbp-113], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T14[rbp-121], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T14[rbp-137], r14b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 46					; 0000002eH
	lea	rdx, OFFSET FLAT:??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
	lea	rcx, QWORD PTR $T14[rbp-137]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR info$4[rbp-89], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$4[rbp-97], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$4[rbp-113], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1759 :   info.token_ = token;

	movups	xmm0, XMMWORD PTR token$[rbp-137]
	movaps	XMMWORD PTR info$4[rbp-137], xmm0
	movsdx	xmm1, QWORD PTR token$[rbp-121]
	movsdx	QWORD PTR info$4[rbp-121], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T14[rbp-137]
	lea	rcx, QWORD PTR info$4[rbp-113]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1761 :   info.extra_ = extra;

	mov	QWORD PTR info$4[rbp-81], r14

; 1762 :   errors_.push_back(info);

	lea	rcx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR info$4[rbp-137]
	call	?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$4[rbp-89], 16
	jb	SHORT $LN538@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$4[rbp-113]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN538@readValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T14[rbp-113], 16
	jb	SHORT $LN570@readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T14[rbp-137]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN570@readValue:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1183 :     return addError("Syntax error: value, object or array expected.", token);

	xor	al, al
$LN19@readValue:

; 1192 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-137]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rdi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
$LN586@readValue:
	npad	2
$LN585@readValue:
	DD	$LN14@readValue
	DD	$LN4@readValue
	DD	$LN13@readValue
	DD	$LN4@readValue
	DD	$LN11@readValue
	DD	$LN12@readValue
	DD	$LN10@readValue
	DD	$LN9@readValue
	DD	$LN8@readValue
	DD	$LN7@readValue
	DD	$LN6@readValue
	DD	$LN5@readValue
	DD	$LN4@readValue
?readValue@OurReader@Json@@AEAA_NXZ ENDP		; Json::OurReader::readValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
$T1 = 56
$T2 = 64
$T3 = 64
info$4 = 96
$T5 = 96
$T6 = 96
v$7 = 96
v$8 = 96
v$9 = 96
v$10 = 96
v$11 = 96
v$12 = 96
v$13 = 96
$T14 = 160
$T15 = 160
__$ArrayPad$ = 192
this$ = 240
?dtor$0@?0??readValue@OurReader@Json@@AEAA_NXZ@4HA PROC	; `Json::OurReader::readValue'::`1'::dtor$0
	lea	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??readValue@OurReader@Json@@AEAA_NXZ@4HA ENDP	; `Json::OurReader::readValue'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
$T1 = 56
$T2 = 64
$T3 = 64
info$4 = 96
$T5 = 96
$T6 = 96
v$7 = 96
v$8 = 96
v$9 = 96
v$10 = 96
v$11 = 96
v$12 = 96
v$13 = 96
$T14 = 160
$T15 = 160
__$ArrayPad$ = 192
this$ = 240
?dtor$8@?0??readValue@OurReader@Json@@AEAA_NXZ@4HA PROC	; `Json::OurReader::readValue'::`1'::dtor$8
	lea	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??readValue@OurReader@Json@@AEAA_NXZ@4HA ENDP	; `Json::OurReader::readValue'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
token$ = 32
$T1 = 56
$T2 = 64
$T3 = 64
info$4 = 96
$T5 = 96
$T6 = 96
v$7 = 96
v$8 = 96
v$9 = 96
v$10 = 96
v$11 = 96
v$12 = 96
v$13 = 96
$T14 = 160
$T15 = 160
__$ArrayPad$ = 192
this$ = 240
?dtor$19@?0??readValue@OurReader@Json@@AEAA_NXZ@4HA PROC ; `Json::OurReader::readValue'::`1'::dtor$19
	lea	rcx, QWORD PTR info$4[rdx]
	jmp	??1ErrorInfo@OurReader@Json@@QEAA@XZ
?dtor$19@?0??readValue@OurReader@Json@@AEAA_NXZ@4HA ENDP ; `Json::OurReader::readValue'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?skipCommentTokens@OurReader@Json@@AEAAXAEAVToken@12@@Z
_TEXT	SEGMENT
this$ = 48
token$ = 56
?skipCommentTokens@OurReader@Json@@AEAAXAEAVToken@12@@Z PROC ; Json::OurReader::skipCommentTokens, COMDAT

; 1194 : void OurReader::skipCommentTokens(Token& token) {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1195 :   if (features_.allowComments_) {

	cmp	BYTE PTR [rcx+184], 0
	mov	rbx, rdx
	mov	rdi, rcx
	je	SHORT $LN5@skipCommen
	npad	7
$LL4@skipCommen:

; 1196 :     do {
; 1197 :       readToken(token);

	mov	rdx, rbx
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken

; 1198 :     } while (token.type_ == tokenComment);

	cmp	DWORD PTR [rbx], 15
	je	SHORT $LL4@skipCommen

; 1201 :   }
; 1202 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@skipCommen:
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1199 :   } else {
; 1200 :     readToken(token);

	jmp	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
?skipCommentTokens@OurReader@Json@@AEAAXAEAVToken@12@@Z ENDP ; Json::OurReader::skipCommentTokens
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z
_TEXT	SEGMENT
this$ = 48
token$ = 56
?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z PROC	; Json::OurReader::readToken, COMDAT

; 1204 : bool OurReader::readToken(Token& token) {

$LN159:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 1303 : 
; 1304 : void OurReader::skipSpaces() {
; 1305 :   while (current_ != end_) {

	mov	rdx, QWORD PTR [rcx+120]

; 1204 : bool OurReader::readToken(Token& token) {

	mov	rbx, rcx

; 1303 : 
; 1304 : void OurReader::skipSpaces() {
; 1305 :   while (current_ != end_) {

	cmp	QWORD PTR [rcx+128], rdx
	je	SHORT $LN151@readToken
	mov	r8, 4294977024				; 0000000100002600H
	npad	9
$LL37@readToken:

; 1306 :     Char c = *current_;

	mov	rcx, QWORD PTR [rbx+128]
	movzx	eax, BYTE PTR [rcx]
	cmp	al, 32					; 00000020H
	ja	SHORT $LN151@readToken
	bt	r8, rax
	jae	SHORT $LN151@readToken

; 1307 :     if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
; 1308 :       ++current_;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx+128], rax
	cmp	rax, rdx
	jne	SHORT $LL37@readToken
$LN151@readToken:

; 1205 :   skipSpaces();
; 1206 :   token.start_ = current_;

	mov	rax, QWORD PTR [rbx+128]
	mov	QWORD PTR [rdi+8], rax

; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)

	mov	rax, QWORD PTR [rbx+128]
	cmp	rax, QWORD PTR [rbx+120]
	jne	SHORT $LN40@readToken

; 1790 :     return 0;

	xor	cl, cl
	jmp	SHORT $LN41@readToken
$LN40@readToken:

; 1791 :   return *current_++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+128], rax
$LN41@readToken:

; 1207 :   Char c = getNextChar();
; 1208 :   bool ok = true;
; 1209 :   switch (c) {

	movsx	rax, cl
	cmp	eax, 125				; 0000007dH
	ja	$LN147@readToken
	lea	r10, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN149@readToken[r10+rax]
	mov	ecx, DWORD PTR $LN150@readToken[r10+rax*4]
	add	rcx, r10
	jmp	rcx
$LN26@readToken:

; 1210 :   case '{':
; 1211 :     token.type_ = tokenObjectBegin;

	mov	DWORD PTR [rdi], 1

; 1212 :     break;

	jmp	$LN1@readToken
$LN25@readToken:

; 1213 :   case '}':
; 1214 :     token.type_ = tokenObjectEnd;

	mov	edx, 2
	mov	DWORD PTR [rdi], edx

; 1215 :     break;

	jmp	$LN1@readToken
$LN24@readToken:

; 1216 :   case '[':
; 1217 :     token.type_ = tokenArrayBegin;

	mov	edx, 3
	mov	DWORD PTR [rdi], edx

; 1218 :     break;

	jmp	$LN1@readToken
$LN23@readToken:

; 1219 :   case ']':
; 1220 :     token.type_ = tokenArrayEnd;

	mov	edx, 4
	mov	DWORD PTR [rdi], edx

; 1221 :     break;

	jmp	$LN1@readToken
$LN22@readToken:

; 1222 :   case '"':
; 1223 :     token.type_ = tokenString;

	mov	DWORD PTR [rdi], 5

; 1322 :   return true;
; 1323 : }
; 1324 : 
; 1325 : bool OurReader::readComment() {
; 1326 :   Location commentBegin = current_ - 1;
; 1327 :   Char c = getNextChar();
; 1328 :   bool successful = false;
; 1329 :   if (c == '*')
; 1330 :     successful = readCStyleComment();
; 1331 :   else if (c == '/')
; 1332 :     successful = readCppStyleComment();
; 1333 :   if (!successful)
; 1334 :     return false;
; 1335 : 
; 1336 :   if (collectComments_) {
; 1337 :     CommentPlacement placement = commentBefore;
; 1338 :     if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
; 1339 :       if (c != '*' || !containsNewLine(commentBegin, current_))
; 1340 :         placement = commentAfterOnSameLine;
; 1341 :     }
; 1342 : 
; 1343 :     addComment(commentBegin, current_, placement);
; 1344 :   }
; 1345 :   return true;
; 1346 : }
; 1347 : 
; 1348 : void
; 1349 : OurReader::addComment(Location begin, Location end, CommentPlacement placement) {
; 1350 :   assert(collectComments_);
; 1351 :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
; 1352 :   if (placement == commentAfterOnSameLine) {
; 1353 :     assert(lastValue_ != 0);
; 1354 :     lastValue_->setComment(normalized, placement);
; 1355 :   } else {
; 1356 :     commentsBefore_ += normalized;
; 1357 :   }
; 1358 : }
; 1359 : 
; 1360 : bool OurReader::readCStyleComment() {
; 1361 :   while ((current_ + 1) < end_) {
; 1362 :     Char c = getNextChar();
; 1363 :     if (c == '*' && *current_ == '/')
; 1364 :       break;
; 1365 :   }
; 1366 :   return getNextChar() == '/';
; 1367 : }
; 1368 : 
; 1369 : bool OurReader::readCppStyleComment() {
; 1370 :   while (current_ != end_) {
; 1371 :     Char c = getNextChar();
; 1372 :     if (c == '\n')
; 1373 :       break;
; 1374 :     if (c == '\r') {
; 1375 :       // Consume DOS EOL. It will be normalized in addComment.
; 1376 :       if (current_ != end_ && *current_ == '\n')
; 1377 :         getNextChar();
; 1378 :       // Break on Moc OS 9 EOL.
; 1379 :       break;
; 1380 :     }
; 1381 :   }
; 1382 :   return true;
; 1383 : }
; 1384 : 
; 1385 : bool OurReader::readNumber(bool checkInf) {
; 1386 :   const char *p = current_;
; 1387 :   if (checkInf && p != end_ && *p == 'I') {
; 1388 :     current_ = ++p;
; 1389 :     return false;
; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character
; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')
; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1395 :   // fractional part
; 1396 :   if (c == '.') {
; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1398 :     while (c >= '0' && c <= '9')
; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1406 :     while (c >= '0' && c <= '9')
; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1408 :   }
; 1409 :   return true;
; 1410 : }
; 1411 : bool OurReader::readString() {
; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {

	mov	rax, QWORD PTR [rbx+128]
	mov	rdx, QWORD PTR [rbx+120]
	xor	cl, cl
	cmp	rax, rdx
	je	SHORT $LN152@readToken
$LN50@readToken:

; 1791 :   return *current_++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+128], rax

; 1414 :     c = getNextChar();
; 1415 :     if (c == '\\')

	cmp	cl, 92					; 0000005cH
	jne	SHORT $LN45@readToken

; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)

	cmp	rax, rdx
	je	SHORT $LN43@readToken

; 1791 :   return *current_++;

	inc	rax
	mov	QWORD PTR [rbx+128], rax

; 1416 :       getNextChar();
; 1417 :     else if (c == '"')

	jmp	SHORT $LN43@readToken
$LN45@readToken:
	cmp	cl, 34					; 00000022H
	je	SHORT $LN154@readToken
$LN43@readToken:

; 1322 :   return true;
; 1323 : }
; 1324 : 
; 1325 : bool OurReader::readComment() {
; 1326 :   Location commentBegin = current_ - 1;
; 1327 :   Char c = getNextChar();
; 1328 :   bool successful = false;
; 1329 :   if (c == '*')
; 1330 :     successful = readCStyleComment();
; 1331 :   else if (c == '/')
; 1332 :     successful = readCppStyleComment();
; 1333 :   if (!successful)
; 1334 :     return false;
; 1335 : 
; 1336 :   if (collectComments_) {
; 1337 :     CommentPlacement placement = commentBefore;
; 1338 :     if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
; 1339 :       if (c != '*' || !containsNewLine(commentBegin, current_))
; 1340 :         placement = commentAfterOnSameLine;
; 1341 :     }
; 1342 : 
; 1343 :     addComment(commentBegin, current_, placement);
; 1344 :   }
; 1345 :   return true;
; 1346 : }
; 1347 : 
; 1348 : void
; 1349 : OurReader::addComment(Location begin, Location end, CommentPlacement placement) {
; 1350 :   assert(collectComments_);
; 1351 :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
; 1352 :   if (placement == commentAfterOnSameLine) {
; 1353 :     assert(lastValue_ != 0);
; 1354 :     lastValue_->setComment(normalized, placement);
; 1355 :   } else {
; 1356 :     commentsBefore_ += normalized;
; 1357 :   }
; 1358 : }
; 1359 : 
; 1360 : bool OurReader::readCStyleComment() {
; 1361 :   while ((current_ + 1) < end_) {
; 1362 :     Char c = getNextChar();
; 1363 :     if (c == '*' && *current_ == '/')
; 1364 :       break;
; 1365 :   }
; 1366 :   return getNextChar() == '/';
; 1367 : }
; 1368 : 
; 1369 : bool OurReader::readCppStyleComment() {
; 1370 :   while (current_ != end_) {
; 1371 :     Char c = getNextChar();
; 1372 :     if (c == '\n')
; 1373 :       break;
; 1374 :     if (c == '\r') {
; 1375 :       // Consume DOS EOL. It will be normalized in addComment.
; 1376 :       if (current_ != end_ && *current_ == '\n')
; 1377 :         getNextChar();
; 1378 :       // Break on Moc OS 9 EOL.
; 1379 :       break;
; 1380 :     }
; 1381 :   }
; 1382 :   return true;
; 1383 : }
; 1384 : 
; 1385 : bool OurReader::readNumber(bool checkInf) {
; 1386 :   const char *p = current_;
; 1387 :   if (checkInf && p != end_ && *p == 'I') {
; 1388 :     current_ = ++p;
; 1389 :     return false;
; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character
; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')
; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1395 :   // fractional part
; 1396 :   if (c == '.') {
; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1398 :     while (c >= '0' && c <= '9')
; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1406 :     while (c >= '0' && c <= '9')
; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1408 :   }
; 1409 :   return true;
; 1410 : }
; 1411 : bool OurReader::readString() {
; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {

	mov	rax, QWORD PTR [rbx+128]
	cmp	rax, rdx
	jne	SHORT $LN50@readToken
$LN152@readToken:

; 1418 :       break;
; 1419 :   }
; 1420 :   return c == '"';

	cmp	cl, 34					; 00000022H
$LN154@readToken:
	sete	al

; 1224 :     ok = readString();
; 1225 :     break;

	jmp	SHORT $LN27@readToken
$LN21@readToken:

; 1226 :   case '\'':
; 1227 :     if (features_.allowSingleQuotes_) {

	cmp	BYTE PTR [rbx+188], 0
	je	SHORT $LN20@readToken

; 1228 :     token.type_ = tokenString;

	mov	DWORD PTR [rdi], 5

; 1421 : }
; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {

	mov	rax, QWORD PTR [rbx+128]
	mov	rdx, QWORD PTR [rbx+120]
	xor	cl, cl
	cmp	rax, rdx
	je	SHORT $LN153@readToken
$LN63@readToken:

; 1791 :   return *current_++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+128], rax

; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')

	cmp	cl, 92					; 0000005cH
	jne	SHORT $LN58@readToken

; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)

	cmp	rax, rdx
	je	SHORT $LN56@readToken

; 1791 :   return *current_++;

	inc	rax
	mov	QWORD PTR [rbx+128], rax

; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')

	jmp	SHORT $LN56@readToken
$LN58@readToken:
	cmp	cl, 39					; 00000027H
	je	SHORT $LN156@readToken
$LN56@readToken:

; 1421 : }
; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {

	mov	rax, QWORD PTR [rbx+128]
	cmp	rax, rdx
	jne	SHORT $LN63@readToken
$LN153@readToken:

; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';

	cmp	cl, 39					; 00000027H
$LN156@readToken:
	sete	al

; 1229 :     ok = readStringSingleQuote();
; 1230 :     break;

	jmp	SHORT $LN27@readToken
$LN20@readToken:

; 1231 :     } // else continue
; 1232 :   case '/':
; 1233 :     token.type_ = tokenComment;
; 1234 :     ok = readComment();

	mov	rcx, rbx
	mov	DWORD PTR [rdi], 15
	call	?readComment@OurReader@Json@@AEAA_NXZ	; Json::OurReader::readComment
$LN27@readToken:

; 1294 :   default:
; 1295 :     ok = false;
; 1296 :     break;
; 1297 :   }
; 1298 :   if (!ok)

	test	al, al
	jne	SHORT $LN1@readToken
$LN147@readToken:

; 1299 :     token.type_ = tokenError;

	mov	DWORD PTR [rdi], 16
$LN1@readToken:

; 1300 :   token.end_ = current_;

	mov	rax, QWORD PTR [rbx+128]

; 1301 :   return true;
; 1302 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	mov	al, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN18@readToken:

; 1235 :     break;
; 1236 :   case '0':
; 1237 :   case '1':
; 1238 :   case '2':
; 1239 :   case '3':
; 1240 :   case '4':
; 1241 :   case '5':
; 1242 :   case '6':
; 1243 :   case '7':
; 1244 :   case '8':
; 1245 :   case '9':
; 1246 :     token.type_ = tokenNumber;
; 1247 :     readNumber(false);

	xor	edx, edx
	mov	rcx, rbx
	mov	DWORD PTR [rdi], 6
	call	?readNumber@OurReader@Json@@AEAA_N_N@Z	; Json::OurReader::readNumber

; 1248 :     break;

	jmp	SHORT $LN1@readToken
$LN17@readToken:

; 1249 :   case '-':
; 1250 :     if (readNumber(true)) {

	mov	dl, 1
	mov	rcx, rbx
	call	?readNumber@OurReader@Json@@AEAA_N_N@Z	; Json::OurReader::readNumber
	test	al, al
	je	SHORT $LN16@readToken

; 1251 :       token.type_ = tokenNumber;

	mov	DWORD PTR [rdi], 6

; 1252 :     } else {

	jmp	SHORT $LN1@readToken
$LN16@readToken:

; 1253 :       token.type_ = tokenNegInf;

	mov	DWORD PTR [rdi], 12

; 1254 :       ok = features_.allowSpecialFloats_ && match("nfinity", 7);

	cmp	BYTE PTR [rbx+191], 0
	je	SHORT $LN147@readToken

; 1309 :     else
; 1310 :       break;
; 1311 :   }
; 1312 : }
; 1313 : 
; 1314 : bool OurReader::match(Location pattern, int patternLength) {
; 1315 :   if (end_ - current_ < patternLength)

	mov	r8, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r8
	cmp	rax, 7
	jl	SHORT $LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	lea	rcx, OFFSET FLAT:??_C@_07FFAIMGME@nfinity?$AA@+7
	mov	r9, r8
	mov	edx, 7
	sub	r9, rcx
	npad	12
$LL71@readToken:
	dec	rdx

; 1319 :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_07FFAIMGME@nfinity?$AA@[r10]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r9+rcx+7], al
	jne	$LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL71@readToken

; 1320 :       return false;
; 1321 :   current_ += patternLength;

	lea	rax, QWORD PTR [r8+7]
	mov	QWORD PTR [rbx+128], rax

; 1254 :       ok = features_.allowSpecialFloats_ && match("nfinity", 7);

	jmp	$LN1@readToken
$LN14@readToken:

; 1255 :     }
; 1256 :     break;
; 1257 :   case 't':
; 1258 :     token.type_ = tokenTrue;

	mov	edx, 7
	mov	DWORD PTR [rdi], edx

; 1309 :     else
; 1310 :       break;
; 1311 :   }
; 1312 : }
; 1313 : 
; 1314 : bool OurReader::match(Location pattern, int patternLength) {
; 1315 :   if (end_ - current_ < patternLength)

	mov	r8, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r8
	cmp	rax, 3
	jl	$LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	lea	rcx, OFFSET FLAT:??_C@_03FFDNHNKN@rue?$AA@+3
	mov	r9, r8
	mov	edx, 3
	sub	r9, rcx
	npad	15
$LL77@readToken:
	dec	rdx

; 1319 :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_03FFDNHNKN@rue?$AA@[r10]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r9+rcx+3], al
	jne	$LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL77@readToken

; 1320 :       return false;
; 1321 :   current_ += patternLength;

	lea	rax, QWORD PTR [r8+3]
	mov	QWORD PTR [rbx+128], rax

; 1259 :     ok = match("rue", 3);
; 1260 :     break;

	jmp	$LN1@readToken
$LN13@readToken:

; 1261 :   case 'f':
; 1262 :     token.type_ = tokenFalse;

	mov	DWORD PTR [rdi], 8

; 1309 :     else
; 1310 :       break;
; 1311 :   }
; 1312 : }
; 1313 : 
; 1314 : bool OurReader::match(Location pattern, int patternLength) {
; 1315 :   if (end_ - current_ < patternLength)

	mov	r8, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r8
	cmp	rax, 4
	jl	$LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	lea	rcx, OFFSET FLAT:??_C@_04KCECFHEP@alse?$AA@+4
	mov	r9, r8
	mov	edx, 4
	sub	r9, rcx
$LL83@readToken:
	dec	rdx

; 1319 :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_04KCECFHEP@alse?$AA@[r10]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r9+rcx+4], al
	jne	$LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL83@readToken

; 1320 :       return false;
; 1321 :   current_ += patternLength;

	lea	rax, QWORD PTR [r8+4]
	mov	QWORD PTR [rbx+128], rax

; 1263 :     ok = match("alse", 4);
; 1264 :     break;

	jmp	$LN1@readToken
$LN12@readToken:

; 1265 :   case 'n':
; 1266 :     token.type_ = tokenNull;

	mov	DWORD PTR [rdi], 9

; 1309 :     else
; 1310 :       break;
; 1311 :   }
; 1312 : }
; 1313 : 
; 1314 : bool OurReader::match(Location pattern, int patternLength) {
; 1315 :   if (end_ - current_ < patternLength)

	mov	r8, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r8
	cmp	rax, 3
	jl	$LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	lea	rcx, OFFSET FLAT:??_C@_03KNPGGKC@ull?$AA@+3
	mov	r9, r8
	mov	edx, 3
	sub	r9, rcx
$LL89@readToken:
	dec	rdx

; 1319 :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_03KNPGGKC@ull?$AA@[r10]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r9+rcx+3], al
	jne	$LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL89@readToken

; 1320 :       return false;
; 1321 :   current_ += patternLength;

	lea	rax, QWORD PTR [r8+3]
	mov	QWORD PTR [rbx+128], rax

; 1267 :     ok = match("ull", 3);
; 1268 :     break;

	jmp	$LN1@readToken
$LN11@readToken:

; 1269 :   case 'N':
; 1270 :     if (features_.allowSpecialFloats_) {

	cmp	BYTE PTR [rbx+191], 0
	je	$LN147@readToken

; 1271 :       token.type_ = tokenNaN;

	mov	DWORD PTR [rdi], 10

; 1309 :     else
; 1310 :       break;
; 1311 :   }
; 1312 : }
; 1313 : 
; 1314 : bool OurReader::match(Location pattern, int patternLength) {
; 1315 :   if (end_ - current_ < patternLength)

	mov	r8, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r8
	cmp	rax, 2
	jl	$LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	lea	rcx, OFFSET FLAT:??_C@_02CHFBOFHB@aN?$AA@+2
	mov	r9, r8
	mov	edx, 2
	sub	r9, rcx
	npad	3
$LL95@readToken:
	dec	rdx

; 1319 :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_02CHFBOFHB@aN?$AA@[r10]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r9+rcx+2], al
	jne	$LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL95@readToken

; 1320 :       return false;
; 1321 :   current_ += patternLength;

	lea	rax, QWORD PTR [r8+2]
	mov	QWORD PTR [rbx+128], rax

; 1272 :       ok = match("aN", 2);
; 1273 :     } else {

	jmp	$LN1@readToken
$LN8@readToken:

; 1274 :       ok = false;
; 1275 :     }
; 1276 :     break;
; 1277 :   case 'I':
; 1278 :     if (features_.allowSpecialFloats_) {

	cmp	BYTE PTR [rbx+191], 0
	je	$LN147@readToken

; 1279 :       token.type_ = tokenPosInf;

	mov	DWORD PTR [rdi], 11

; 1309 :     else
; 1310 :       break;
; 1311 :   }
; 1312 : }
; 1313 : 
; 1314 : bool OurReader::match(Location pattern, int patternLength) {
; 1315 :   if (end_ - current_ < patternLength)

	mov	r8, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR [rbx+120]
	sub	rax, r8
	cmp	rax, 7
	jl	$LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	lea	rcx, OFFSET FLAT:??_C@_07FFAIMGME@nfinity?$AA@+7
	mov	r9, r8
	mov	edx, 7
	sub	r9, rcx
	npad	3
$LL101@readToken:
	dec	rdx

; 1319 :     if (current_[index] != pattern[index])

	lea	rcx, QWORD PTR ??_C@_07FFAIMGME@nfinity?$AA@[r10]
	add	rcx, rdx
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [r9+rcx+7], al
	jne	$LN147@readToken

; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	test	rdx, rdx
	jne	SHORT $LL101@readToken

; 1320 :       return false;
; 1321 :   current_ += patternLength;

	lea	rax, QWORD PTR [r8+7]
	mov	QWORD PTR [rbx+128], rax

; 1280 :       ok = match("nfinity", 7);
; 1281 :     } else {

	jmp	$LN1@readToken
$LN5@readToken:

; 1282 :       ok = false;
; 1283 :     }
; 1284 :     break;
; 1285 :   case ',':
; 1286 :     token.type_ = tokenArraySeparator;

	mov	DWORD PTR [rdi], 13

; 1287 :     break;

	jmp	$LN1@readToken
$LN4@readToken:

; 1288 :   case ':':
; 1289 :     token.type_ = tokenMemberSeparator;

	mov	DWORD PTR [rdi], 14

; 1290 :     break;

	jmp	$LN1@readToken
$LN3@readToken:

; 1291 :   case 0:
; 1292 :     token.type_ = tokenEndOfStream;

	mov	DWORD PTR [rdi], 0

; 1293 :     break;

	jmp	$LN1@readToken
	npad	3
$LN150@readToken:

; 1301 :   return true;
; 1302 : }

	DD	$LN3@readToken
	DD	$LN22@readToken
	DD	$LN21@readToken
	DD	$LN5@readToken
	DD	$LN17@readToken
	DD	$LN20@readToken
	DD	$LN18@readToken
	DD	$LN4@readToken
	DD	$LN8@readToken
	DD	$LN11@readToken
	DD	$LN24@readToken
	DD	$LN23@readToken
	DD	$LN13@readToken
	DD	$LN12@readToken
	DD	$LN14@readToken
	DD	$LN26@readToken
	DD	$LN25@readToken
	DD	$LN147@readToken
$LN149@readToken:
	DB	0
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	1
	DB	17
	DB	17
	DB	17
	DB	17
	DB	2
	DB	17
	DB	17
	DB	17
	DB	17
	DB	3
	DB	4
	DB	17
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	7
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	8
	DB	17
	DB	17
	DB	17
	DB	17
	DB	9
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	10
	DB	17
	DB	11
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	12
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	13
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	14
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	15
	DB	17
	DB	16
?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ENDP	; Json::OurReader::readToken
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?skipSpaces@OurReader@Json@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?skipSpaces@OurReader@Json@@AEAAXXZ PROC		; Json::OurReader::skipSpaces, COMDAT

; 1305 :   while (current_ != end_) {

	mov	r8, QWORD PTR [rcx+120]
	cmp	QWORD PTR [rcx+128], r8
	je	SHORT $LN3@skipSpaces
	mov	r9, 4294977024				; 0000000100002600H
	npad	9
$LL5@skipSpaces:

; 1306 :     Char c = *current_;

	mov	rdx, QWORD PTR [rcx+128]
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 32					; 00000020H
	ja	SHORT $LN3@skipSpaces
	bt	r9, rax
	jae	SHORT $LN3@skipSpaces

; 1307 :     if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
; 1308 :       ++current_;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rcx+128], rax
	cmp	rax, r8
	jne	SHORT $LL5@skipSpaces
$LN3@skipSpaces:

; 1309 :     else
; 1310 :       break;
; 1311 :   }
; 1312 : }

	ret	0
?skipSpaces@OurReader@Json@@AEAAXXZ ENDP		; Json::OurReader::skipSpaces
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?match@OurReader@Json@@AEAA_NPEBDH@Z
_TEXT	SEGMENT
this$ = 8
pattern$ = 16
patternLength$ = 24
?match@OurReader@Json@@AEAA_NPEBDH@Z PROC		; Json::OurReader::match, COMDAT

; 1315 :   if (end_ - current_ < patternLength)

	mov	r9, QWORD PTR [rcx+128]
	mov	rax, QWORD PTR [rcx+120]
	movsxd	r10, r8d
	sub	rax, r9
	mov	r11, rcx
	cmp	rax, r10
	jge	SHORT $LN4@match
$LN8@match:

; 1316 :     return false;

	xor	al, al

; 1323 : }

	ret	0
$LN4@match:

; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	test	r8d, r8d
	je	SHORT $LN9@match
	mov	r8, r9

; 1319 :     if (current_[index] != pattern[index])

	lea	rax, QWORD PTR [r10+rdx]
	sub	r8, rdx
	neg	rdx
	npad	2
$LL3@match:
	movzx	ecx, BYTE PTR [rax-1]
	dec	rax
	cmp	BYTE PTR [r8+rax], cl
	jne	SHORT $LN8@match

; 1317 :   int index = patternLength;
; 1318 :   while (index--)

	lea	rcx, QWORD PTR [rdx+rax]
	test	rcx, rcx
	jne	SHORT $LL3@match
$LN9@match:

; 1320 :       return false;
; 1321 :   current_ += patternLength;

	lea	rax, QWORD PTR [r10+r9]
	mov	QWORD PTR [r11+128], rax

; 1322 :   return true;

	mov	al, 1

; 1323 : }

	ret	0
?match@OurReader@Json@@AEAA_NPEBDH@Z ENDP		; Json::OurReader::match
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readComment@OurReader@Json@@AEAA_NXZ
_TEXT	SEGMENT
this$ = 48
?readComment@OurReader@Json@@AEAA_NXZ PROC		; Json::OurReader::readComment, COMDAT

; 1325 : bool OurReader::readComment() {

$LN81:
	sub	rsp, 40					; 00000028H

; 1326 :   Location commentBegin = current_ - 1;

	mov	rax, QWORD PTR [rcx+128]

; 1377 :         getNextChar();
; 1378 :       // Break on Moc OS 9 EOL.
; 1379 :       break;
; 1380 :     }
; 1381 :   }
; 1382 :   return true;
; 1383 : }
; 1384 : 
; 1385 : bool OurReader::readNumber(bool checkInf) {
; 1386 :   const char *p = current_;
; 1387 :   if (checkInf && p != end_ && *p == 'I') {
; 1388 :     current_ = ++p;
; 1389 :     return false;
; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character
; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')
; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1395 :   // fractional part
; 1396 :   if (c == '.') {
; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1398 :     while (c >= '0' && c <= '9')
; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1406 :     while (c >= '0' && c <= '9')
; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1408 :   }
; 1409 :   return true;
; 1410 : }
; 1411 : bool OurReader::readString() {
; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {
; 1414 :     c = getNextChar();
; 1415 :     if (c == '\\')
; 1416 :       getNextChar();
; 1417 :     else if (c == '"')
; 1418 :       break;
; 1419 :   }
; 1420 :   return c == '"';
; 1421 : }
; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {
; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')
; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')
; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';
; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)

	mov	rdx, QWORD PTR [rcx+120]

; 1326 :   Location commentBegin = current_ - 1;

	lea	r11, QWORD PTR [rax-1]

; 1377 :         getNextChar();
; 1378 :       // Break on Moc OS 9 EOL.
; 1379 :       break;
; 1380 :     }
; 1381 :   }
; 1382 :   return true;
; 1383 : }
; 1384 : 
; 1385 : bool OurReader::readNumber(bool checkInf) {
; 1386 :   const char *p = current_;
; 1387 :   if (checkInf && p != end_ && *p == 'I') {
; 1388 :     current_ = ++p;
; 1389 :     return false;
; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character
; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')
; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1395 :   // fractional part
; 1396 :   if (c == '.') {
; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1398 :     while (c >= '0' && c <= '9')
; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1406 :     while (c >= '0' && c <= '9')
; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1408 :   }
; 1409 :   return true;
; 1410 : }
; 1411 : bool OurReader::readString() {
; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {
; 1414 :     c = getNextChar();
; 1415 :     if (c == '\\')
; 1416 :       getNextChar();
; 1417 :     else if (c == '"')
; 1418 :       break;
; 1419 :   }
; 1420 :   return c == '"';
; 1421 : }
; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {
; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')
; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')
; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';
; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)

	cmp	rax, rdx
	je	SHORT $LN71@readCommen

; 1791 :   return *current_++;

	movzx	r9d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 1327 :   Char c = getNextChar();
; 1328 :   bool successful = false;
; 1329 :   if (c == '*')

	cmp	r9b, 42					; 0000002aH
	jne	SHORT $LN8@readCommen

; 1347 : 
; 1348 : void
; 1349 : OurReader::addComment(Location begin, Location end, CommentPlacement placement) {
; 1350 :   assert(collectComments_);
; 1351 :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
; 1352 :   if (placement == commentAfterOnSameLine) {
; 1353 :     assert(lastValue_ != 0);
; 1354 :     lastValue_->setComment(normalized, placement);
; 1355 :   } else {
; 1356 :     commentsBefore_ += normalized;
; 1357 :   }
; 1358 : }
; 1359 : 
; 1360 : bool OurReader::readCStyleComment() {
; 1361 :   while ((current_ + 1) < end_) {

	inc	rax
	cmp	rax, rdx
	jae	SHORT $LN56@readCommen
$LL16@readCommen:

; 1377 :         getNextChar();
; 1378 :       // Break on Moc OS 9 EOL.
; 1379 :       break;
; 1380 :     }
; 1381 :   }
; 1382 :   return true;
; 1383 : }
; 1384 : 
; 1385 : bool OurReader::readNumber(bool checkInf) {
; 1386 :   const char *p = current_;
; 1387 :   if (checkInf && p != end_ && *p == 'I') {
; 1388 :     current_ = ++p;
; 1389 :     return false;
; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character
; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')
; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1395 :   // fractional part
; 1396 :   if (c == '.') {
; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1398 :     while (c >= '0' && c <= '9')
; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1406 :     while (c >= '0' && c <= '9')
; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1408 :   }
; 1409 :   return true;
; 1410 : }
; 1411 : bool OurReader::readString() {
; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {
; 1414 :     c = getNextChar();
; 1415 :     if (c == '\\')
; 1416 :       getNextChar();
; 1417 :     else if (c == '"')
; 1418 :       break;
; 1419 :   }
; 1420 :   return c == '"';
; 1421 : }
; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {
; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')
; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')
; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';
; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)

	mov	r8, QWORD PTR [rcx+128]
	cmp	r8, rdx
	je	SHORT $LN14@readCommen

; 1791 :   return *current_++;

	movzx	eax, BYTE PTR [r8]
	inc	r8
	mov	QWORD PTR [rcx+128], r8

; 1362 :     Char c = getNextChar();
; 1363 :     if (c == '*' && *current_ == '/')

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN14@readCommen
	cmp	BYTE PTR [r8], 47			; 0000002fH
	je	SHORT $LN56@readCommen
$LN14@readCommen:

; 1347 : 
; 1348 : void
; 1349 : OurReader::addComment(Location begin, Location end, CommentPlacement placement) {
; 1350 :   assert(collectComments_);
; 1351 :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
; 1352 :   if (placement == commentAfterOnSameLine) {
; 1353 :     assert(lastValue_ != 0);
; 1354 :     lastValue_->setComment(normalized, placement);
; 1355 :   } else {
; 1356 :     commentsBefore_ += normalized;
; 1357 :   }
; 1358 : }
; 1359 : 
; 1360 : bool OurReader::readCStyleComment() {
; 1361 :   while ((current_ + 1) < end_) {

	mov	rax, QWORD PTR [rcx+128]
	inc	rax
	cmp	rax, rdx
	jb	SHORT $LL16@readCommen
$LN56@readCommen:

; 1377 :         getNextChar();
; 1378 :       // Break on Moc OS 9 EOL.
; 1379 :       break;
; 1380 :     }
; 1381 :   }
; 1382 :   return true;
; 1383 : }
; 1384 : 
; 1385 : bool OurReader::readNumber(bool checkInf) {
; 1386 :   const char *p = current_;
; 1387 :   if (checkInf && p != end_ && *p == 'I') {
; 1388 :     current_ = ++p;
; 1389 :     return false;
; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character
; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')
; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1395 :   // fractional part
; 1396 :   if (c == '.') {
; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1398 :     while (c >= '0' && c <= '9')
; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1406 :     while (c >= '0' && c <= '9')
; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1408 :   }
; 1409 :   return true;
; 1410 : }
; 1411 : bool OurReader::readString() {
; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {
; 1414 :     c = getNextChar();
; 1415 :     if (c == '\\')
; 1416 :       getNextChar();
; 1417 :     else if (c == '"')
; 1418 :       break;
; 1419 :   }
; 1420 :   return c == '"';
; 1421 : }
; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {
; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')
; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')
; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';
; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)

	mov	rax, QWORD PTR [rcx+128]
	cmp	rax, rdx
	jne	SHORT $LN22@readCommen

; 1790 :     return 0;

	xor	dl, dl
	jmp	SHORT $LN23@readCommen
$LN22@readCommen:

; 1791 :   return *current_++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+128], rax
$LN23@readCommen:

; 1364 :       break;
; 1365 :   }
; 1366 :   return getNextChar() == '/';

	cmp	dl, 47					; 0000002fH
	sete	al

; 1332 :     successful = readCppStyleComment();
; 1333 :   if (!successful)

	test	al, al
	jne	SHORT $LN5@readCommen
$LN71@readCommen:

; 1334 :     return false;

	xor	al, al

; 1346 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@readCommen:

; 1330 :     successful = readCStyleComment();
; 1331 :   else if (c == '/')

	cmp	r9b, 47					; 0000002fH
	jne	SHORT $LN71@readCommen

; 1367 : }
; 1368 : 
; 1369 : bool OurReader::readCppStyleComment() {
; 1370 :   while (current_ != end_) {

	cmp	rax, rdx
	je	SHORT $LN5@readCommen
$LN79@readCommen:

; 1791 :   return *current_++;

	movzx	r8d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 1371 :     Char c = getNextChar();
; 1372 :     if (c == '\n')

	cmp	r8b, 10
	je	SHORT $LN5@readCommen

; 1373 :       break;
; 1374 :     if (c == '\r') {

	cmp	r8b, 13
	je	SHORT $LN58@readCommen

; 1367 : }
; 1368 : 
; 1369 : bool OurReader::readCppStyleComment() {
; 1370 :   while (current_ != end_) {

	cmp	rax, rdx
	jne	SHORT $LN79@readCommen

; 86   :     if (*begin == '\n' || *begin == '\r')

	jmp	SHORT $LN5@readCommen
$LN58@readCommen:

; 1375 :       // Consume DOS EOL. It will be normalized in addComment.
; 1376 :       if (current_ != end_ && *current_ == '\n')

	cmp	rax, rdx
	je	SHORT $LN5@readCommen
	cmp	BYTE PTR [rax], 10
	jne	SHORT $LN5@readCommen

; 1791 :   return *current_++;

	inc	rax
	mov	QWORD PTR [rcx+128], rax
$LN5@readCommen:

; 1335 : 
; 1336 :   if (collectComments_) {

	cmp	BYTE PTR [rcx+196], 0
	je	SHORT $LN4@readCommen

; 1337 :     CommentPlacement placement = commentBefore;
; 1338 :     if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {

	mov	rax, QWORD PTR [rcx+136]
	xor	r10d, r10d
	test	rax, rax
	je	SHORT $LN2@readCommen

; 85   :   for (; begin < end; ++begin)

	cmp	rax, r11
	jae	SHORT $LN40@readCommen
$LL42@readCommen:

; 86   :     if (*begin == '\n' || *begin == '\r')

	movzx	edx, BYTE PTR [rax]
	cmp	dl, 10
	je	SHORT $LN2@readCommen
	cmp	dl, 13
	je	SHORT $LN2@readCommen

; 85   :   for (; begin < end; ++begin)

	inc	rax
	cmp	rax, r11
	jb	SHORT $LL42@readCommen
$LN40@readCommen:

; 1339 :       if (c != '*' || !containsNewLine(commentBegin, current_))

	cmp	r9b, 42					; 0000002aH
	jne	SHORT $LN47@readCommen

; 85   :   for (; begin < end; ++begin)

	mov	r9, QWORD PTR [rcx+128]

; 1339 :       if (c != '*' || !containsNewLine(commentBegin, current_))

	mov	rax, r11

; 85   :   for (; begin < end; ++begin)

	cmp	r11, r9
	jae	SHORT $LN47@readCommen
	npad	4
$LL49@readCommen:

; 86   :     if (*begin == '\n' || *begin == '\r')

	movzx	r8d, BYTE PTR [rax]
	cmp	r8b, 10
	je	SHORT $LN2@readCommen
	cmp	r8b, 13
	je	SHORT $LN2@readCommen

; 85   :   for (; begin < end; ++begin)

	inc	rax
	cmp	rax, r9
	jb	SHORT $LL49@readCommen
$LN47@readCommen:

; 1340 :         placement = commentAfterOnSameLine;

	mov	r10d, 1
$LN2@readCommen:

; 1341 :     }
; 1342 : 
; 1343 :     addComment(commentBegin, current_, placement);

	mov	r8, QWORD PTR [rcx+128]
	mov	r9d, r10d
	mov	rdx, r11
	call	?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z ; Json::OurReader::addComment
$LN4@readCommen:

; 1344 :   }
; 1345 :   return true;

	mov	al, 1

; 1346 : }

	add	rsp, 40					; 00000028H
	ret	0
?readComment@OurReader@Json@@AEAA_NXZ ENDP		; Json::OurReader::readComment
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z
_TEXT	SEGMENT
$T1 = 32
$S2$ = 40
__$ArrayPad$ = 72
this$ = 112
begin$ = 120
end$ = 128
placement$ = 136
?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z PROC ; Json::OurReader::addComment, COMDAT

; 1349 : OurReader::addComment(Location begin, Location end, CommentPlacement placement) {

$LN54:
	push	rbx
	push	rdi
	sub	rsp, 88					; 00000058H
	mov	QWORD PTR $T1[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	ebx, r9d
	mov	rdi, rcx

; 1350 :   assert(collectComments_);
; 1351 :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);

	lea	rcx, QWORD PTR $S2$[rsp]
	call	?normalizeEOL@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD0@Z ; Json::normalizeEOL
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rdx, QWORD PTR $S2$[rsp]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1352 :   if (placement == commentAfterOnSameLine) {

	cmp	ebx, 1
	jne	SHORT $LN2@addComment
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR $S2$[rsp+24], 16
	cmovae	rdx, QWORD PTR $S2$[rsp]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1407 :   setComment(comment.c_str(), comment.length(), placement);

	mov	r9d, ebx
	mov	r8, QWORD PTR $S2$[rsp+16]
	mov	rcx, QWORD PTR [rdi+144]
	call	?setComment@Value@Json@@QEAAXPEBD_KW4CommentPlacement@2@@Z ; Json::Value::setComment
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1355 :   } else {

	jmp	SHORT $LN18@addComment
$LN2@addComment:

; 1356 :     commentsBefore_ += normalized;

	lea	rcx, QWORD PTR [rdi+152]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN18@addComment:

; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $S2$[rsp+24], 16
	jb	SHORT $LN42@addComment
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $S2$[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN42@addComment:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1358 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rbx
	ret	0
?addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z ENDP ; Json::OurReader::addComment
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$S2$ = 40
__$ArrayPad$ = 72
this$ = 112
begin$ = 120
end$ = 128
placement$ = 136
?dtor$0@?0??addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z@4HA PROC ; `Json::OurReader::addComment'::`1'::dtor$0
	lea	rcx, QWORD PTR $S2$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??addComment@OurReader@Json@@AEAAXPEBD0W4CommentPlacement@2@@Z@4HA ENDP ; `Json::OurReader::addComment'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readCStyleComment@OurReader@Json@@AEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?readCStyleComment@OurReader@Json@@AEAA_NXZ PROC	; Json::OurReader::readCStyleComment, COMDAT

; 1361 :   while ((current_ + 1) < end_) {

	mov	rax, QWORD PTR [rcx+128]
	mov	r8, QWORD PTR [rcx+120]
	lea	rdx, QWORD PTR [rax+1]
	cmp	rdx, r8
	jae	SHORT $LN13@readCStyle
$LL3@readCStyle:

; 1368 : 
; 1369 : bool OurReader::readCppStyleComment() {
; 1370 :   while (current_ != end_) {
; 1371 :     Char c = getNextChar();
; 1372 :     if (c == '\n')
; 1373 :       break;
; 1374 :     if (c == '\r') {
; 1375 :       // Consume DOS EOL. It will be normalized in addComment.
; 1376 :       if (current_ != end_ && *current_ == '\n')
; 1377 :         getNextChar();
; 1378 :       // Break on Moc OS 9 EOL.
; 1379 :       break;
; 1380 :     }
; 1381 :   }
; 1382 :   return true;
; 1383 : }
; 1384 : 
; 1385 : bool OurReader::readNumber(bool checkInf) {
; 1386 :   const char *p = current_;
; 1387 :   if (checkInf && p != end_ && *p == 'I') {
; 1388 :     current_ = ++p;
; 1389 :     return false;
; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character
; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')
; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1395 :   // fractional part
; 1396 :   if (c == '.') {
; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1398 :     while (c >= '0' && c <= '9')
; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1406 :     while (c >= '0' && c <= '9')
; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1408 :   }
; 1409 :   return true;
; 1410 : }
; 1411 : bool OurReader::readString() {
; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {
; 1414 :     c = getNextChar();
; 1415 :     if (c == '\\')
; 1416 :       getNextChar();
; 1417 :     else if (c == '"')
; 1418 :       break;
; 1419 :   }
; 1420 :   return c == '"';
; 1421 : }
; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {
; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')
; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')
; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';
; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)

	cmp	rax, r8
	je	SHORT $LN1@readCStyle

; 1791 :   return *current_++;

	movzx	eax, BYTE PTR [rax]
	mov	QWORD PTR [rcx+128], rdx

; 1362 :     Char c = getNextChar();
; 1363 :     if (c == '*' && *current_ == '/')

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN1@readCStyle
	cmp	BYTE PTR [rdx], 47			; 0000002fH
	je	SHORT $LN13@readCStyle
$LN1@readCStyle:

; 1361 :   while ((current_ + 1) < end_) {

	mov	rax, QWORD PTR [rcx+128]
	lea	rdx, QWORD PTR [rax+1]
	cmp	rdx, r8
	jb	SHORT $LL3@readCStyle
$LN13@readCStyle:

; 1368 : 
; 1369 : bool OurReader::readCppStyleComment() {
; 1370 :   while (current_ != end_) {
; 1371 :     Char c = getNextChar();
; 1372 :     if (c == '\n')
; 1373 :       break;
; 1374 :     if (c == '\r') {
; 1375 :       // Consume DOS EOL. It will be normalized in addComment.
; 1376 :       if (current_ != end_ && *current_ == '\n')
; 1377 :         getNextChar();
; 1378 :       // Break on Moc OS 9 EOL.
; 1379 :       break;
; 1380 :     }
; 1381 :   }
; 1382 :   return true;
; 1383 : }
; 1384 : 
; 1385 : bool OurReader::readNumber(bool checkInf) {
; 1386 :   const char *p = current_;
; 1387 :   if (checkInf && p != end_ && *p == 'I') {
; 1388 :     current_ = ++p;
; 1389 :     return false;
; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character
; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')
; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1395 :   // fractional part
; 1396 :   if (c == '.') {
; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1398 :     while (c >= '0' && c <= '9')
; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1406 :     while (c >= '0' && c <= '9')
; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1408 :   }
; 1409 :   return true;
; 1410 : }
; 1411 : bool OurReader::readString() {
; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {
; 1414 :     c = getNextChar();
; 1415 :     if (c == '\\')
; 1416 :       getNextChar();
; 1417 :     else if (c == '"')
; 1418 :       break;
; 1419 :   }
; 1420 :   return c == '"';
; 1421 : }
; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {
; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')
; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')
; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';
; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)

	mov	rax, QWORD PTR [rcx+128]
	cmp	rax, r8
	jne	SHORT $LN9@readCStyle

; 1790 :     return 0;

	xor	dl, dl

; 1364 :       break;
; 1365 :   }
; 1366 :   return getNextChar() == '/';

	cmp	dl, 47					; 0000002fH
	sete	al

; 1367 : }

	ret	0
$LN9@readCStyle:

; 1791 :   return *current_++;

	movzx	edx, BYTE PTR [rax]
	inc	rax

; 1364 :       break;
; 1365 :   }
; 1366 :   return getNextChar() == '/';

	cmp	dl, 47					; 0000002fH

; 1791 :   return *current_++;

	mov	QWORD PTR [rcx+128], rax

; 1364 :       break;
; 1365 :   }
; 1366 :   return getNextChar() == '/';

	sete	al

; 1367 : }

	ret	0
?readCStyleComment@OurReader@Json@@AEAA_NXZ ENDP	; Json::OurReader::readCStyleComment
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readCppStyleComment@OurReader@Json@@AEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?readCppStyleComment@OurReader@Json@@AEAA_NXZ PROC	; Json::OurReader::readCppStyleComment, COMDAT

; 1370 :   while (current_ != end_) {

	mov	rax, QWORD PTR [rcx+128]
	mov	rdx, QWORD PTR [rcx+120]
	cmp	rax, rdx
	je	SHORT $LN25@readCppSty
$LN29@readCppSty:

; 1384 : 
; 1385 : bool OurReader::readNumber(bool checkInf) {
; 1386 :   const char *p = current_;
; 1387 :   if (checkInf && p != end_ && *p == 'I') {
; 1388 :     current_ = ++p;
; 1389 :     return false;
; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character
; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')
; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1395 :   // fractional part
; 1396 :   if (c == '.') {
; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1398 :     while (c >= '0' && c <= '9')
; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1406 :     while (c >= '0' && c <= '9')
; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1408 :   }
; 1409 :   return true;
; 1410 : }
; 1411 : bool OurReader::readString() {
; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {
; 1414 :     c = getNextChar();
; 1415 :     if (c == '\\')
; 1416 :       getNextChar();
; 1417 :     else if (c == '"')
; 1418 :       break;
; 1419 :   }
; 1420 :   return c == '"';
; 1421 : }
; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {
; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')
; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')
; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';
; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)
; 1790 :     return 0;
; 1791 :   return *current_++;

	movzx	r8d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 1371 :     Char c = getNextChar();
; 1372 :     if (c == '\n')

	cmp	r8b, 10
	je	SHORT $LN25@readCppSty

; 1373 :       break;
; 1374 :     if (c == '\r') {

	cmp	r8b, 13
	je	SHORT $LN16@readCppSty

; 1370 :   while (current_ != end_) {

	cmp	rax, rdx
	jne	SHORT $LN29@readCppSty

; 1377 :         getNextChar();
; 1378 :       // Break on Moc OS 9 EOL.
; 1379 :       break;
; 1380 :     }
; 1381 :   }
; 1382 :   return true;

	mov	al, 1

; 1383 : }

	ret	0
$LN16@readCppSty:

; 1375 :       // Consume DOS EOL. It will be normalized in addComment.
; 1376 :       if (current_ != end_ && *current_ == '\n')

	cmp	rax, rdx
	je	SHORT $LN25@readCppSty
	cmp	BYTE PTR [rax], 10
	jne	SHORT $LN25@readCppSty

; 1384 : 
; 1385 : bool OurReader::readNumber(bool checkInf) {
; 1386 :   const char *p = current_;
; 1387 :   if (checkInf && p != end_ && *p == 'I') {
; 1388 :     current_ = ++p;
; 1389 :     return false;
; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character
; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')
; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1395 :   // fractional part
; 1396 :   if (c == '.') {
; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1398 :     while (c >= '0' && c <= '9')
; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1406 :     while (c >= '0' && c <= '9')
; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1408 :   }
; 1409 :   return true;
; 1410 : }
; 1411 : bool OurReader::readString() {
; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {
; 1414 :     c = getNextChar();
; 1415 :     if (c == '\\')
; 1416 :       getNextChar();
; 1417 :     else if (c == '"')
; 1418 :       break;
; 1419 :   }
; 1420 :   return c == '"';
; 1421 : }
; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {
; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')
; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')
; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';
; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)
; 1790 :     return 0;
; 1791 :   return *current_++;

	inc	rax
	mov	QWORD PTR [rcx+128], rax
$LN25@readCppSty:

; 1377 :         getNextChar();
; 1378 :       // Break on Moc OS 9 EOL.
; 1379 :       break;
; 1380 :     }
; 1381 :   }
; 1382 :   return true;

	mov	al, 1

; 1383 : }

	ret	0
?readCppStyleComment@OurReader@Json@@AEAA_NXZ ENDP	; Json::OurReader::readCppStyleComment
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readNumber@OurReader@Json@@AEAA_N_N@Z
_TEXT	SEGMENT
this$ = 8
checkInf$ = 16
?readNumber@OurReader@Json@@AEAA_N_N@Z PROC		; Json::OurReader::readNumber, COMDAT

; 1386 :   const char *p = current_;

	mov	rax, QWORD PTR [rcx+128]
	mov	r8, rcx

; 1387 :   if (checkInf && p != end_ && *p == 'I') {

	test	dl, dl
	je	SHORT $LN12@readNumber
	cmp	rax, QWORD PTR [rcx+120]
	je	SHORT $LN12@readNumber
	cmp	BYTE PTR [rax], 73			; 00000049H
	jne	SHORT $LN12@readNumber

; 1388 :     current_ = ++p;

	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 1389 :     return false;

	xor	al, al

; 1410 : }

	ret	0
$LN12@readNumber:

; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character

	mov	cl, 48					; 00000030H
$LL11@readNumber:

; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')

	cmp	cl, 57					; 00000039H
	jg	SHORT $LN10@readNumber

; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';

	mov	QWORD PTR [r8+128], rax
	cmp	rax, QWORD PTR [r8+120]
	jae	$LN25@readNumber
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	cmp	cl, 48					; 00000030H
	jge	SHORT $LL11@readNumber
$LN10@readNumber:

; 1395 :   // fractional part
; 1396 :   if (c == '.') {

	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN7@readNumber

; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';

	mov	rdx, QWORD PTR [r8+120]
	mov	QWORD PTR [r8+128], rax
	cmp	rax, rdx
	jae	$LN25@readNumber
	movzx	ecx, BYTE PTR [rax]
	inc	rax

; 1398 :     while (c >= '0' && c <= '9')

	cmp	cl, 48					; 00000030H
	jl	SHORT $LN7@readNumber
	npad	3
$LL8@readNumber:
	cmp	cl, 57					; 00000039H
	jg	SHORT $LN7@readNumber

; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';

	mov	QWORD PTR [r8+128], rax
	cmp	rax, rdx
	jae	SHORT $LN25@readNumber
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	cmp	cl, 48					; 00000030H
	jge	SHORT $LL8@readNumber
$LN7@readNumber:
	sub	cl, 69					; 00000045H
	test	cl, 223					; 000000dfH
	jne	SHORT $LN25@readNumber

; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';

	mov	r9, QWORD PTR [r8+120]
	mov	QWORD PTR [r8+128], rax
	cmp	rax, r9
	jae	SHORT $LN25@readNumber
	movzx	edx, BYTE PTR [rax]
	inc	rax
	lea	ecx, DWORD PTR [rdx-43]
	test	cl, 253					; 000000fdH
	jne	SHORT $LN24@readNumber

; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';

	mov	QWORD PTR [r8+128], rax
	cmp	rax, r9
	jae	SHORT $LN25@readNumber
	movzx	edx, BYTE PTR [rax]
	inc	rax
$LN24@readNumber:

; 1406 :     while (c >= '0' && c <= '9')

	cmp	dl, 48					; 00000030H
	jl	SHORT $LN25@readNumber
	npad	7
$LL2@readNumber:
	cmp	dl, 57					; 00000039H
	jg	SHORT $LN25@readNumber

; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';

	mov	QWORD PTR [r8+128], rax
	cmp	rax, r9
	jae	SHORT $LN25@readNumber
	movzx	edx, BYTE PTR [rax]
	inc	rax
	cmp	dl, 48					; 00000030H
	jge	SHORT $LL2@readNumber
$LN25@readNumber:

; 1408 :   }
; 1409 :   return true;

	mov	al, 1

; 1410 : }

	ret	0
?readNumber@OurReader@Json@@AEAA_N_N@Z ENDP		; Json::OurReader::readNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readString@OurReader@Json@@AEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?readString@OurReader@Json@@AEAA_NXZ PROC		; Json::OurReader::readString, COMDAT

; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {

	mov	rax, QWORD PTR [rcx+128]
	mov	r8, QWORD PTR [rcx+120]
	xor	dl, dl
	cmp	rax, r8
	je	SHORT $LN15@readString
$LN8@readString:

; 1790 :     return 0;
; 1791 :   return *current_++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 1414 :     c = getNextChar();
; 1415 :     if (c == '\\')

	cmp	dl, 92					; 0000005cH
	jne	SHORT $LN3@readString

; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {
; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')
; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')
; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';
; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)

	cmp	rax, r8
	je	SHORT $LN1@readString

; 1790 :     return 0;
; 1791 :   return *current_++;

	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 1792 : }

	jmp	SHORT $LN1@readString
$LN3@readString:

; 1416 :       getNextChar();
; 1417 :     else if (c == '"')

	cmp	dl, 34					; 00000022H
	je	SHORT $LN19@readString
$LN1@readString:

; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {

	mov	rax, QWORD PTR [rcx+128]
	cmp	rax, r8
	jne	SHORT $LN8@readString
$LN15@readString:

; 1418 :       break;
; 1419 :   }
; 1420 :   return c == '"';

	cmp	dl, 34					; 00000022H
$LN19@readString:
	sete	al

; 1421 : }

	ret	0
?readString@OurReader@Json@@AEAA_NXZ ENDP		; Json::OurReader::readString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readStringSingleQuote@OurReader@Json@@AEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?readStringSingleQuote@OurReader@Json@@AEAA_NXZ PROC	; Json::OurReader::readStringSingleQuote, COMDAT

; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {

	mov	rax, QWORD PTR [rcx+128]
	mov	r8, QWORD PTR [rcx+120]
	xor	dl, dl
	cmp	rax, r8
	je	SHORT $LN15@readString
$LN8@readString:

; 1790 :     return 0;
; 1791 :   return *current_++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')

	cmp	dl, 92					; 0000005cH
	jne	SHORT $LN3@readString

; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)

	cmp	rax, r8
	je	SHORT $LN1@readString

; 1790 :     return 0;
; 1791 :   return *current_++;

	inc	rax
	mov	QWORD PTR [rcx+128], rax

; 1792 : }

	jmp	SHORT $LN1@readString
$LN3@readString:

; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')

	cmp	dl, 39					; 00000027H
	je	SHORT $LN19@readString
$LN1@readString:

; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {

	mov	rax, QWORD PTR [rcx+128]
	cmp	rax, r8
	jne	SHORT $LN8@readString
$LN15@readString:

; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';

	cmp	dl, 39					; 00000027H
$LN19@readString:
	sete	al

; 1434 : }

	ret	0
?readStringSingleQuote@OurReader@Json@@AEAA_NXZ ENDP	; Json::OurReader::readStringSingleQuote
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z
_TEXT	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z PROC	; Json::OurReader::readObject, COMDAT

; 1436 : bool OurReader::readObject(Token& tokenStart) {

$LN1585:
	mov	rax, rsp
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-96]
	sub	rsp, 352				; 00000160H
	mov	QWORD PTR $T3[rsp], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r14, rdx
	mov	rdi, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR name$[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	r15d, r15d
	mov	QWORD PTR name$[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR name$[rbp-256], r15b
	mov	esi, DWORD PTR init$[rsp+8]
	and	esi, -505				; fffffe07H
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	or	esi, 7
	mov	DWORD PTR init$[rsp+8], esi
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR init$[rsp+16], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR init$[rsp+32], r15

; 364  :     value_.map_ = new ObjectValues();

	lea	ecx, QWORD PTR [r15+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	rbx, rax
	mov	QWORD PTR $T2[rsp], rax
	test	rax, rax
	je	SHORT $LN84@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

	mov	QWORD PTR [rax], r15

; 570  : 		this->_Mysize = 0;

	mov	QWORD PTR [rax+8], r15

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Buyheadnode
	mov	QWORD PTR [rbx], rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 364  :     value_.map_ = new ObjectValues();

	jmp	SHORT $LN85@readObject
$LN84@readObject:
	mov	rbx, r15
$LN85@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T16[rbp-256]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T6[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	mov	r8, r15
	je	SHORT $LN120@readObject
	mov	r8, QWORD PTR [rcx]
$LN120@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	r8, QWORD PTR [rcx+rdx*8]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	ecx, BYTE PTR [r8+8]

; 518  :   type_ = other.type_;

	movzx	eax, BYTE PTR init$[rsp+8]
	mov	BYTE PTR [r8+8], al

; 519  :   other.type_ = temp;

	mov	eax, esi
	xor	eax, ecx
	movzx	eax, al
	xor	esi, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rax, QWORD PTR [r8]

; 53   : 	_Left = _Move(_Right);

	mov	QWORD PTR [r8], rbx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR init$[rsp], rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [r8+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, esi
	xor	eax, ecx
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, esi
	and	edx, 256				; 00000100H
	xor	esi, edx
	mov	DWORD PTR init$[rsp+8], esi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T15[rbp-256]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T5[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN145@readObject
	mov	r8, r15
	jmp	SHORT $LN146@readObject
$LN145@readObject:
	mov	r8, QWORD PTR [r8]
$LN146@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [rdi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rdx+24], rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1442 :   while (readToken(tokenName)) {

	lea	rdx, QWORD PTR tokenName$[rsp]
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	test	al, al
	je	$LN13@readObject
	mov	r12d, 40964				; 0000a004H
$LL22@readObject:

; 1443 :     bool initialTokenOk = true;

	mov	al, 1

; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)

	mov	ecx, DWORD PTR tokenName$[rsp]
	cmp	ecx, 15
	jne	SHORT $LN1573@readObject
	npad	1
$LL20@readObject:
	test	al, al
	je	$LN13@readObject

; 1445 :       initialTokenOk = readToken(tokenName);

	lea	rdx, QWORD PTR tokenName$[rsp]
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken

; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)

	mov	ecx, DWORD PTR tokenName$[rsp]
	cmp	ecx, 15
	je	SHORT $LL20@readObject

; 1446 :     if (!initialTokenOk)

	test	al, al
	je	$LN13@readObject
$LN1573@readObject:

; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object

	cmp	ecx, 2
	jne	SHORT $LN17@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR name$[rbp-240], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object

	je	$LN1549@readObject
$LN17@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR name$[rbp-240], r15

; 513  : 			: this->_Bx._Buf);

	lea	rax, QWORD PTR name$[rbp-256]
	cmp	QWORD PTR name$[rbp-232], 16
	cmovae	rax, QWORD PTR name$[rbp-256]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1451 :     if (tokenName.type_ == tokenString) {

	cmp	ecx, 5
	jne	SHORT $LN16@readObject

; 1452 :       if (!decodeString(tokenName, name))

	lea	r8, QWORD PTR name$[rbp-256]
	lea	rdx, QWORD PTR tokenName$[rsp]
	mov	rcx, rdi
	call	?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::OurReader::decodeString
	test	al, al
	je	$LN1550@readObject

; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {

	jmp	$LN577@readObject
$LN16@readObject:
	cmp	ecx, 6
	jne	$LN13@readObject
	cmp	BYTE PTR [rdi+187], 0
	je	$LN13@readObject
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	and	DWORD PTR numberName$21[rbp-248], -512	; fffffe00H
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR numberName$21[rbp-240], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR numberName$21[rbp-224], r15
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1456 :       if (!decodeNumber(tokenName, numberName))

	lea	r8, QWORD PTR numberName$21[rbp-256]
	lea	rdx, QWORD PTR tokenName$[rsp]
	mov	rcx, rdi
	call	?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ; Json::OurReader::decodeNumber
	test	al, al
	je	$LN1551@readObject

; 1458 :       name = numberName.asString();

	lea	rdx, QWORD PTR $T12[rbp-256]
	lea	rcx, QWORD PTR numberName$21[rbp-256]
	call	?asString@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Value::asString
	mov	rbx, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 903  : 		if (this != &_Right)

	lea	rax, QWORD PTR name$[rbp-256]
	cmp	rax, rbx
	je	SHORT $LN463@readObject

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR name$[rbp-232], 16
	jb	SHORT $LN319@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR name$[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN319@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR name$[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR name$[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR name$[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	cmp	QWORD PTR [rbx+24], 16
	jae	SHORT $LN410@readObject

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	r8, QWORD PTR [rbx+16]
	inc	r8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN409@readObject
	mov	rdx, rbx
	lea	rcx, QWORD PTR name$[rbp-256]
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

	jmp	SHORT $LN409@readObject
$LN410@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR name$[rbp-256], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 942  : 			_Right._Bx._Ptr = pointer();

	mov	QWORD PTR [rbx], r15
$LN409@readObject:

; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR name$[rbp-240], rax

; 945  : 		this->_Myres = _Right._Myres;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR name$[rbp-232], rax

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], 0
$LN463@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T12[rbp-232], 16
	jb	SHORT $LN485@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T12[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN485@readObject:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 487  :   switch (type_) {

	movsx	eax, BYTE PTR numberName$21[rbp-248]
	cmp	eax, 4
	je	SHORT $LN500@readObject
	add	eax, -6					; fffffffaH
	cmp	eax, 1
	ja	SHORT $LN510@readObject

; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;

	mov	rbx, QWORD PTR numberName$21[rbp-256]
	test	rbx, rbx
	je	SHORT $LN510@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

	mov	r8, QWORD PTR [rbx]

; 774  : 		}
; 775  : 
; 776  : 	~_Tree_alloc() _NOEXCEPT
; 777  : 		{	// destroy head node
; 778  : 		_Freeheadnode(this->_Myhead);
; 779  : 		}
; 780  : 
; 781  : 	void _Change_alloc(const _Alty&)
; 782  : 		{	// replace old allocator
; 783  : 		}
; 784  : 
; 785  : 	void _Swap_alloc(_Myt&)
; 786  : 		{	// swap allocators
; 787  : 		}
; 788  : 
; 789  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 790  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 791  : 		{	// construct allocators from _Al
; 792  : 		this->_Myhead = _Buyheadnode();
; 793  : 		_TRY_BEGIN
; 794  : 		_Alloc_proxy();
; 795  : 		_CATCH_ALL
; 796  : 		_Freeheadnode(this->_Myhead);
; 797  : 		_RERAISE;
; 798  : 		_CATCH_END
; 799  : 		}
; 800  : 
; 801  : 	~_Tree_alloc() _NOEXCEPT
; 802  : 		{	// destroy proxy
; 803  : 		_Freeheadnode(this->_Myhead);
; 804  : 		_Free_proxy();
; 805  : 		}
; 806  : 
; 807  : 	void _Change_alloc(const _Alty&)
; 808  : 		{	// replace old allocator
; 809  : 		}
; 810  : 
; 811  : 	void _Swap_alloc(_Myt&)
; 812  : 		{	// swap allocators
; 813  : 		}
; 814  : 
; 815  : 	void _Alloc_proxy()
; 816  : 		{	// construct proxy from _Alnod
; 817  : 		typename _Alty::template rebind<_Container_proxy>::other
; 818  : 			_Alproxy(_Getal());
; 819  : 		this->_Myproxy = _Alproxy.allocate(1);
; 820  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 821  : 		this->_Myproxy->_Mycont = this;
; 822  : 		}
; 823  : 
; 824  : 	void _Free_proxy()
; 825  : 		{	// destroy proxy
; 826  : 		typename _Alty::template rebind<_Container_proxy>::other
; 827  : 			_Alproxy(_Getal());
; 828  : 		this->_Orphan_all();
; 829  : 		_Alproxy.destroy(this->_Myproxy);
; 830  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 831  : 		this->_Myproxy = 0;
; 832  : 		}
; 833  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 834  : 
; 835  : 	_Nodeptr _Buyheadnode()
; 836  : 		{	// get head node using current allocator
; 837  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 838  : 
; 839  : 		_TRY_BEGIN
; 840  : 		this->_Getal().construct(
; 841  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 842  : 		this->_Getal().construct(
; 843  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 844  : 		this->_Getal().construct(
; 845  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 846  : 		_CATCH_ALL
; 847  : 		this->_Getal().deallocate(_Pnode, 1);
; 848  : 		_RERAISE;
; 849  : 		_CATCH_END
; 850  : 
; 851  : 		this->_Color(_Pnode) = this->_Black;
; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}
; 855  : 
; 856  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 857  : 		{	// free head node using current allocator
; 858  : 		this->_Getal().destroy(
; 859  : 			_STD addressof(this->_Left(_Pnode)));
; 860  : 		this->_Getal().destroy(
; 861  : 			_STD addressof(this->_Parent(_Pnode)));
; 862  : 		this->_Getal().destroy(
; 863  : 			_STD addressof(this->_Right(_Pnode)));
; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());
; 870  : 		}
; 871  : 	};
; 872  : 
; 873  : 		// TEMPLATE CLASS _Tree_buy
; 874  : template<class _Ty,
; 875  : 	class _Alloc>
; 876  : 	class _Tree_buy
; 877  : 		: public _Tree_alloc<!is_empty<_Alloc>::value,
; 878  : 			_Tree_base_types<_Ty, _Alloc> >
; 879  : 	{	// base class for tree to hold buynode/freenode functions
; 880  : public:
; 881  : 	typedef _Tree_alloc<!is_empty<_Alloc>::value,
; 882  : 		_Tree_base_types<_Ty, _Alloc> > _Mybase;
; 883  : 	typedef typename _Mybase::_Alty _Alty;
; 884  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 885  : 	typedef typename _Mybase::value_type value_type;
; 886  : 
; 887  : 	_Tree_buy(const _Alloc& _Al = _Alloc())
; 888  : 		: _Mybase(_Al)
; 889  : 		{	// construct from allocator
; 890  : 		}
; 891  : 
; 892  : 	_Nodeptr _Buynode0()
; 893  : 		{	// allocate a non-value node
; 894  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 895  : 
; 896  : 		_TRY_BEGIN
; 897  : 		this->_Getal().construct(
; 898  : 			_STD addressof(this->_Left(_Pnode)), this->_Myhead);
; 899  : 		this->_Getal().construct(
; 900  : 			_STD addressof(this->_Parent(_Pnode)), this->_Myhead);
; 901  : 		this->_Getal().construct(
; 902  : 			_STD addressof(this->_Right(_Pnode)), this->_Myhead);
; 903  : 		_CATCH_ALL
; 904  : 		this->_Getal().deallocate(_Pnode, 1);
; 905  : 		_RERAISE;
; 906  : 		_CATCH_END
; 907  : 
; 908  : 		return (_Pnode);
; 909  : 		}
; 910  : 
; 911  : 	void _Freenode0(_Nodeptr _Pnode)
; 912  : 		{	// free non-value node using current allocator
; 913  : 		this->_Getal().destroy(
; 914  : 			_STD addressof(this->_Left(_Pnode)));
; 915  : 		this->_Getal().destroy(
; 916  : 			_STD addressof(this->_Parent(_Pnode)));
; 917  : 		this->_Getal().destroy(
; 918  : 			_STD addressof(this->_Right(_Pnode)));
; 919  : 		this->_Getal().deallocate(_Pnode, 1);
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)
; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();
; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;
; 928  : 		this->_Isnil(_Pnode) = false;
; 929  : 
; 930  : 		_TRY_BEGIN
; 931  : 		this->_Getal().construct(
; 932  : 			_STD addressof(this->_Myval(_Pnode)),
; 933  : 				_STD forward<_Valty>(_Val)...);
; 934  : 		_CATCH_ALL
; 935  : 		_Freenode0(_Pnode);
; 936  : 		_RERAISE;
; 937  : 		_CATCH_END
; 938  : 
; 939  : 		return (_Pnode);
; 940  : 		}
; 941  : 
; 942  : 	};
; 943  : 
; 944  : 		// TEMPLATE CLASS _Tree_comp
; 945  : template<bool _Pr_has_storage,
; 946  : 	class _Traits>
; 947  : 	class _Tree_comp
; 948  : 		: public _Tree_buy<typename _Traits::value_type,
; 949  : 			typename _Traits::allocator_type>
; 950  : 	{	// base class for _Tree to hold ordering predicate with storage
; 951  : public:
; 952  : 	typedef _Tree_comp<_Pr_has_storage, _Traits> _Myt;
; 953  : 	typedef _Tree_buy<typename _Traits::value_type,
; 954  : 		typename _Traits::allocator_type> _Mybase;
; 955  : 
; 956  : 	typedef typename _Traits::allocator_type allocator_type;
; 957  : 	typedef typename _Traits::key_compare key_compare;
; 958  : 
; 959  : 	_Tree_comp(const key_compare& _Parg, const allocator_type& _Al)
; 960  : 		: _Mybase(_Al), comp(_Parg)
; 961  : 		{	// construct ordering predicate
; 962  : 		}
; 963  : 
; 964  : 	key_compare& _Getcomp()
; 965  : 		{	// get reference to ordering predicate
; 966  : 		return (comp);
; 967  : 		}
; 968  : 
; 969  : 	const key_compare& _Getcomp() const
; 970  : 		{	// get reference to ordering predicate
; 971  : 		return (comp);
; 972  : 		}
; 973  : 
; 974  : 	void _Setcomp(const key_compare& _Right)
; 975  : 		{	// copy ordering predicate
; 976  : 		comp = _Right;
; 977  : 		}
; 978  : 
; 979  : 	void _Swapcomp(key_compare& _Right)
; 980  : 		{	// swap ordering predicate
; 981  : 		_Swap_adl(comp, _Right);
; 982  : 		}
; 983  : 
; 984  : 	key_compare comp;
; 985  : 	};
; 986  : 
; 987  : template<class _Traits>
; 988  : 	class _Tree_comp<false, _Traits>
; 989  : 		: public _Tree_buy<typename _Traits::value_type,
; 990  : 			typename _Traits::allocator_type>
; 991  : 	{	// base class for _Tree to hold ordering predicate with no storage
; 992  : public:
; 993  : 	typedef _Tree_comp<false, _Traits> _Myt;
; 994  : 	typedef _Tree_buy<typename _Traits::value_type,
; 995  : 		typename _Traits::allocator_type> _Mybase;
; 996  : 
; 997  : 	typedef typename _Traits::allocator_type allocator_type;
; 998  : 	typedef typename _Traits::key_compare key_compare;
; 999  : 
; 1000 : 	_Tree_comp(const key_compare&, const allocator_type& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct ordering predicate
; 1003 : 		}
; 1004 : 
; 1005 : 	key_compare _Getcomp() const
; 1006 : 		{	// get ordering predicate
; 1007 : 		return (key_compare());
; 1008 : 		}
; 1009 : 
; 1010 : 	void _Setcomp(const key_compare&)
; 1011 : 		{	// copy ordering predicate
; 1012 : 		}
; 1013 : 
; 1014 : 	void _Swapcomp(const key_compare&)
; 1015 : 		{	// swap ordering predicate
; 1016 : 		}
; 1017 : 	};
; 1018 : 
; 1019 : 		// TEMPLATE CLASS _Tree
; 1020 : template<class _Traits>
; 1021 : 	class _Tree
; 1022 : 		: public _Tree_comp<
; 1023 : 			!is_empty<typename _Traits::key_compare>::value, _Traits>
; 1024 : 	{	// ordered red-black tree for [multi_]{map set}
; 1025 : public:
; 1026 : 	typedef _Tree<_Traits> _Myt;
; 1027 : 	typedef _Tree_comp<
; 1028 : 		!is_empty<typename _Traits::key_compare>::value, _Traits> _Mybase;
; 1029 : 
; 1030 : 	typedef typename _Traits::key_type key_type;
; 1031 : 	typedef typename _Traits::value_compare value_compare;
; 1032 : 	enum
; 1033 : 		{	// get multi parameter
; 1034 : 		_Multi = _Traits::_Multi};
; 1035 : 
; 1036 : 	typedef typename _Mybase::_Node _Node;
; 1037 : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 1038 : 	typedef typename _Mybase::_Alty _Alty;
; 1039 : 
; 1040 : 	typedef typename _Mybase::key_compare key_compare;
; 1041 : 	typedef typename _Mybase::allocator_type allocator_type;
; 1042 : 
; 1043 : 	typedef typename _Mybase::value_type value_type;
; 1044 : 	typedef typename _Mybase::size_type size_type;
; 1045 : 	typedef typename _Mybase::difference_type difference_type;
; 1046 : 	typedef typename _Mybase::pointer pointer;
; 1047 : 	typedef typename _Mybase::const_pointer const_pointer;
; 1048 : 	typedef typename _Mybase::reference reference;
; 1049 : 	typedef typename _Mybase::const_reference const_reference;
; 1050 : 
; 1051 : 	typedef typename _Mybase::const_iterator const_iterator;
; 1052 : 	typedef typename _If<is_same<key_type, value_type>::value,
; 1053 : 		typename _Mybase::const_iterator,
; 1054 : 		typename _Mybase::iterator>::type iterator;
; 1055 : 
; 1056 : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 1057 : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 1058 : 
; 1059 : 	typedef pair<iterator, bool> _Pairib;
; 1060 : 	typedef pair<iterator, iterator> _Pairii;
; 1061 : 	typedef pair<const_iterator, const_iterator> _Paircc;
; 1062 : 
; 1063 : 	_Tree(const key_compare& _Parg,
; 1064 : 		const allocator_type& _Al)
; 1065 : 		: _Mybase(_Parg, _Al)
; 1066 : 		{	// construct empty tree
; 1067 : 		}
; 1068 : 
; 1069 : 	_Tree(const value_type *_First, const value_type *_Last,
; 1070 : 		const key_compare& _Parg, const allocator_type& _Al)
; 1071 : 		: _Mybase(_Parg, _Al)
; 1072 : 		{	// construct tree from [_First, _Last) array
; 1073 : 		_TRY_BEGIN
; 1074 : 		insert(_First, _Last);
; 1075 : 		_CATCH_ALL
; 1076 : 		_Tidy();
; 1077 : 		_RERAISE;
; 1078 : 		_CATCH_END
; 1079 : 		}
; 1080 : 
; 1081 : 	_Tree(const _Myt& _Right, const allocator_type& _Al)
; 1082 : 		: _Mybase(_Right.key_comp(), _Al)
; 1083 : 		{	// construct tree by copying _Right, allocator
; 1084 : 		_TRY_BEGIN
; 1085 : 		_Copy(_Right, false_type());
; 1086 : 		_CATCH_ALL
; 1087 : 		_Tidy();
; 1088 : 		_RERAISE;
; 1089 : 		_CATCH_END
; 1090 : 		}
; 1091 : 
; 1092 : 	_Tree(_Myt&& _Right)
; 1093 : 		: _Mybase(_Right.key_comp(), _Right._Getal())
; 1094 : 		{	// construct tree by moving _Right
; 1095 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1096 : 		}
; 1097 : 
; 1098 : 	_Tree(_Myt&& _Right, const allocator_type& _Al)
; 1099 : 		: _Mybase(_Right.key_comp(), _Al)
; 1100 : 		{	// construct tree by moving _Right, allocator
; 1101 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1102 : 		}
; 1103 : 
; 1104 : 	_Myt& operator=(_Myt&& _Right)
; 1105 : 		{	// assign by moving _Right
; 1106 : 		if (this != &_Right)
; 1107 : 			{	// different, move it
; 1108 : 			clear();
; 1109 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1110 : 				&& this->_Getal() != _Right._Getal())
; 1111 : 				this->_Change_alloc(_Right._Getal());
; 1112 : 
; 1113 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1114 : 			}
; 1115 : 		return (*this);
; 1116 : 		}
; 1117 : 
; 1118 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1119 : 		{	// move from _Right, stealing its contents
; 1120 : 		this->_Swap_all(_Right);
; 1121 : 		this->_Swapcomp(_Right._Getcomp());
; 1122 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1123 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1124 : 		}
; 1125 : 
; 1126 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1127 : 		{	// move from _Right, possibly moving its contents
; 1128 : 		if (get_allocator() == _Right.get_allocator())
; 1129 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1130 : 		else
; 1131 : 			_Copy(_Right, true_type());
; 1132 : 		}
; 1133 : 
; 1134 : 	void _Assign_rv(_Myt&& _Right)
; 1135 : 		{	// assign by moving _Right
; 1136 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1137 : 			typename _Alty::propagate_on_container_move_assignment());
; 1138 : 		}
; 1139 : 
; 1140 : 
; 1141 : 	_Pairib insert(value_type&& _Val)
; 1142 : 		{	// try to insert node with value _Val, favoring right side
; 1143 : 		return (_Insert_nohint(false,
; 1144 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1145 : 		}
; 1146 : 
; 1147 : 	iterator insert(const_iterator _Where, value_type&& _Val)
; 1148 : 		{	// try to insert node with value _Val using _Where as a hint
; 1149 : 		return (_Insert_hint(_Where,
; 1150 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1151 : 		}
; 1152 : 
; 1153 : 	template<class _Valty>
; 1154 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1155 : 			_Pairib>::type
; 1156 : 		insert(_Valty&& _Val)
; 1157 : 		{	// try to insert node with value _Val, favoring right side
; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));
; 1161 : 		}
; 1162 : 
; 1163 : 	template<class _Valty>
; 1164 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1165 : 			iterator>::type
; 1166 : 		insert(const_iterator _Where, _Valty&& _Val)
; 1167 : 		{	// try to insert node with value _Val using _Where as a hint
; 1168 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1169 : 		return (_Insert_hint(_Where,
; 1170 : 			this->_Myval(_Newnode), _Newnode));
; 1171 : 		}
; 1172 : 
; 1173 : 	template<class... _Valty>
; 1174 : 		_Pairib emplace(_Valty&&... _Val)
; 1175 : 		{	// try to insert value_type(_Val...), favoring right side
; 1176 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1177 : 		return (_Insert_nohint(false,
; 1178 : 			this->_Myval(_Newnode), _Newnode));
; 1179 : 		}
; 1180 : 
; 1181 : 	template<class... _Valty>
; 1182 : 		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
; 1183 : 		{	// insert value_type(_Val...) at _Where
; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));
; 1187 : 		}
; 1188 : 
; 1189 : 
; 1190 : 	~_Tree() _NOEXCEPT
; 1191 : 		{	// destroy tree
; 1192 : 		_Tidy();
; 1193 : 		}
; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

	mov	r9, r8
	mov	r8, QWORD PTR [r8]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	mov	rcx, rbx
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 501  :     break;

	jmp	SHORT $LN510@readObject
$LN500@readObject:

; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)

	test	DWORD PTR numberName$21[rbp-248], 256	; 00000100H
	je	SHORT $LN510@readObject

; 170  :   free(value);

	mov	rcx, QWORD PTR numberName$21[rbp-256]
	call	QWORD PTR __imp_free
$LN510@readObject:

; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;

	mov	rcx, QWORD PTR numberName$21[rbp-240]
	test	rcx, rcx
	je	SHORT $LN577@readObject
	lea	rbx, QWORD PTR [rcx-8]
	lea	r9, OFFSET FLAT:??1CommentInfo@Value@Json@@QEAA@XZ ; Json::Value::CommentInfo::~CommentInfo
	mov	r8d, DWORD PTR [rbx]
	mov	edx, 8
	call	??_M@YAXPEAX_KHP6AX0@Z@Z
	mov	rcx, rbx
	call	QWORD PTR __imp_??_V@YAXPEAX@Z
$LN577@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {

	lea	rdx, QWORD PTR colon$19[rbp-256]
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	test	al, al
	je	$LN9@readObject
	cmp	DWORD PTR colon$19[rbp-256], 14
	jne	$LN9@readObject

; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");

	mov	rbx, QWORD PTR name$[rbp-240]
	cmp	rbx, 1073741824				; 40000000H
	jae	$LN1553@readObject

; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {

	cmp	BYTE PTR [rdi+190], 0
	je	SHORT $LN7@readObject
	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	r8, QWORD PTR name$[rbp-256]
	cmp	QWORD PTR name$[rbp-232], 16
	cmovae	r8, QWORD PTR name$[rbp-256]
	lea	rdx, QWORD PTR name$[rbp-256]
	cmovae	rdx, QWORD PTR name$[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1220 :   return isMember(key.data(), key.data() + key.length());

	add	r8, rbx

; 1107 : }
; 1108 : 
; 1109 : Value& Value::operator[](const StaticString& key) {
; 1110 :   return resolveReference(key.c_str());
; 1111 : }
; 1112 : 
; 1113 : #ifdef JSON_USE_CPPTL
; 1114 : Value& Value::operator[](const CppTL::ConstString& key) {
; 1115 :   return resolveReference(key.c_str(), key.end_c_str());
; 1116 : }
; 1117 : Value const& Value::operator[](CppTL::ConstString const& key) const
; 1118 : {
; 1119 :   Value const* found = find(key.c_str(), key.end_c_str());
; 1120 :   if (!found) return nullSingleton();
; 1121 :   return *found;
; 1122 : }
; 1123 : #endif
; 1124 : 
; 1125 : Value& Value::append(const Value& value) { return (*this)[size()] = value; }
; 1126 : 
; 1127 : Value Value::get(char const* key, char const* cend, Value const& defaultValue) const
; 1128 : {
; 1129 :   Value const* found = find(key, cend);
; 1130 :   return !found ? defaultValue : *found;
; 1131 : }
; 1132 : Value Value::get(char const* key, Value const& defaultValue) const
; 1133 : {
; 1134 :   return get(key, key + strlen(key), defaultValue);
; 1135 : }
; 1136 : Value Value::get(JSONCPP_STRING const& key, Value const& defaultValue) const
; 1137 : {
; 1138 :   return get(key.data(), key.data() + key.length(), defaultValue);
; 1139 : }
; 1140 : 
; 1141 : 
; 1142 : bool Value::removeMember(const char* key, const char* cend, Value* removed)
; 1143 : {
; 1144 :   if (type_ != objectValue) {
; 1145 :     return false;
; 1146 :   }
; 1147 :   CZString actualKey(key, static_cast<unsigned>(cend-key), CZString::noDuplication);
; 1148 :   ObjectValues::iterator it = value_.map_->find(actualKey);
; 1149 :   if (it == value_.map_->end())
; 1150 :     return false;
; 1151 :   *removed = it->second;
; 1152 :   value_.map_->erase(it);
; 1153 :   return true;
; 1154 : }
; 1155 : bool Value::removeMember(const char* key, Value* removed)
; 1156 : {
; 1157 :   return removeMember(key, key + strlen(key), removed);
; 1158 : }
; 1159 : bool Value::removeMember(JSONCPP_STRING const& key, Value* removed)
; 1160 : {
; 1161 :   return removeMember(key.data(), key.data() + key.length(), removed);
; 1162 : }
; 1163 : Value Value::removeMember(const char* key)
; 1164 : {
; 1165 :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == objectValue,
; 1166 :                       "in Json::Value::removeMember(): requires objectValue");
; 1167 :   if (type_ == nullValue)
; 1168 :     return nullSingleton();
; 1169 : 
; 1170 :   Value removed;  // null
; 1171 :   removeMember(key, key + strlen(key), &removed);
; 1172 :   return removed; // still null if removeMember() did nothing
; 1173 : }
; 1174 : Value Value::removeMember(const JSONCPP_STRING& key)
; 1175 : {
; 1176 :   return removeMember(key.c_str());
; 1177 : }
; 1178 : 
; 1179 : bool Value::removeIndex(ArrayIndex index, Value* removed) {
; 1180 :   if (type_ != arrayValue) {
; 1181 :     return false;
; 1182 :   }
; 1183 :   CZString key(index);
; 1184 :   ObjectValues::iterator it = value_.map_->find(key);
; 1185 :   if (it == value_.map_->end()) {
; 1186 :     return false;
; 1187 :   }
; 1188 :   *removed = it->second;
; 1189 :   ArrayIndex oldSize = size();
; 1190 :   // shift left all items left, into the place of the "removed"
; 1191 :   for (ArrayIndex i = index; i < (oldSize - 1); ++i){
; 1192 :     CZString keey(i);
; 1193 :     (*value_.map_)[keey] = (*this)[i + 1];
; 1194 :   }
; 1195 :   // erase the last one ("leftover")
; 1196 :   CZString keyLast(oldSize - 1);
; 1197 :   ObjectValues::iterator itLast = value_.map_->find(keyLast);
; 1198 :   value_.map_->erase(itLast);
; 1199 :   return true;
; 1200 : }
; 1201 : 
; 1202 : #ifdef JSON_USE_CPPTL
; 1203 : Value Value::get(const CppTL::ConstString& key,
; 1204 :                  const Value& defaultValue) const {
; 1205 :   return get(key.c_str(), key.end_c_str(), defaultValue);
; 1206 : }
; 1207 : #endif
; 1208 : 
; 1209 : bool Value::isMember(char const* key, char const* cend) const
; 1210 : {
; 1211 :   Value const* value = find(key, cend);

	mov	rcx, rax
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1212 :   return NULL != value;

	test	rax, rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {

	jne	$LN1554@readObject
	mov	rbx, QWORD PTR name$[rbp-240]
$LN7@readObject:

; 1473 :     }
; 1474 :     Value& value = currentValue()[name];

	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	r8, QWORD PTR name$[rbp-256]
	cmp	QWORD PTR name$[rbp-232], 16
	cmovae	r8, QWORD PTR name$[rbp-256]
	lea	rdx, QWORD PTR name$[rbp-256]
	cmovae	rdx, QWORD PTR name$[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1106 :   return resolveReference(key.data(), key.data() + key.length());

	add	r8, rbx
	mov	rcx, rax
	call	?resolveReference@Value@Json@@AEAAAEAV12@PEBD0@Z ; Json::Value::resolveReference
	mov	r14, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1130 : 		this->_Orphan_all();

	mov	rcx, rdi
	call	QWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QEAAXXZ

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rdx, QWORD PTR [rdi+32]
	movzx	ecx, BYTE PTR [rdi+24]
	add	cl, dl
	test	cl, 1
	jne	SHORT $LN1208@readObject
	lea	rcx, QWORD PTR [rdx+2]
	shr	rcx, 1
	cmp	QWORD PTR [rdi+16], rcx
	ja	SHORT $LN1208@readObject
	mov	rcx, rdi
	call	?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Growmap
$LN1208@readObject:
	mov	rdx, QWORD PTR [rdi+16]
	lea	rax, QWORD PTR [rdx*2-1]
	and	QWORD PTR [rdi+24], rax
	mov	rsi, QWORD PTR [rdi+24]
	add	rsi, QWORD PTR [rdi+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rbx, rsi
	shr	rbx, 1
	lea	rax, QWORD PTR [rdx-1]
	and	rbx, rax

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rdi+8]
	cmp	QWORD PTR [rax+rbx*8], 0
	jne	SHORT $LN1207@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	je	$LN1555@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rcx, QWORD PTR [rdi+8]
	mov	QWORD PTR [rcx+rbx*8], rax
$LN1207@readObject:

; 1132 : 		this->_Getal().construct(
; 1133 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 			_STD forward<value_type>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	and	esi, 1
	mov	rax, QWORD PTR [rax+rbx*8]
	lea	rcx, QWORD PTR [rax+rsi*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN1242@readObject
	mov	QWORD PTR [rcx], r14
$LN1242@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1135 : 		_PUSH_BACK_END;

	inc	QWORD PTR [rdi+32]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1476 :     bool ok = readValue();

	mov	rcx, rdi
	call	?readValue@OurReader@Json@@AEAA_NXZ	; Json::OurReader::readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1491 : 		if (--this->_Mysize == 0)

	dec	QWORD PTR [rdi+32]
	jne	SHORT $LN1252@readObject

; 1492 : 			this->_Myoff = 0;

	mov	QWORD PTR [rdi+24], r15
$LN1252@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1484 :          comma.type_ != tokenComment)) {

	mov	rcx, rdi

; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set

	test	al, al
	je	$LN1556@readObject

; 1484 :          comma.type_ != tokenComment)) {

	lea	rdx, QWORD PTR comma$7[rsp]
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	test	al, al
	je	$LN4@readObject
	mov	eax, DWORD PTR comma$7[rsp]
	cmp	eax, 15
	ja	$LN4@readObject
	bt	r12d, eax
	jae	$LN4@readObject

; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;

	mov	cl, 1

; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)

	cmp	eax, 15
	jne	SHORT $LN2@readObject
$LL3@readObject:
	test	cl, cl
	je	SHORT $LN2@readObject

; 1490 :       finalizeTokenOk = readToken(comma);

	lea	rdx, QWORD PTR comma$7[rsp]
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	movzx	ecx, al

; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)

	mov	eax, DWORD PTR comma$7[rsp]
	cmp	eax, 15
	je	SHORT $LL3@readObject
$LN2@readObject:

; 1491 :     if (comma.type_ == tokenObjectEnd)

	cmp	eax, 2
	je	SHORT $LN1549@readObject

; 1442 :   while (readToken(tokenName)) {

	lea	rdx, QWORD PTR tokenName$[rsp]
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	test	al, al
	je	$LN13@readObject
	jmp	$LL22@readObject
$LN1549@readObject:

; 1449 :       return true;

	lea	rcx, QWORD PTR init$[rsp]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR name$[rbp-232], 16
	jb	SHORT $LN173@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR name$[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN173@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1449 :       return true;

	mov	al, 1
	jmp	$LN23@readObject
$LN1550@readObject:

; 1453 :         return recoverFromError(tokenObjectEnd);

	mov	edx, 2
	mov	rcx, rdi
	call	?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z ; Json::OurReader::recoverFromError
	movzx	ebx, al
	jmp	$LN1580@readObject
$LN1554@readObject:

; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";

	lea	r8, QWORD PTR name$[rbp-256]
	lea	rdx, OFFSET FLAT:??_C@_0BB@BCJBKKDP@Duplicate?5key?3?5?8?$AA@
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_01GEODFPGF@?8?$AA@
	mov	rdx, rax
	lea	rcx, QWORD PTR msg$20[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@PEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T10[rbp-232], 16
	jb	SHORT $LN961@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T10[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN961@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T10[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T10[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T10[rbp-256], 0
	mov	QWORD PTR info$4[rbp-208], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$4[rbp-216], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$4[rbp-232], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1759 :   info.token_ = token;

	movups	xmm0, XMMWORD PTR tokenName$[rsp]
	movaps	XMMWORD PTR info$4[rsp], xmm0
	movsdx	xmm1, QWORD PTR tokenName$[rsp+16]
	movsdx	QWORD PTR info$4[rbp-240], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR msg$20[rbp-256]
	lea	rcx, QWORD PTR info$4[rbp-232]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1761 :   info.extra_ = extra;

	mov	QWORD PTR info$4[rbp-200], r15

; 1762 :   errors_.push_back(info);

	lea	rdx, QWORD PTR info$4[rsp]
	lea	rcx, QWORD PTR [rdi+40]
	call	?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$4[rbp-208], 16
	jb	SHORT $LN1094@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$4[rbp-232]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN1094@readObject:
	mov	QWORD PTR info$4[rbp-208], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$4[rbp-216], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$4[rbp-232], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1352 : 		return (this->_Mysize);

	mov	rsi, QWORD PTR [rdi+72]
$LL1110@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1770 :     if (!readToken(skip))

	lea	rdx, QWORD PTR skip$13[rbp-256]
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	test	al, al
	jne	SHORT $LN1108@readObject

; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery

	mov	rdx, rsi
	lea	rcx, QWORD PTR [rdi+40]
	call	?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize
$LN1108@readObject:

; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)

	mov	eax, DWORD PTR skip$13[rbp-256]
	cmp	eax, 2
	je	SHORT $LN1559@readObject
	test	eax, eax
	jne	SHORT $LL1110@readObject
$LN1559@readObject:

; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);

	mov	rdx, rsi
	lea	rcx, QWORD PTR [rdi+40]
	call	?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR msg$20[rbp-232], 16
	jb	SHORT $LN1135@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR msg$20[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN1135@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR msg$20[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR msg$20[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR msg$20[rbp-256], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1472 :           msg, tokenName, tokenObjectEnd);

	jmp	$LN1584@readObject
$LN1555@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN4@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T18[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T18[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T18[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 40					; 00000028H
	lea	rdx, OFFSET FLAT:??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
	lea	rcx, QWORD PTR $T18[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1782 :   addError(message, token);

	xor	r9d, r9d
	lea	r8, QWORD PTR comma$7[rsp]
	lea	rdx, QWORD PTR $T18[rbp-256]
	mov	rcx, rdi
	call	?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::OurReader::addError

; 1783 :   return recoverFromError(skipUntilToken);

	mov	edx, 2
	mov	rcx, rdi
	call	?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z ; Json::OurReader::recoverFromError
	movzx	ebx, al

; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);

	jmp	$LN1583@readObject
$LN1556@readObject:

; 1479 :       return recoverFromError(tokenObjectEnd);

	mov	edx, 2
	call	?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z ; Json::OurReader::recoverFromError
	movzx	ebx, al
	jmp	$LN1580@readObject
$LN1553@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T11[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T11[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T11[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 17
	lea	rdx, OFFSET FLAT:??_C@_0BC@PJPJEKBD@keylength?5?$DO?$DN?52?$FO30?$AA@
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");

	lea	rcx, QWORD PTR $T11[rbp-256]
	call	?throwRuntimeError@Json@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::throwRuntimeError
	npad	1
$LN9@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T8[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T8[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 36					; 00000024H
	lea	rdx, OFFSET FLAT:??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
	lea	rcx, QWORD PTR $T8[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR info$9[rbp-208], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$9[rbp-216], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$9[rbp-232], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1759 :   info.token_ = token;

	movups	xmm0, XMMWORD PTR colon$19[rbp-256]
	movaps	XMMWORD PTR info$9[rbp-256], xmm0
	movsdx	xmm1, QWORD PTR colon$19[rbp-240]
	movsdx	QWORD PTR info$9[rbp-240], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T8[rsp]
	lea	rcx, QWORD PTR info$9[rbp-232]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1761 :   info.extra_ = extra;

	mov	QWORD PTR info$9[rbp-200], r15

; 1762 :   errors_.push_back(info);

	lea	rdx, QWORD PTR info$9[rbp-256]
	lea	rcx, QWORD PTR [rdi+40]
	call	?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$9[rbp-208], 16
	jb	SHORT $LN752@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$9[rbp-232]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN752@readObject:
	mov	QWORD PTR info$9[rbp-208], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$9[rbp-216], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$9[rbp-232], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1352 : 		return (this->_Mysize);

	mov	rsi, QWORD PTR [rdi+72]
	npad	3
$LL768@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1770 :     if (!readToken(skip))

	lea	rdx, QWORD PTR skip$14[rbp-256]
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	test	al, al
	jne	SHORT $LN766@readObject

; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery

	mov	rdx, rsi
	lea	rcx, QWORD PTR [rdi+40]
	call	?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize
$LN766@readObject:

; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)

	mov	eax, DWORD PTR skip$14[rbp-256]
	cmp	eax, 2
	je	SHORT $LN1560@readObject
	test	eax, eax
	jne	SHORT $LL768@readObject
$LN1560@readObject:

; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);

	mov	rdx, rsi
	lea	rcx, QWORD PTR [rdi+40]
	call	?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T8[rbp-232], 16
	jb	SHORT $LN793@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T8[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN793@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T8[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T8[rsp], 0
$LN1584@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);

	lea	rcx, QWORD PTR init$[rsp]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR name$[rbp-232], 16
	jb	SHORT $LN825@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR name$[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN825@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);

	xor	al, al
	jmp	$LN23@readObject
$LN1551@readObject:

; 1457 :         return recoverFromError(tokenObjectEnd);

	mov	edx, 2
	mov	rcx, rdi
	call	?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z ; Json::OurReader::recoverFromError
	movzx	ebx, al
	lea	rcx, QWORD PTR numberName$21[rbp-256]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	jmp	SHORT $LN1580@readObject
$LN13@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T17[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T17[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T17[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 33					; 00000021H
	lea	rdx, OFFSET FLAT:??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
	lea	rcx, QWORD PTR $T17[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1782 :   addError(message, token);

	xor	r9d, r9d
	lea	r8, QWORD PTR tokenName$[rsp]
	lea	rdx, QWORD PTR $T17[rbp-256]
	mov	rcx, rdi
	call	?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::OurReader::addError

; 1783 :   return recoverFromError(skipUntilToken);

	mov	edx, 2
	mov	rcx, rdi
	call	?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z ; Json::OurReader::recoverFromError
	movzx	ebx, al
$LN1583@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T17[rbp-232], 16
	jb	SHORT $LN1499@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T17[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN1499@readObject:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T17[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T17[rbp-240], r15

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T17[rbp-232], 15
$LN1580@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);

	lea	rcx, QWORD PTR init$[rsp]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR name$[rbp-232], 16
	jb	SHORT $LN1531@readObject
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR name$[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN1531@readObject:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);

	movzx	eax, bl
$LN23@readObject:

; 1496 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+352]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN1577@readObject:
?readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z ENDP	; Json::OurReader::readObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$0@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$0
	lea	rcx, QWORD PTR name$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$10@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$10
	mov	rcx, QWORD PTR $T2[rdx]
	rex_jmp	QWORD PTR __imp_??3@YAXPEAX@Z
?dtor$10@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$1@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$1
	lea	rcx, QWORD PTR init$[rdx]
	jmp	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
?dtor$1@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$2@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$2
	lea	rcx, QWORD PTR numberName$21[rdx]
	jmp	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
?dtor$2@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$4@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$4
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$20@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$20
	lea	rcx, QWORD PTR info$9[rdx]
	jmp	??1ErrorInfo@OurReader@Json@@QEAA@XZ
?dtor$20@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$5@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$5
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$6@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$6
	lea	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$7@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$7
	lea	rcx, QWORD PTR msg$20[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$21@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$21
	lea	rcx, QWORD PTR info$4[rdx]
	jmp	??1ErrorInfo@OurReader@Json@@QEAA@XZ
?dtor$21@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$8@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$8
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tokenName$ = 32
init$ = 56
$T1 = 96
$T2 = 96
$T3 = 104
info$4 = 112
$T5 = 112
$T6 = 112
comma$7 = 112
$T8 = 112
info$9 = 176
$T10 = 176
$T11 = 176
$T12 = 176
name$ = 240
skip$13 = 272
skip$14 = 272
$T15 = 272
$T16 = 272
$T17 = 272
$T18 = 272
colon$19 = 272
msg$20 = 304
numberName$21 = 304
__$ArrayPad$ = 344
this$ = 400
tokenStart$ = 408
?dtor$9@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readObject'::`1'::dtor$9
	lea	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0??readObject@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readObject'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z PROC	; Json::OurReader::readArray, COMDAT

; 1498 : bool OurReader::readArray(Token& tokenStart) {

$LN579:
	mov	rax, rsp
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-248]
	sub	rsp, 464				; 000001d0H
	mov	QWORD PTR $T8[rsp], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r14, rdx
	mov	rdi, rcx
	xor	r12d, r12d
	mov	DWORD PTR $T2[rsp], r12d
	mov	r13d, DWORD PTR init$[rsp+8]
	and	r13d, -506				; fffffe06H
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	or	r13d, 6
	mov	DWORD PTR init$[rsp+8], r13d
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR init$[rsp+16], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR init$[rsp+32], r12

; 364  :     value_.map_ = new ObjectValues();

	lea	ecx, QWORD PTR [r12+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	rsi, rax
	mov	QWORD PTR $T3[rsp], rax
	test	rax, rax
	je	SHORT $LN30@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

	mov	QWORD PTR [rax], r12

; 570  : 		this->_Mysize = 0;

	mov	QWORD PTR [rax+8], r12

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<Json::Value::CZString const ,Json::Value>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > > >::_Buyheadnode
	mov	QWORD PTR [rsi], rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 364  :     value_.map_ = new ObjectValues();

	jmp	SHORT $LN31@readArray
$LN30@readArray:
	mov	rsi, r12
$LN31@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T13[rbp-256]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	mov	r8, r12
	je	SHORT $LN66@readArray
	mov	r8, QWORD PTR [rcx]
$LN66@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	r8, QWORD PTR [rcx+rdx*8]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	ecx, BYTE PTR [r8+8]

; 518  :   type_ = other.type_;

	movzx	eax, BYTE PTR init$[rsp+8]
	mov	BYTE PTR [r8+8], al

; 519  :   other.type_ = temp;

	mov	eax, r13d
	xor	eax, ecx
	movzx	eax, al
	xor	r13d, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rbx, QWORD PTR [r8]

; 53   : 	_Left = _Move(_Right);

	mov	QWORD PTR [r8], rsi

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR init$[rsp], rbx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [r8+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, ecx
	xor	eax, r13d
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, r13d
	and	edx, 256				; 00000100H
	xor	r13d, edx
	mov	DWORD PTR init$[rsp+8], r13d
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T12[rbp-256]
	mov	rcx, rdi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T5[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN91@readArray
	mov	r8, r12
	jmp	SHORT $LN92@readArray
$LN91@readArray:
	mov	r8, QWORD PTR [r8]
$LN92@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [rdi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rdx+24], rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1305 :   while (current_ != end_) {

	mov	rdx, QWORD PTR [rdi+120]
	cmp	QWORD PTR [rdi+128], rdx
	je	SHORT $LN99@readArray
	mov	r8, 4294977024				; 0000000100002600H
$LL101@readArray:

; 1306 :     Char c = *current_;

	mov	rcx, QWORD PTR [rdi+128]
	movzx	eax, BYTE PTR [rcx]
	cmp	al, 32					; 00000020H
	ja	SHORT $LN99@readArray
	bt	r8, rax
	jae	SHORT $LN99@readArray

; 1307 :     if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
; 1308 :       ++current_;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+128], rax

; 1305 :   while (current_ != end_) {

	cmp	rax, rdx
	jne	SHORT $LL101@readArray
$LN99@readArray:

; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array

	mov	rax, QWORD PTR [rdi+128]
	cmp	rax, rdx
	je	SHORT $LN9@readArray
	cmp	BYTE PTR [rax], 93			; 0000005dH
	jne	SHORT $LN9@readArray

; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);

	lea	rdx, QWORD PTR endArray$15[rbp-256]
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
$LN562@readArray:
	mov	dil, 1
	jmp	$LN18@readArray
$LN9@readArray:

; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;

	mov	r15d, r12d

; 1511 :     Value& value = currentValue()[index++];

	mov	esi, r12d
	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
	npad	6
$LL8@readArray:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 998  :   return (*this)[ArrayIndex(index)];

	mov	edx, esi
	mov	rcx, rax
	call	??AValue@Json@@QEAAAEAV01@I@Z		; Json::Value::operator[]
	mov	r12, rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1511 :     Value& value = currentValue()[index++];

	inc	r15d
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rdx, QWORD PTR [rdi+32]
	movzx	ecx, BYTE PTR [rdi+24]
	add	cl, dl
	test	cl, 1
	jne	SHORT $LN194@readArray
	lea	rcx, QWORD PTR [rdx+2]
	shr	rcx, 1
	cmp	QWORD PTR [rdi+16], rcx
	ja	SHORT $LN194@readArray
	mov	rcx, rdi
	call	?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Growmap
$LN194@readArray:
	mov	rdx, QWORD PTR [rdi+16]
	lea	rax, QWORD PTR [rdx*2-1]
	and	QWORD PTR [rdi+24], rax
	mov	r14, QWORD PTR [rdi+24]
	add	r14, QWORD PTR [rdi+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	lea	rsi, QWORD PTR [rdx-1]
	mov	rax, r14
	shr	rax, 1
	and	rsi, rax

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rdi+8]
	cmp	QWORD PTR [rax+rsi*8], 0
	jne	SHORT $LN193@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	je	$LN559@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rcx, QWORD PTR [rdi+8]
	mov	QWORD PTR [rcx+rsi*8], rax
$LN193@readArray:

; 1132 : 		this->_Getal().construct(
; 1133 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 			_STD forward<value_type>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	and	r14d, 1
	mov	rax, QWORD PTR [rax+rsi*8]
	lea	rcx, QWORD PTR [rax+r14*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN230@readArray
	mov	QWORD PTR [rcx], r12
$LN230@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1135 : 		_PUSH_BACK_END;

	inc	QWORD PTR [rdi+32]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1513 :     bool ok = readValue();

	mov	rcx, rdi
	call	?readValue@OurReader@Json@@AEAA_NXZ	; Json::OurReader::readValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1492 : 			this->_Myoff = 0;

	xor	r14d, r14d

; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1491 : 		if (--this->_Mysize == 0)

	dec	QWORD PTR [rdi+32]
	jne	SHORT $LN239@readArray

; 1492 : 			this->_Myoff = 0;

	mov	QWORD PTR [rdi+24], r14
$LN239@readArray:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1520 :     ok = readToken(token);

	mov	rcx, rdi

; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set

	test	al, al
	je	$LN560@readArray

; 1520 :     ok = readToken(token);

	lea	rdx, QWORD PTR token$7[rsp]
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken

; 1521 :     while (token.type_ == tokenComment && ok) {

	mov	ecx, DWORD PTR token$7[rsp]
	cmp	ecx, 15
	jne	SHORT $LN4@readArray
	npad	1
$LL5@readArray:
	test	al, al
	je	SHORT $LN4@readArray

; 1522 :       ok = readToken(token);

	lea	rdx, QWORD PTR token$7[rsp]
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken

; 1521 :     while (token.type_ == tokenComment && ok) {

	mov	ecx, DWORD PTR token$7[rsp]
	cmp	ecx, 15
	je	SHORT $LL5@readArray
$LN4@readArray:

; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);

	cmp	ecx, 13
	je	SHORT $LN12@readArray
	cmp	ecx, 4
	je	SHORT $LN12@readArray
	mov	dl, 1
	jmp	SHORT $LN13@readArray
$LN12@readArray:
	xor	dl, dl
$LN13@readArray:

; 1526 :     if (!ok || badTokenType) {

	test	al, al
	je	$LN2@readArray
	test	dl, dl
	jne	$LN2@readArray

; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)

	cmp	ecx, 4
	je	$LN562@readArray

; 1511 :     Value& value = currentValue()[index++];

	mov	esi, r15d
	mov	rcx, rdi
	call	?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ; Json::OurReader::currentValue
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 997  :       "in Json::Value::operator[](int index): index cannot be negative");

	test	r15d, r15d
	js	SHORT $LN574@readArray
	jmp	$LL8@readArray
$LN559@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN574@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 492  : 		{	// construct empty writable character buffer

	lea	rax, OFFSET FLAT:??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	mov	QWORD PTR oss$9[rsp], rax
	lea	rcx, QWORD PTR oss$9[rbp-120]
	call	QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	mov	DWORD PTR $T2[rsp], 1
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, QWORD PTR oss$9[rsp+8]
	lea	rcx, QWORD PTR oss$9[rsp]
	call	QWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	npad	1
	mov	rax, QWORD PTR oss$9[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR oss$9[rsp+rcx], rax
	mov	rax, QWORD PTR oss$9[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-136]
	mov	DWORD PTR oss$9[rsp+rcx-4], edx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

	lea	rcx, QWORD PTR oss$9[rsp+8]
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR oss$9[rsp+8], rax

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode
; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}
; 33   : 
; 34   : 	explicit basic_stringbuf(const _Mystr& _Str,
; 35   : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 36   : 		{	// construct character buffer from string, mode
; 37   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
; 38   : 		}
; 39   : 
; 40   : 	basic_stringbuf(_Myt&& _Right)
; 41   : 		{	// construct by moving _Right
; 42   : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 43   : 		}
; 44   : 
; 45   : 	_Myt& operator=(_Myt&& _Right)
; 46   : 		{	// assign from _Right
; 47   : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 48   : 		return (*this);
; 49   : 		}
; 50   : 
; 51   : 	void _Assign_rv(_Myt&& _Right)
; 52   : 		{	// assign by moving _Right
; 53   : 		if (this != &_Right)
; 54   : 			{	// different, worth moving
; 55   : 			_Tidy();
; 56   : 			this->swap(_Right);
; 57   : 			}
; 58   : 		}
; 59   : 
; 60   : 	void swap(_Myt& _Right)
; 61   : 		{	// swap with _Right
; 62   : 		if (this != &_Right)
; 63   : 			{	// different, worth swapping
; 64   : 			_Mysb::swap(_Right);
; 65   : 			_STD swap(_Seekhigh, _Right._Seekhigh);
; 66   : 			_STD swap(_Mystate, _Right._Mystate);
; 67   : 			_Swap_adl(_Al, _Right._Al);
; 68   : 			}
; 69   : 		}
; 70   : 
; 71   : 	basic_stringbuf(const _Myt&) = delete;
; 72   : 	_Myt& operator=(const _Myt&) = delete;
; 73   : 
; 74   : 	virtual ~basic_stringbuf() _NOEXCEPT
; 75   : 		{	// destroy the object
; 76   : 		_Tidy();
; 77   : 		}
; 78   : 
; 79   : 	enum
; 80   : 		{	// constants for bits in stream state
; 81   : 		_Allocated = 1,	// set if character array storage has been allocated
; 82   : 		_Constant = 2,	// set if character array nonmutable
; 83   : 		_Noread = 4,	// set if character array cannot be read
; 84   : 		_Append = 8,	// set if all writes are appends
; 85   : 		_Atend = 16};	// set if initial writes are appends
; 86   : 	typedef int _Strstate;
; 87   : 
; 88   : 	typedef typename _Traits::int_type int_type;
; 89   : 	typedef typename _Traits::pos_type pos_type;
; 90   : 	typedef typename _Traits::off_type off_type;
; 91   : 
; 92   : 	_Mystr str() const
; 93   : 		{	// return string copy of character array
; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)
; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);
; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)
; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());
; 103  : 			return (_Str);
; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;
; 108  : 			return (_Nul);
; 109  : 			}
; 110  : 		}
; 111  : 
; 112  : 	void str(const _Mystr& _Newstr)
; 113  : 		{	// replace character array from string
; 114  : 		_Tidy();
; 115  : 		_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
; 116  : 		}
; 117  : 
; 118  : protected:
; 119  : 	virtual int_type overflow(int_type _Meta = _Traits::eof())
; 120  : 		{	// put an element to stream
; 121  : 		if (_Mystate & _Constant)
; 122  : 			return (_Traits::eof());	// array nonmutable, fail
; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))
; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code
; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)
; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());
; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())
; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 134  : 			return (_Meta);
; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0
; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE
; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)
; 145  : 				_Inc /= 2;	// increment causes overflow, halve it
; 146  : 			if (_Inc == 0)
; 147  : 				return (_Traits::eof());	// buffer can't grow, fail
; 148  : 
; 149  : 			_Newsize += _Inc;
; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);
; 152  : 			_Elem *_Oldptr = _Mysb::eback();
; 153  : 
; 154  : 			if (0 < _Oldsize)
; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);
; 156  : 
; 157  : 			if (_Oldsize == 0)
; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);
; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 163  : 				else
; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);
; 165  : 				}
; 166  : 			else
; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)
; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 174  : 				else
; 175  : 					_Mysb::setg(_Newptr,
; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)
; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);
; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}
; 188  : 
; 189  : 	virtual int_type pbackfail(int_type _Meta = _Traits::eof())
; 190  : 		{	// put an element back to stream
; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)
; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail
; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);
; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);
; 202  : 			return (_Traits::not_eof(_Meta));
; 203  : 			}
; 204  : 		}
; 205  : 
; 206  : 	virtual int_type underflow()
; 207  : 		{	// get an element from stream, but don't point past it
; 208  : 		if (_Mysb::gptr() == 0)
; 209  : 			return (_Traits::eof());	// no character buffer, fail
; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())
; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered
; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))
; 214  : 			return (_Traits::eof());	// can't read, fail
; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())
; 218  : 				_Seekhigh = _Mysb::pptr();
; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));
; 221  : 			}
; 222  : 		}
; 223  : 
; 224  : 	virtual pos_type seekoff(off_type _Off,
; 225  : 		ios_base::seekdir _Way,
; 226  : 		ios_base::openmode _Which = ios_base::in | ios_base::out)
; 227  : 		{	// change position by _Off, according to _Way, _Mode
; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)
; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)
; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 235  : 			else if (_Way == ios_base::cur
; 236  : 				&& (_Which & ios_base::out) == 0)
; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());
; 238  : 			else if (_Way != ios_base::beg)
; 239  : 				_Off = _BADOFF;
; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else
; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)
; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 255  : 			else if (_Way == ios_base::cur)
; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());
; 257  : 			else if (_Way != ios_base::beg)
; 258  : 				_Off = _BADOFF;
; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 261  : 				_Mysb::pbump((int)(_Mysb::eback()
; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else
; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)
; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 271  : 		return (pos_type(_Off));
; 272  : 		}
; 273  : 
; 274  : 	virtual pos_type seekpos(pos_type _Ptr,
; 275  : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 276  : 		{	// change position to _Pos, according to _Mode
; 277  : 		streamoff _Off = (streamoff)_Ptr;
; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 280  : 
; 281  : 		if (_Off == _BADOFF)
; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)
; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else
; 293  : 				_Off = _BADOFF;
; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 298  : 				_Mysb::pbump((int)(_Mysb::eback()
; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else
; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 305  : 		return (streampos(_Off));
; 306  : 		}
; 307  : 
; 308  : 	void _Init(const _Elem *_Ptr,
; 309  : 		size_t _Count, _Strstate _State)
; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state
; 311  : 		_Seekhigh = 0;

	mov	QWORD PTR oss$9[rbp-144], r14

; 312  : 		_Mystate = _State;

	mov	DWORD PTR oss$9[rbp-136], 4
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 997  :       "in Json::Value::operator[](int index): index cannot be negative");

	lea	rdx, OFFSET FLAT:??_C@_0EA@BFHDEBDG@in?5Json?3?3Value?3?3operator?$FL?$FN?$CIint?5i@
	lea	rcx, QWORD PTR oss$9[rsp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, QWORD PTR $T11[rbp-256]
	lea	rcx, QWORD PTR oss$9[rsp]
	call	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
	npad	1
	mov	rcx, rax
	call	?throwLogicError@Json@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::throwLogicError
	npad	1
$LN2@readArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T14[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T14[rbp-240], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T14[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 39					; 00000027H
	lea	rdx, OFFSET FLAT:??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR info$10[rbp-208], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$10[rbp-216], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$10[rbp-232], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1759 :   info.token_ = token;

	movups	xmm0, XMMWORD PTR token$7[rsp]
	movaps	XMMWORD PTR info$10[rbp-256], xmm0
	movsdx	xmm1, QWORD PTR token$7[rsp+16]
	movsdx	QWORD PTR info$10[rbp-240], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T14[rbp-256]
	lea	rcx, QWORD PTR info$10[rbp-232]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1761 :   info.extra_ = extra;

	mov	QWORD PTR info$10[rbp-200], r14

; 1762 :   errors_.push_back(info);

	lea	rdx, QWORD PTR info$10[rbp-256]
	lea	rcx, QWORD PTR [rdi+40]
	call	?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$10[rbp-208], 16
	jb	SHORT $LN411@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$10[rbp-232]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN411@readArray:
	mov	QWORD PTR info$10[rbp-208], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$10[rbp-216], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$10[rbp-232], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1352 : 		return (this->_Mysize);

	mov	r14, QWORD PTR [rdi+72]
$LL427@readArray:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1770 :     if (!readToken(skip))

	lea	rdx, QWORD PTR skip$4[rsp]
	mov	rcx, rdi
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	test	al, al
	jne	SHORT $LN425@readArray

; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery

	mov	rdx, r14
	lea	rcx, QWORD PTR [rdi+40]
	call	?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize
$LN425@readArray:

; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)

	mov	eax, DWORD PTR skip$4[rsp]
	cmp	eax, 4
	je	SHORT $LN563@readArray
	test	eax, eax
	jne	SHORT $LL427@readArray
$LN563@readArray:

; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);

	mov	rdx, r14
	lea	rcx, QWORD PTR [rdi+40]
	call	?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize

; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);

	xor	dil, dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T14[rbp-232], 16
	jb	SHORT $LN18@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T14[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	jmp	SHORT $LN18@readArray
$LN560@readArray:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1516 :       return recoverFromError(tokenArrayEnd);

	mov	edx, 4
	call	?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z ; Json::OurReader::recoverFromError
	movzx	edi, al
$LN18@readArray:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 487  :   switch (type_) {

	movsx	eax, BYTE PTR init$[rsp+8]
	cmp	eax, 4
	je	SHORT $LN467@readArray
	add	eax, -6					; fffffffaH
	cmp	eax, 1
	ja	SHORT $LN477@readArray

; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;

	test	rbx, rbx
	je	SHORT $LN477@readArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

	mov	r8, QWORD PTR [rbx]
	mov	r9, r8
	mov	r8, QWORD PTR [r8]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	mov	rcx, rbx
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 501  :     break;

	jmp	SHORT $LN477@readArray
$LN467@readArray:

; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)

	bt	r13d, 8
	jae	SHORT $LN477@readArray

; 170  :   free(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN477@readArray:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1533 :   return true;

	movzx	eax, dil

; 1534 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+464]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN578@readArray:
?readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z ENDP	; Json::OurReader::readArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$2@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readArray'::`1'::dtor$2
	mov	rcx, QWORD PTR $T3[rdx]
	rex_jmp	QWORD PTR __imp_??3@YAXPEAX@Z
?dtor$2@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readArray'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$0@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readArray'::`1'::dtor$0
	lea	rcx, QWORD PTR init$[rdx]
	jmp	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
?dtor$0@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readArray'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$9@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readArray'::`1'::dtor$9
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN113@dtor$9
	and	DWORD PTR $T2[rbp], -2
	lea	rcx, QWORD PTR oss$9[rbp]
	add	rcx, 136				; 00000088H
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN113@dtor$9:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$9@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readArray'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$10@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readArray'::`1'::dtor$10
	lea	rcx, QWORD PTR oss$9[rdx]
	add	rcx, 16
	rex_jmp	QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$10@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readArray'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$12@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readArray'::`1'::dtor$12
	mov	rcx, QWORD PTR this$16[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$12@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readArray'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$7@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readArray'::`1'::dtor$7
	lea	rcx, QWORD PTR oss$9[rdx]
	jmp	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$7@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readArray'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$8@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readArray'::`1'::dtor$8
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readArray'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$1@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readArray'::`1'::dtor$1
	lea	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readArray'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
skip$4 = 40
$T5 = 40
$T6 = 40
token$7 = 40
init$ = 64
$T8 = 104
oss$9 = 112
info$10 = 352
$T11 = 416
$T12 = 416
$T13 = 416
$T14 = 416
endArray$15 = 416
this$16 = 448
__$ArrayPad$ = 456
this$ = 512
tokenStart$ = 520
?dtor$13@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::readArray'::`1'::dtor$13
	lea	rcx, QWORD PTR info$10[rdx]
	jmp	??1ErrorInfo@OurReader@Json@@QEAA@XZ
?dtor$13@?0??readArray@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::readArray'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z
_TEXT	SEGMENT
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 64
$T5 = 64
$T6 = 64
decoded$ = 88
this$ = 160
token$ = 168
$T7 = 176
?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z PROC ; Json::OurReader::decodeNumber, COMDAT

; 1536 : bool OurReader::decodeNumber(Token& token) {

$LN193:
	mov	rax, rsp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 128				; 00000080H
	mov	QWORD PTR [rax-120], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	r14, rdx
	mov	rsi, rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1023 :   allocated_ = allocated;

	and	DWORD PTR [rax-56], -512		; fffffe00H
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR [rax-48], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	xor	edi, edi
	mov	QWORD PTR [rax-32], rdi
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1538 :   if (!decodeNumber(token, decoded))

	lea	r8, QWORD PTR [rax-64]
	call	?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ; Json::OurReader::decodeNumber
	test	al, al
	jne	SHORT $LN1@decodeNumb
	mov	ebp, DWORD PTR decoded$[rsp+8]
	mov	rbx, QWORD PTR decoded$[rsp]
	jmp	$LN5@decodeNumb
$LN1@decodeNumb:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rsi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T6[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	mov	r8, rdi
	je	SHORT $LN53@decodeNumb
	mov	r8, QWORD PTR [rcx]
$LN53@decodeNumb:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	r8, QWORD PTR [rcx+rdx*8]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	ecx, BYTE PTR [r8+8]

; 518  :   type_ = other.type_;

	movzx	eax, BYTE PTR decoded$[rsp+8]
	mov	BYTE PTR [r8+8], al

; 519  :   other.type_ = temp;

	mov	ebp, DWORD PTR decoded$[rsp+8]
	mov	eax, ebp
	xor	eax, ecx
	movzx	eax, al
	xor	ebp, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rbx, QWORD PTR [r8]

; 53   : 	_Left = _Move(_Right);

	mov	rax, QWORD PTR decoded$[rsp]
	mov	QWORD PTR [r8], rax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [r8+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, ecx
	xor	eax, ebp
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, ebp
	and	edx, 256				; 00000100H
	xor	ebp, edx
	mov	DWORD PTR decoded$[rsp+8], ebp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, rsi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T2[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN78@decodeNumb
	mov	r8, rdi
	jmp	SHORT $LN79@decodeNumb
$LN78@decodeNumb:
	mov	r8, QWORD PTR [r8]
$LN79@decodeNumb:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [rsi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rdx+24], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rsi
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T1[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN97@decodeNumb
	mov	rdi, QWORD PTR [rcx]
$LN97@decodeNumb:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [rdi+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, QWORD PTR [rsi+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1422 : void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

	mov	QWORD PTR [rdx+32], rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1543 :   return true;

	mov	dil, 1
$LN5@decodeNumb:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 487  :   switch (type_) {

	movsx	eax, BYTE PTR decoded$[rsp+8]
	cmp	eax, 4
	je	SHORT $LN105@decodeNumb
	add	eax, -6					; fffffffaH
	cmp	eax, 1
	ja	SHORT $LN115@decodeNumb

; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;

	test	rbx, rbx
	je	SHORT $LN115@decodeNumb
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

	mov	r8, QWORD PTR [rbx]
	mov	r9, r8
	mov	r8, QWORD PTR [r8]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, rbx
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	mov	rcx, rbx
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 501  :     break;

	jmp	SHORT $LN115@decodeNumb
$LN105@decodeNumb:

; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)

	bt	ebp, 8
	jae	SHORT $LN115@decodeNumb

; 170  :   free(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN115@decodeNumb:

; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;

	mov	rcx, QWORD PTR decoded$[rsp+16]
	test	rcx, rcx
	je	SHORT $LN192@decodeNumb
	lea	rbx, QWORD PTR [rcx-8]
	lea	r9, OFFSET FLAT:??1CommentInfo@Value@Json@@QEAA@XZ ; Json::Value::CommentInfo::~CommentInfo
	mov	r8d, DWORD PTR [rbx]
	mov	edx, 8
	call	??_M@YAXPEAX_KHP6AX0@Z@Z
	mov	rcx, rbx
	call	QWORD PTR __imp_??_V@YAXPEAX@Z
$LN192@decodeNumb:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1543 :   return true;

	movzx	eax, dil

; 1544 : }

	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z ENDP ; Json::OurReader::decodeNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 64
$T5 = 64
$T6 = 64
decoded$ = 88
this$ = 160
token$ = 168
$T7 = 176
?dtor$0@?0??decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::decodeNumber'::`1'::dtor$0
	lea	rcx, QWORD PTR decoded$[rdx]
	jmp	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
?dtor$0@?0??decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::decodeNumber'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
this$ = 96
token$ = 104
decoded$ = 112
?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z PROC ; Json::OurReader::decodeNumber, COMDAT

; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 80					; 00000050H

; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;

	mov	r9, QWORD PTR [rdx+8]
	mov	rbx, r8
	mov	rsi, rdx

; 1551 :   bool isNegative = *current == '-';

	cmp	BYTE PTR [r9], 45			; 0000002dH
	mov	r14, rcx
	sete	bpl

; 1552 :   if (isNegative)

	test	bpl, bpl
	je	SHORT $LN15@decodeNumb

; 1553 :     ++current;

	inc	r9

; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;

	mov	rdi, -9223372036854775808		; 8000000000000000H
	jmp	SHORT $LN16@decodeNumb
$LN15@decodeNumb:
	or	rdi, -1
$LN16@decodeNumb:
	mov	r11, QWORD PTR [rsi+16]

; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;

	mov	rax, -3689348814741910323		; cccccccccccccccdH

; 1559 :   Value::LargestUInt value = 0;

	xor	r8d, r8d
	mul	rdi
	mov	r10, rdx
	shr	r10, 3

; 1560 :   while (current < token.end_) {

	cmp	r9, r11
	jae	SHORT $LN10@decodeNumb
	npad	9
$LL11@decodeNumb:

; 1561 :     Char c = *current++;

	movzx	eax, BYTE PTR [r9]
	inc	r9

; 1562 :     if (c < '0' || c > '9')

	cmp	al, 48					; 00000030H
	jl	SHORT $LN8@decodeNumb
	cmp	al, 57					; 00000039H
	jg	SHORT $LN8@decodeNumb

; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));

	movsx	edx, al
	sub	edx, 48					; 00000030H

; 1565 :     if (value >= threshold) {

	cmp	r8, r10
	jb	SHORT $LN6@decodeNumb

; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {

	ja	SHORT $LN8@decodeNumb
	cmp	r9, r11
	jne	SHORT $LN8@decodeNumb
	lea	rax, QWORD PTR [r10+r10*4]
	mov	rcx, rdi
	add	rax, rax
	sub	rcx, rax
	mov	eax, edx
	cmp	rax, rcx
	ja	SHORT $LN8@decodeNumb
$LN6@decodeNumb:

; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;

	lea	rcx, QWORD PTR [r8+r8*4]
	mov	eax, edx
	lea	r8, QWORD PTR [rdx+rcx*2]
	cmp	r9, r11
	jb	SHORT $LL11@decodeNumb
$LN10@decodeNumb:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1022 :   type_ = vtype;

	mov	BYTE PTR $T2[rsp+8], 1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1577 :   if (isNegative)

	test	bpl, bpl
	je	SHORT $LN4@decodeNumb

; 1578 :     decoded = -Value::LargestInt(value);

	neg	r8
	jmp	SHORT $LN38@decodeNumb
$LN8@decodeNumb:

; 1563 :       return decodeDouble(token, decoded);

	mov	r8, rbx
	mov	rdx, rsi
	mov	rcx, r14
	call	?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ; Json::OurReader::decodeDouble
	jmp	SHORT $LN13@decodeNumb
$LN4@decodeNumb:

; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))

	cmp	r8, 2147483647				; 7fffffffH
	jbe	SHORT $LN38@decodeNumb
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1022 :   type_ = vtype;

	mov	BYTE PTR $T1[rsp+8], 2
$LN38@decodeNumb:

; 1023 :   allocated_ = allocated;

	and	DWORD PTR $T1[rsp+8], -257		; fffffeffH
	xorps	xmm0, xmm0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1582 :     decoded = value;

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1026 :   limit_ = 0;

	mov	QWORD PTR $T1[rsp+32], 0

; 390  :   value_.uint_ = value;

	mov	QWORD PTR $T1[rsp], r8
	movdqu	XMMWORD PTR $T1[rsp+16], xmm0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1582 :     decoded = value;

	call	??4Value@Json@@QEAAAEAV01@V01@@Z	; Json::Value::operator=

; 1583 :   return true;

	mov	al, 1
$LN13@decodeNumb:

; 1584 : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	r14
	ret	0
?decodeNumber@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ENDP ; Json::OurReader::decodeNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z
_TEXT	SEGMENT
value$ = 32
$T1 = 40
info$2 = 48
$T3 = 48
$T4 = 48
buffer$5 = 48
format$ = 112
$T6 = 120
buffer$7 = 120
$T8 = 120
$T9 = 152
__$ArrayPad$ = 184
this$ = 256
token$ = 264
decoded$ = 272
?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z PROC ; Json::OurReader::decodeDouble, COMDAT

; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {

$LN455:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 192				; 000000c0H
	mov	QWORD PTR $T1[rbp-153], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-153], rax
	mov	r15, r8
	mov	r14, rdx
	mov	r13, rcx
	xorps	xmm0, xmm0

; 1597 :   double value = 0;

	movsdx	QWORD PTR value$[rbp-153], xmm0

; 1600 :   ptrdiff_t const length = token.end_ - token.start_;

	mov	r8, QWORD PTR [rdx+16]
	mov	rdx, QWORD PTR [rdx+8]
	mov	rbx, r8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	edi, edi
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1600 :   ptrdiff_t const length = token.end_ - token.start_;

	sub	rbx, rdx

; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {

	jns	$LN4@decodeDoub
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-129], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T8[rbp-137], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T8[rbp-153], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+28]
	lea	rdx, OFFSET FLAT:??_C@_0BN@MIBOPDFC@Unable?5to?5parse?5token?5length?$AA@
	lea	rcx, QWORD PTR $T8[rbp-153]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR info$2[rbp-105], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$2[rbp-113], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$2[rbp-129], dil
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1759 :   info.token_ = token;

	movups	xmm0, XMMWORD PTR [r14]
	movaps	XMMWORD PTR info$2[rbp-153], xmm0
	movsdx	xmm1, QWORD PTR [r14+16]
	movsdx	QWORD PTR info$2[rbp-137], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T8[rbp-153]
	lea	rcx, QWORD PTR info$2[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1761 :   info.extra_ = extra;

	mov	QWORD PTR info$2[rbp-97], rdi

; 1762 :   errors_.push_back(info);

	lea	rcx, QWORD PTR [r13+40]
	lea	rdx, QWORD PTR info$2[rbp-153]
	call	?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$2[rbp-105], 16
	jb	SHORT $LN178@decodeDoub
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$2[rbp-129]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN178@decodeDoub:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T8[rbp-129], 16
	jb	SHORT $LN210@decodeDoub
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T8[rbp-153]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN210@decodeDoub:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1604 :     return addError("Unable to parse token length", token);

	xor	al, al
	jmp	$LN5@decodeDoub
$LN4@decodeDoub:

; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";

	mov	DWORD PTR format$[rbp-153], 6712357	; 00666c25H

; 1614 : 
; 1615 :   if (length <= bufferSize) {

	cmp	rbx, 32					; 00000020H
	jg	SHORT $LN3@decodeDoub

; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);

	mov	r8, rbx
	lea	rcx, QWORD PTR buffer$5[rbp-153]
	call	memcpy

; 1618 :     buffer[length] = 0;

	cmp	rbx, 33					; 00000021H
	jae	SHORT $LN7@decodeDoub
	lea	rsi, QWORD PTR buffer$5[rbp-153]
	add	rsi, rbx
	mov	BYTE PTR [rsi], dil

; 1619 :     fixNumericLocaleInput(buffer, buffer + length);

	lea	rbx, QWORD PTR buffer$5[rbp-153]
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 30   :   struct lconv* lc = localeconv();

	call	QWORD PTR __imp_localeconv

; 31   :   return lc ? *(lc->decimal_point) : '\0';

	test	rax, rax
	je	SHORT $LN223@decodeDoub
	mov	rax, QWORD PTR [rax]
	movzx	ecx, BYTE PTR [rax]

; 32   : #endif
; 33   : }
; 34   : 
; 35   : /// Converts a unicode code-point to UTF-8.
; 36   : static inline JSONCPP_STRING codePointToUTF8(unsigned int cp) {
; 37   :   JSONCPP_STRING result;
; 38   : 
; 39   :   // based on description from http://en.wikipedia.org/wiki/UTF-8
; 40   : 
; 41   :   if (cp <= 0x7f) {
; 42   :     result.resize(1);
; 43   :     result[0] = static_cast<char>(cp);
; 44   :   } else if (cp <= 0x7FF) {
; 45   :     result.resize(2);
; 46   :     result[1] = static_cast<char>(0x80 | (0x3f & cp));
; 47   :     result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));
; 48   :   } else if (cp <= 0xFFFF) {
; 49   :     result.resize(3);
; 50   :     result[2] = static_cast<char>(0x80 | (0x3f & cp));
; 51   :     result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));
; 52   :     result[0] = static_cast<char>(0xE0 | (0xf & (cp >> 12)));
; 53   :   } else if (cp <= 0x10FFFF) {
; 54   :     result.resize(4);
; 55   :     result[3] = static_cast<char>(0x80 | (0x3f & cp));
; 56   :     result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));
; 57   :     result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));
; 58   :     result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));
; 59   :   }
; 60   : 
; 61   :   return result;
; 62   : }
; 63   : 
; 64   : /// Returns true if ch is a control character (in range [1,31]).
; 65   : static inline bool isControlCharacter(char ch) { return ch > 0 && ch <= 0x1F; }
; 66   : 
; 67   : enum {
; 68   :   /// Constant that specify the size of the buffer that must be passed to
; 69   :   /// uintToString.
; 70   :   uintToStringBufferSize = 3 * sizeof(LargestUInt) + 1
; 71   : };
; 72   : 
; 73   : // Defines a char buffer for use with uintToString().
; 74   : typedef char UIntToStringBuffer[uintToStringBufferSize];
; 75   : 
; 76   : /** Converts an unsigned integer to string.
; 77   :  * @param value Unsigned interger to convert to string
; 78   :  * @param current Input/Output string buffer.
; 79   :  *        Must have at least uintToStringBufferSize chars free.
; 80   :  */
; 81   : static inline void uintToString(LargestUInt value, char*& current) {
; 82   :   *--current = 0;
; 83   :   do {
; 84   :     *--current = static_cast<char>(value % 10U + static_cast<unsigned>('0'));
; 85   :     value /= 10;
; 86   :   } while (value != 0);
; 87   : }
; 88   : 
; 89   : /** Change ',' to '.' everywhere in buffer.
; 90   :  *
; 91   :  * We had a sophisticated way, but it did not work in WinCE.
; 92   :  * @see https://github.com/open-source-parsers/jsoncpp/pull/9
; 93   :  */
; 94   : static inline void fixNumericLocale(char* begin, char* end) {
; 95   :   while (begin < end) {
; 96   :     if (*begin == ',') {
; 97   :       *begin = '.';
; 98   :     }
; 99   :     ++begin;
; 100  :   }
; 101  : }
; 102  : 
; 103  : static inline void fixNumericLocaleInput(char* begin, char* end) {
; 104  :   char decimalPoint = getDecimalPoint();
; 105  :   if (decimalPoint != '\0' && decimalPoint != '.') {

	test	cl, cl
	je	SHORT $LN223@decodeDoub
	cmp	cl, 46					; 0000002eH
	je	SHORT $LN223@decodeDoub

; 106  :     while (begin < end) {

	lea	rax, QWORD PTR buffer$5[rbp-153]
	cmp	rax, rsi
	jae	SHORT $LN223@decodeDoub
	npad	4
$LL224@decodeDoub:

; 107  :       if (*begin == '.') {

	cmp	BYTE PTR [rbx], 46			; 0000002eH
	jne	SHORT $LN222@decodeDoub

; 108  :         *begin = decimalPoint;

	mov	BYTE PTR [rbx], cl
$LN222@decodeDoub:

; 109  :       }
; 110  :       ++begin;

	inc	rbx

; 106  :     while (begin < end) {

	cmp	rbx, rsi
	jb	SHORT $LL224@decodeDoub
$LN223@decodeDoub:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1620 :     count = sscanf(buffer, format, &value);

	lea	r8, QWORD PTR value$[rbp-153]
	lea	rdx, QWORD PTR format$[rbp-153]
	lea	rcx, QWORD PTR buffer$5[rbp-153]
	call	QWORD PTR __imp_sscanf
	mov	ebx, eax

; 1621 :   } else {

	jmp	SHORT $LN299@decodeDoub
$LN7@decodeDoub:

; 1618 :     buffer[length] = 0;

	call	__report_rangecheckfailure
	int	3
$LN3@decodeDoub:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR buffer$7[rbp-129], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR buffer$7[rbp-137], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR buffer$7[rbp-153], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 862  : 		if (_First != _Last)

	cmp	rdx, r8
	je	SHORT $LN275@decodeDoub

; 863  : 			assign(&*_First, _Last - _First);

	sub	r8, rdx
	lea	rcx, QWORD PTR buffer$7[rbp-153]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR buffer$7[rbp-129], 16
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR buffer$7[rbp-153]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	jae	SHORT $LN276@decodeDoub
$LN275@decodeDoub:
	lea	rcx, QWORD PTR buffer$7[rbp-153]
$LN276@decodeDoub:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1623 :     count = sscanf(buffer.c_str(), format, &value);

	lea	r8, QWORD PTR value$[rbp-153]
	lea	rdx, QWORD PTR format$[rbp-153]
	call	QWORD PTR __imp_sscanf
	mov	ebx, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR buffer$7[rbp-129], 16
	jb	SHORT $LN299@decodeDoub
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR buffer$7[rbp-153]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN299@decodeDoub:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1626 :   if (count != 1)

	cmp	ebx, 1
	je	$LN1@decodeDoub

; 1629 :                     token);

	mov	r8, QWORD PTR [r14+16]
	mov	rdx, QWORD PTR [r14+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T6[rbp-129], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T6[rbp-137], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T6[rbp-153], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 862  : 		if (_First != _Last)

	cmp	rdx, r8
	je	SHORT $LN311@decodeDoub

; 863  : 			assign(&*_First, _Last - _First);

	sub	r8, rdx
	lea	rcx, QWORD PTR $T6[rbp-153]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
$LN311@decodeDoub:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1629 :                     token);

	lea	r8, QWORD PTR $T6[rbp-153]
	lea	rdx, OFFSET FLAT:??_C@_01GEODFPGF@?8?$AA@
	lea	rcx, QWORD PTR $T4[rbp-153]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	mov	rdx, rax
	lea	rcx, QWORD PTR $T9[rbp-153]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@PEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	xor	r9d, r9d
	mov	r8, r14
	mov	rdx, rax
	mov	rcx, r13
	call	?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::OurReader::addError
	movzx	ebx, al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T9[rbp-129], 16
	jb	SHORT $LN370@decodeDoub
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T9[rbp-153]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN370@decodeDoub:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T9[rbp-129], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T9[rbp-137], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T9[rbp-153], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-129], 16
	jb	SHORT $LN402@decodeDoub
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rbp-153]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN402@decodeDoub:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-129], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-137], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rbp-153], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T6[rbp-129], 16
	jb	SHORT $LN434@decodeDoub
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T6[rbp-153]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN434@decodeDoub:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1629 :                     token);

	movzx	eax, bl
	jmp	SHORT $LN5@decodeDoub
$LN1@decodeDoub:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1022 :   type_ = vtype;

	mov	BYTE PTR $T3[rbp-145], 3

; 1023 :   allocated_ = allocated;

	and	DWORD PTR $T3[rbp-145], -257		; fffffeffH
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR $T3[rbp-137], xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR $T3[rbp-121], rdi

; 396  :   value_.real_ = value;

	movsdx	xmm0, QWORD PTR value$[rbp-153]
	movsdx	QWORD PTR $T3[rbp-153], xmm0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1630 :   decoded = value;

	lea	rdx, QWORD PTR $T3[rbp-153]
	mov	rcx, r15
	call	??4Value@Json@@QEAAAEAV01@V01@@Z	; Json::Value::operator=

; 1631 :   return true;

	mov	al, 1
$LN5@decodeDoub:

; 1632 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-153]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 192				; 000000c0H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN454@decodeDoub:
?decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z ENDP ; Json::OurReader::decodeDouble
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
value$ = 32
$T1 = 40
info$2 = 48
$T3 = 48
$T4 = 48
buffer$5 = 48
format$ = 112
$T6 = 120
buffer$7 = 120
$T8 = 120
$T9 = 152
__$ArrayPad$ = 184
this$ = 256
token$ = 264
decoded$ = 272
?dtor$0@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::OurReader::decodeDouble'::`1'::dtor$0
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::OurReader::decodeDouble'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
value$ = 32
$T1 = 40
info$2 = 48
$T3 = 48
$T4 = 48
buffer$5 = 48
format$ = 112
$T6 = 120
buffer$7 = 120
$T8 = 120
$T9 = 152
__$ArrayPad$ = 184
this$ = 256
token$ = 264
decoded$ = 272
?dtor$6@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::OurReader::decodeDouble'::`1'::dtor$6
	lea	rcx, QWORD PTR info$2[rdx]
	jmp	??1ErrorInfo@OurReader@Json@@QEAA@XZ
?dtor$6@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::OurReader::decodeDouble'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
value$ = 32
$T1 = 40
info$2 = 48
$T3 = 48
$T4 = 48
buffer$5 = 48
format$ = 112
$T6 = 120
buffer$7 = 120
$T8 = 120
$T9 = 152
__$ArrayPad$ = 184
this$ = 256
token$ = 264
decoded$ = 272
?dtor$2@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::OurReader::decodeDouble'::`1'::dtor$2
	lea	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::OurReader::decodeDouble'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
value$ = 32
$T1 = 40
info$2 = 48
$T3 = 48
$T4 = 48
buffer$5 = 48
format$ = 112
$T6 = 120
buffer$7 = 120
$T8 = 120
$T9 = 152
__$ArrayPad$ = 184
this$ = 256
token$ = 264
decoded$ = 272
?dtor$3@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::OurReader::decodeDouble'::`1'::dtor$3
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::OurReader::decodeDouble'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
value$ = 32
$T1 = 40
info$2 = 48
$T3 = 48
$T4 = 48
buffer$5 = 48
format$ = 112
$T6 = 120
buffer$7 = 120
$T8 = 120
$T9 = 152
__$ArrayPad$ = 184
this$ = 256
token$ = 264
decoded$ = 272
?dtor$4@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA PROC ; `Json::OurReader::decodeDouble'::`1'::dtor$4
	lea	rcx, QWORD PTR $T9[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??decodeDouble@OurReader@Json@@AEAA_NAEAVToken@12@AEAVValue@2@@Z@4HA ENDP ; `Json::OurReader::decodeDouble'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 80
decoded$ = 88
decoded_string$ = 136
__$ArrayPad$ = 168
this$ = 224
token$ = 232
?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z PROC ; Json::OurReader::decodeString, COMDAT

; 1634 : bool OurReader::decodeString(Token& token) {

$LN278:
	mov	r11, rsp
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 176				; 000000b0H
	mov	QWORD PTR [r11-88], -2
	mov	QWORD PTR [r11+24], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, rdx
	mov	rbp, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [r11-56], 15

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	edi, edi
	mov	QWORD PTR [r11-64], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [r11-80], dil
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1636 :   if (!decodeString(token, decoded_string))

	lea	r8, QWORD PTR [r11-80]
	call	?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::OurReader::decodeString
	test	al, al
	je	$LN168@decodeStri
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1022 :   type_ = vtype;

	mov	esi, DWORD PTR decoded$[rsp+8]
	and	esi, -252				; ffffff04H

; 1023 :   allocated_ = allocated;

	or	esi, 260				; 00000104H
	mov	DWORD PTR decoded$[rsp+8], esi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rcx, QWORD PTR decoded_string$[rsp]
	cmp	QWORD PTR decoded_string$[rsp+24], 16
	cmovae	rcx, QWORD PTR decoded_string$[rsp]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));

	mov	edx, DWORD PTR decoded_string$[rsp+16]
	call	?duplicateAndPrefixStringValue@Json@@YAPEADPEBDI@Z ; Json::duplicateAndPrefixStringValue
	mov	r15, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rbp
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T6[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	mov	r8, rdi
	je	SHORT $LN106@decodeStri
	mov	r8, QWORD PTR [rcx]
$LN106@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	r8, QWORD PTR [rcx+rdx*8]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 517  :   ValueType temp = type_;

	movsx	ecx, BYTE PTR [r8+8]

; 518  :   type_ = other.type_;

	movzx	eax, BYTE PTR decoded$[rsp+8]
	mov	BYTE PTR [r8+8], al

; 519  :   other.type_ = temp;

	mov	eax, esi
	xor	eax, ecx
	movzx	eax, al
	xor	esi, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rbx, QWORD PTR [r8]

; 53   : 	_Left = _Move(_Right);

	mov	QWORD PTR [r8], r15
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 521  :   int temp2 = allocated_;

	mov	ecx, DWORD PTR [r8+8]
	mov	edx, ecx
	shr	edx, 8
	and	edx, 1

; 522  :   allocated_ = other.allocated_;

	mov	eax, ecx
	xor	eax, esi
	and	eax, 256				; 00000100H
	xor	eax, ecx
	mov	DWORD PTR [r8+8], eax

; 523  :   other.allocated_ = temp2 & 0x1;

	shl	edx, 8
	xor	edx, esi
	and	edx, 256				; 00000100H
	xor	esi, edx
	mov	DWORD PTR decoded$[rsp+8], esi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, rbp
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T2[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	jne	SHORT $LN131@decodeStri
	mov	r8, rdi
	jmp	SHORT $LN132@decodeStri
$LN131@decodeStri:
	mov	r8, QWORD PTR [r8]
$LN132@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [r8+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [rbp+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1420 : void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	mov	QWORD PTR [rdx+24], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rbp
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	mov	rcx, rax
	lea	rdx, QWORD PTR $T1[rsp]
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN150@decodeStri
	mov	rdi, QWORD PTR [rcx]
$LN150@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [rdi+16]
	dec	rcx
	mov	rax, rdx
	shr	rax, 1
	and	rcx, rax

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rax+rcx*8]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	rdx, QWORD PTR [rcx+rdx*8]

; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, QWORD PTR [rbp+112]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1422 : void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

	mov	QWORD PTR [rdx+32], rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1642 :   return true;

	mov	dil, 1
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 487  :   switch (type_) {

	movsx	eax, BYTE PTR decoded$[rsp+8]
	cmp	eax, 4
	je	SHORT $LN158@decodeStri
	add	eax, -6					; fffffffaH
	cmp	eax, 1
	ja	SHORT $LN168@decodeStri

; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;

	test	rbx, rbx
	je	SHORT $LN168@decodeStri
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

	mov	r8, QWORD PTR [rbx]

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();
; 774  : 		}
; 775  : 
; 776  : 	~_Tree_alloc() _NOEXCEPT
; 777  : 		{	// destroy head node
; 778  : 		_Freeheadnode(this->_Myhead);
; 779  : 		}
; 780  : 
; 781  : 	void _Change_alloc(const _Alty&)
; 782  : 		{	// replace old allocator
; 783  : 		}
; 784  : 
; 785  : 	void _Swap_alloc(_Myt&)
; 786  : 		{	// swap allocators
; 787  : 		}
; 788  : 
; 789  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 790  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 791  : 		{	// construct allocators from _Al
; 792  : 		this->_Myhead = _Buyheadnode();
; 793  : 		_TRY_BEGIN
; 794  : 		_Alloc_proxy();
; 795  : 		_CATCH_ALL
; 796  : 		_Freeheadnode(this->_Myhead);
; 797  : 		_RERAISE;
; 798  : 		_CATCH_END
; 799  : 		}
; 800  : 
; 801  : 	~_Tree_alloc() _NOEXCEPT
; 802  : 		{	// destroy proxy
; 803  : 		_Freeheadnode(this->_Myhead);
; 804  : 		_Free_proxy();
; 805  : 		}
; 806  : 
; 807  : 	void _Change_alloc(const _Alty&)
; 808  : 		{	// replace old allocator
; 809  : 		}
; 810  : 
; 811  : 	void _Swap_alloc(_Myt&)
; 812  : 		{	// swap allocators
; 813  : 		}
; 814  : 
; 815  : 	void _Alloc_proxy()
; 816  : 		{	// construct proxy from _Alnod
; 817  : 		typename _Alty::template rebind<_Container_proxy>::other
; 818  : 			_Alproxy(_Getal());
; 819  : 		this->_Myproxy = _Alproxy.allocate(1);
; 820  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 821  : 		this->_Myproxy->_Mycont = this;
; 822  : 		}
; 823  : 
; 824  : 	void _Free_proxy()
; 825  : 		{	// destroy proxy
; 826  : 		typename _Alty::template rebind<_Container_proxy>::other
; 827  : 			_Alproxy(_Getal());
; 828  : 		this->_Orphan_all();
; 829  : 		_Alproxy.destroy(this->_Myproxy);
; 830  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 831  : 		this->_Myproxy = 0;
; 832  : 		}
; 833  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 834  : 
; 835  : 	_Nodeptr _Buyheadnode()
; 836  : 		{	// get head node using current allocator
; 837  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 838  : 
; 839  : 		_TRY_BEGIN
; 840  : 		this->_Getal().construct(
; 841  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 842  : 		this->_Getal().construct(
; 843  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 844  : 		this->_Getal().construct(
; 845  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 846  : 		_CATCH_ALL
; 847  : 		this->_Getal().deallocate(_Pnode, 1);
; 848  : 		_RERAISE;
; 849  : 		_CATCH_END
; 850  : 
; 851  : 		this->_Color(_Pnode) = this->_Black;
; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}
; 855  : 
; 856  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 857  : 		{	// free head node using current allocator
; 858  : 		this->_Getal().destroy(
; 859  : 			_STD addressof(this->_Left(_Pnode)));
; 860  : 		this->_Getal().destroy(
; 861  : 			_STD addressof(this->_Parent(_Pnode)));
; 862  : 		this->_Getal().destroy(
; 863  : 			_STD addressof(this->_Right(_Pnode)));
; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());
; 870  : 		}
; 871  : 	};
; 872  : 
; 873  : 		// TEMPLATE CLASS _Tree_buy
; 874  : template<class _Ty,
; 875  : 	class _Alloc>
; 876  : 	class _Tree_buy
; 877  : 		: public _Tree_alloc<!is_empty<_Alloc>::value,
; 878  : 			_Tree_base_types<_Ty, _Alloc> >
; 879  : 	{	// base class for tree to hold buynode/freenode functions
; 880  : public:
; 881  : 	typedef _Tree_alloc<!is_empty<_Alloc>::value,
; 882  : 		_Tree_base_types<_Ty, _Alloc> > _Mybase;
; 883  : 	typedef typename _Mybase::_Alty _Alty;
; 884  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 885  : 	typedef typename _Mybase::value_type value_type;
; 886  : 
; 887  : 	_Tree_buy(const _Alloc& _Al = _Alloc())
; 888  : 		: _Mybase(_Al)
; 889  : 		{	// construct from allocator
; 890  : 		}
; 891  : 
; 892  : 	_Nodeptr _Buynode0()
; 893  : 		{	// allocate a non-value node
; 894  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 895  : 
; 896  : 		_TRY_BEGIN
; 897  : 		this->_Getal().construct(
; 898  : 			_STD addressof(this->_Left(_Pnode)), this->_Myhead);
; 899  : 		this->_Getal().construct(
; 900  : 			_STD addressof(this->_Parent(_Pnode)), this->_Myhead);
; 901  : 		this->_Getal().construct(
; 902  : 			_STD addressof(this->_Right(_Pnode)), this->_Myhead);
; 903  : 		_CATCH_ALL
; 904  : 		this->_Getal().deallocate(_Pnode, 1);
; 905  : 		_RERAISE;
; 906  : 		_CATCH_END
; 907  : 
; 908  : 		return (_Pnode);
; 909  : 		}
; 910  : 
; 911  : 	void _Freenode0(_Nodeptr _Pnode)
; 912  : 		{	// free non-value node using current allocator
; 913  : 		this->_Getal().destroy(
; 914  : 			_STD addressof(this->_Left(_Pnode)));
; 915  : 		this->_Getal().destroy(
; 916  : 			_STD addressof(this->_Parent(_Pnode)));
; 917  : 		this->_Getal().destroy(
; 918  : 			_STD addressof(this->_Right(_Pnode)));
; 919  : 		this->_Getal().deallocate(_Pnode, 1);
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)
; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();
; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;
; 928  : 		this->_Isnil(_Pnode) = false;
; 929  : 
; 930  : 		_TRY_BEGIN
; 931  : 		this->_Getal().construct(
; 932  : 			_STD addressof(this->_Myval(_Pnode)),
; 933  : 				_STD forward<_Valty>(_Val)...);
; 934  : 		_CATCH_ALL
; 935  : 		_Freenode0(_Pnode);
; 936  : 		_RERAISE;
; 937  : 		_CATCH_END
; 938  : 
; 939  : 		return (_Pnode);
; 940  : 		}
; 941  : 
; 942  : 	};
; 943  : 
; 944  : 		// TEMPLATE CLASS _Tree_comp
; 945  : template<bool _Pr_has_storage,
; 946  : 	class _Traits>
; 947  : 	class _Tree_comp
; 948  : 		: public _Tree_buy<typename _Traits::value_type,
; 949  : 			typename _Traits::allocator_type>
; 950  : 	{	// base class for _Tree to hold ordering predicate with storage
; 951  : public:
; 952  : 	typedef _Tree_comp<_Pr_has_storage, _Traits> _Myt;
; 953  : 	typedef _Tree_buy<typename _Traits::value_type,
; 954  : 		typename _Traits::allocator_type> _Mybase;
; 955  : 
; 956  : 	typedef typename _Traits::allocator_type allocator_type;
; 957  : 	typedef typename _Traits::key_compare key_compare;
; 958  : 
; 959  : 	_Tree_comp(const key_compare& _Parg, const allocator_type& _Al)
; 960  : 		: _Mybase(_Al), comp(_Parg)
; 961  : 		{	// construct ordering predicate
; 962  : 		}
; 963  : 
; 964  : 	key_compare& _Getcomp()
; 965  : 		{	// get reference to ordering predicate
; 966  : 		return (comp);
; 967  : 		}
; 968  : 
; 969  : 	const key_compare& _Getcomp() const
; 970  : 		{	// get reference to ordering predicate
; 971  : 		return (comp);
; 972  : 		}
; 973  : 
; 974  : 	void _Setcomp(const key_compare& _Right)
; 975  : 		{	// copy ordering predicate
; 976  : 		comp = _Right;
; 977  : 		}
; 978  : 
; 979  : 	void _Swapcomp(key_compare& _Right)
; 980  : 		{	// swap ordering predicate
; 981  : 		_Swap_adl(comp, _Right);
; 982  : 		}
; 983  : 
; 984  : 	key_compare comp;
; 985  : 	};
; 986  : 
; 987  : template<class _Traits>
; 988  : 	class _Tree_comp<false, _Traits>
; 989  : 		: public _Tree_buy<typename _Traits::value_type,
; 990  : 			typename _Traits::allocator_type>
; 991  : 	{	// base class for _Tree to hold ordering predicate with no storage
; 992  : public:
; 993  : 	typedef _Tree_comp<false, _Traits> _Myt;
; 994  : 	typedef _Tree_buy<typename _Traits::value_type,
; 995  : 		typename _Traits::allocator_type> _Mybase;
; 996  : 
; 997  : 	typedef typename _Traits::allocator_type allocator_type;
; 998  : 	typedef typename _Traits::key_compare key_compare;
; 999  : 
; 1000 : 	_Tree_comp(const key_compare&, const allocator_type& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct ordering predicate
; 1003 : 		}
; 1004 : 
; 1005 : 	key_compare _Getcomp() const
; 1006 : 		{	// get ordering predicate
; 1007 : 		return (key_compare());
; 1008 : 		}
; 1009 : 
; 1010 : 	void _Setcomp(const key_compare&)
; 1011 : 		{	// copy ordering predicate
; 1012 : 		}
; 1013 : 
; 1014 : 	void _Swapcomp(const key_compare&)
; 1015 : 		{	// swap ordering predicate
; 1016 : 		}
; 1017 : 	};
; 1018 : 
; 1019 : 		// TEMPLATE CLASS _Tree
; 1020 : template<class _Traits>
; 1021 : 	class _Tree
; 1022 : 		: public _Tree_comp<
; 1023 : 			!is_empty<typename _Traits::key_compare>::value, _Traits>
; 1024 : 	{	// ordered red-black tree for [multi_]{map set}
; 1025 : public:
; 1026 : 	typedef _Tree<_Traits> _Myt;
; 1027 : 	typedef _Tree_comp<
; 1028 : 		!is_empty<typename _Traits::key_compare>::value, _Traits> _Mybase;
; 1029 : 
; 1030 : 	typedef typename _Traits::key_type key_type;
; 1031 : 	typedef typename _Traits::value_compare value_compare;
; 1032 : 	enum
; 1033 : 		{	// get multi parameter
; 1034 : 		_Multi = _Traits::_Multi};
; 1035 : 
; 1036 : 	typedef typename _Mybase::_Node _Node;
; 1037 : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 1038 : 	typedef typename _Mybase::_Alty _Alty;
; 1039 : 
; 1040 : 	typedef typename _Mybase::key_compare key_compare;
; 1041 : 	typedef typename _Mybase::allocator_type allocator_type;
; 1042 : 
; 1043 : 	typedef typename _Mybase::value_type value_type;
; 1044 : 	typedef typename _Mybase::size_type size_type;
; 1045 : 	typedef typename _Mybase::difference_type difference_type;
; 1046 : 	typedef typename _Mybase::pointer pointer;
; 1047 : 	typedef typename _Mybase::const_pointer const_pointer;
; 1048 : 	typedef typename _Mybase::reference reference;
; 1049 : 	typedef typename _Mybase::const_reference const_reference;
; 1050 : 
; 1051 : 	typedef typename _Mybase::const_iterator const_iterator;
; 1052 : 	typedef typename _If<is_same<key_type, value_type>::value,
; 1053 : 		typename _Mybase::const_iterator,
; 1054 : 		typename _Mybase::iterator>::type iterator;
; 1055 : 
; 1056 : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 1057 : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 1058 : 
; 1059 : 	typedef pair<iterator, bool> _Pairib;
; 1060 : 	typedef pair<iterator, iterator> _Pairii;
; 1061 : 	typedef pair<const_iterator, const_iterator> _Paircc;
; 1062 : 
; 1063 : 	_Tree(const key_compare& _Parg,
; 1064 : 		const allocator_type& _Al)
; 1065 : 		: _Mybase(_Parg, _Al)
; 1066 : 		{	// construct empty tree
; 1067 : 		}
; 1068 : 
; 1069 : 	_Tree(const value_type *_First, const value_type *_Last,
; 1070 : 		const key_compare& _Parg, const allocator_type& _Al)
; 1071 : 		: _Mybase(_Parg, _Al)
; 1072 : 		{	// construct tree from [_First, _Last) array
; 1073 : 		_TRY_BEGIN
; 1074 : 		insert(_First, _Last);
; 1075 : 		_CATCH_ALL
; 1076 : 		_Tidy();
; 1077 : 		_RERAISE;
; 1078 : 		_CATCH_END
; 1079 : 		}
; 1080 : 
; 1081 : 	_Tree(const _Myt& _Right, const allocator_type& _Al)
; 1082 : 		: _Mybase(_Right.key_comp(), _Al)
; 1083 : 		{	// construct tree by copying _Right, allocator
; 1084 : 		_TRY_BEGIN
; 1085 : 		_Copy(_Right, false_type());
; 1086 : 		_CATCH_ALL
; 1087 : 		_Tidy();
; 1088 : 		_RERAISE;
; 1089 : 		_CATCH_END
; 1090 : 		}
; 1091 : 
; 1092 : 	_Tree(_Myt&& _Right)
; 1093 : 		: _Mybase(_Right.key_comp(), _Right._Getal())
; 1094 : 		{	// construct tree by moving _Right
; 1095 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1096 : 		}
; 1097 : 
; 1098 : 	_Tree(_Myt&& _Right, const allocator_type& _Al)
; 1099 : 		: _Mybase(_Right.key_comp(), _Al)
; 1100 : 		{	// construct tree by moving _Right, allocator
; 1101 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1102 : 		}
; 1103 : 
; 1104 : 	_Myt& operator=(_Myt&& _Right)
; 1105 : 		{	// assign by moving _Right
; 1106 : 		if (this != &_Right)
; 1107 : 			{	// different, move it
; 1108 : 			clear();
; 1109 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1110 : 				&& this->_Getal() != _Right._Getal())
; 1111 : 				this->_Change_alloc(_Right._Getal());
; 1112 : 
; 1113 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1114 : 			}
; 1115 : 		return (*this);
; 1116 : 		}
; 1117 : 
; 1118 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1119 : 		{	// move from _Right, stealing its contents
; 1120 : 		this->_Swap_all(_Right);
; 1121 : 		this->_Swapcomp(_Right._Getcomp());
; 1122 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1123 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1124 : 		}
; 1125 : 
; 1126 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1127 : 		{	// move from _Right, possibly moving its contents
; 1128 : 		if (get_allocator() == _Right.get_allocator())
; 1129 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1130 : 		else
; 1131 : 			_Copy(_Right, true_type());
; 1132 : 		}
; 1133 : 
; 1134 : 	void _Assign_rv(_Myt&& _Right)
; 1135 : 		{	// assign by moving _Right
; 1136 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1137 : 			typename _Alty::propagate_on_container_move_assignment());
; 1138 : 		}
; 1139 : 
; 1140 : 
; 1141 : 	_Pairib insert(value_type&& _Val)
; 1142 : 		{	// try to insert node with value _Val, favoring right side
; 1143 : 		return (_Insert_nohint(false,
; 1144 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1145 : 		}
; 1146 : 
; 1147 : 	iterator insert(const_iterator _Where, value_type&& _Val)
; 1148 : 		{	// try to insert node with value _Val using _Where as a hint
; 1149 : 		return (_Insert_hint(_Where,
; 1150 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1151 : 		}
; 1152 : 
; 1153 : 	template<class _Valty>
; 1154 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1155 : 			_Pairib>::type
; 1156 : 		insert(_Valty&& _Val)
; 1157 : 		{	// try to insert node with value _Val, favoring right side
; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));
; 1161 : 		}
; 1162 : 
; 1163 : 	template<class _Valty>
; 1164 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1165 : 			iterator>::type
; 1166 : 		insert(const_iterator _Where, _Valty&& _Val)
; 1167 : 		{	// try to insert node with value _Val using _Where as a hint
; 1168 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1169 : 		return (_Insert_hint(_Where,
; 1170 : 			this->_Myval(_Newnode), _Newnode));
; 1171 : 		}
; 1172 : 
; 1173 : 	template<class... _Valty>
; 1174 : 		_Pairib emplace(_Valty&&... _Val)
; 1175 : 		{	// try to insert value_type(_Val...), favoring right side
; 1176 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1177 : 		return (_Insert_nohint(false,
; 1178 : 			this->_Myval(_Newnode), _Newnode));
; 1179 : 		}
; 1180 : 
; 1181 : 	template<class... _Valty>
; 1182 : 		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
; 1183 : 		{	// insert value_type(_Val...) at _Where
; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));
; 1187 : 		}
; 1188 : 
; 1189 : 
; 1190 : 	~_Tree() _NOEXCEPT
; 1191 : 		{	// destroy tree
; 1192 : 		_Tidy();
; 1193 : 		}
; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

	mov	r9, r8
	mov	r8, QWORD PTR [r8]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, rbx
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	mov	rcx, rbx
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 501  :     break;

	jmp	SHORT $LN168@decodeStri
$LN158@decodeStri:

; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)

	bt	esi, 8
	jae	SHORT $LN168@decodeStri

; 170  :   free(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
	npad	1
$LN168@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR decoded_string$[rsp+24], 16
	jb	SHORT $LN277@decodeStri
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR decoded_string$[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN277@decodeStri:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1642 :   return true;

	movzx	eax, dil

; 1643 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+240]
	add	rsp, 176				; 000000b0H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z ENDP ; Json::OurReader::decodeString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 80
decoded$ = 88
decoded_string$ = 136
__$ArrayPad$ = 168
this$ = 224
token$ = 232
?dtor$0@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA PROC ; `Json::OurReader::decodeString'::`1'::dtor$0
	lea	rcx, QWORD PTR decoded_string$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@@Z@4HA ENDP ; `Json::OurReader::decodeString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
unicode$1 = 48
current$ = 56
$T2 = 64
$T3 = 72
$T4 = 72
$T5 = 104
__$ArrayPad$ = 136
this$ = 208
token$ = 216
decoded$ = 224
?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::OurReader::decodeString, COMDAT

; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {

$LN257:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 144				; 00000090H
	mov	QWORD PTR $T2[rbp-105], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax
	mov	rdi, r8
	mov	r14, rdx
	mov	r15, rcx

; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));

	mov	rdx, QWORD PTR [rdx+16]
	sub	rdx, QWORD PTR [r14+8]
	sub	rdx, 2
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)

	mov	rbx, QWORD PTR [r8+16]
	cmp	rbx, rdx
	ja	SHORT $LN38@decodeStri
	cmp	QWORD PTR [r8+24], rdx
	je	SHORT $LN38@decodeStri

; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))

	mov	r8b, 1
	mov	rcx, rdi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN38@decodeStri

; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], rbx

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN34@decodeStri
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rdi]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN35@decodeStri
$LN34@decodeStri:
	mov	rax, rdi
$LN35@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax+rbx], 0
$LN38@decodeStri:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1647 :   Location current = token.start_ + 1; // skip '"'

	mov	rbx, QWORD PTR [r14+8]
	inc	rbx

; 1648 :   Location end = token.end_ - 1;       // do not include '"'

	mov	rsi, QWORD PTR [r14+16]
	dec	rsi

; 1649 :   while (current != end) {

	cmp	rbx, rsi
	je	$LN252@decodeStri
	lea	r12, OFFSET FLAT:__ImageBase
$LL20@decodeStri:

; 1650 :     Char c = *current++;

	movzx	r8d, BYTE PTR [rbx]
	inc	rbx

; 1651 :     if (c == '"')

	cmp	r8b, 34					; 00000022H
	je	$LN252@decodeStri

; 1652 :       break;
; 1653 :     else if (c == '\\') {

	cmp	r8b, 92					; 0000005cH
	jne	$LN16@decodeStri

; 1654 :       if (current == end)

	cmp	rbx, rsi
	je	$LN248@decodeStri

; 1656 :       Char escape = *current++;

	movsx	eax, BYTE PTR [rbx]
	inc	rbx
	mov	QWORD PTR current$[rbp-105], rbx

; 1657 :       switch (escape) {

	add	eax, -34				; ffffffffffffffdeH
	cmp	eax, 83					; 00000053H
	ja	$LN2@decodeStri
	cdqe
	movzx	eax, BYTE PTR $LN253@decodeStri[r12+rax]
	mov	ecx, DWORD PTR $LN254@decodeStri[r12+rax*4]
	add	rcx, r12
	jmp	rcx
$LN12@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 34					; 00000022H
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1660 :         break;

	jmp	$LN16@decodeStri
$LN11@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 47					; 0000002fH
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1663 :         break;

	jmp	SHORT $LN16@decodeStri
$LN10@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 92					; 0000005cH
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1666 :         break;

	jmp	SHORT $LN16@decodeStri
$LN9@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 8
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1669 :         break;

	jmp	SHORT $LN16@decodeStri
$LN8@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 12
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1672 :         break;

	jmp	SHORT $LN16@decodeStri
$LN7@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 10
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1675 :         break;

	jmp	SHORT $LN16@decodeStri
$LN6@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 13
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1678 :         break;

	jmp	SHORT $LN16@decodeStri
$LN5@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 9
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1681 :         break;

	jmp	SHORT $LN16@decodeStri
$LN4@decodeStri:

; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))

	lea	rax, QWORD PTR unicode$1[rbp-105]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, rsi
	lea	r8, QWORD PTR current$[rbp-105]
	mov	rdx, r14
	mov	rcx, r15
	call	?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ; Json::OurReader::decodeUnicodeCodePoint
	test	al, al
	je	SHORT $LN249@decodeStri

; 1686 :         decoded += codePointToUTF8(unicode);

	mov	edx, DWORD PTR unicode$1[rbp-105]
	lea	rcx, QWORD PTR $T5[rbp-105]
	call	?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::codePointToUTF8
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T5[rbp-81], 16
	jb	SHORT $LN255@decodeStri
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T5[rbp-105]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN255@decodeStri:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1691 :     } else {

	mov	rbx, QWORD PTR current$[rbp-105]
	jmp	SHORT $LN244@decodeStri
$LN16@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	edx, 1
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN244@decodeStri:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1649 :   while (current != end) {

	cmp	rbx, rsi
	je	$LN252@decodeStri
	jmp	$LL20@decodeStri
$LN249@decodeStri:

; 1685 :           return false;

	xor	al, al
	jmp	$LN21@decodeStri
$LN2@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rbp-81], 15

; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rbp-89], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rbp-105], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 29
	lea	rdx, OFFSET FLAT:??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
	lea	rcx, QWORD PTR $T3[rbp-105]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1689 :         return addError("Bad escape sequence in string", token, current);

	mov	r9, rbx
	mov	r8, r14
	lea	rdx, QWORD PTR $T3[rbp-105]
	mov	rcx, r15
	call	?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::OurReader::addError
	movzx	ebx, al
	jmp	SHORT $LN256@decodeStri
$LN248@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-81], 15

; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-89], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rbp-105], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 31
	lea	rdx, OFFSET FLAT:??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
	lea	rcx, QWORD PTR $T4[rbp-105]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1655 :         return addError("Empty escape sequence in string", token, current);

	mov	r9, rbx
	mov	r8, r14
	lea	rdx, QWORD PTR $T4[rbp-105]
	mov	rcx, r15
	call	?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::OurReader::addError
	movzx	ebx, al
$LN256@decodeStri:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-81], 16
	jb	SHORT $LN104@decodeStri
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rbp-105]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN104@decodeStri:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1655 :         return addError("Empty escape sequence in string", token, current);

	movzx	eax, bl
	jmp	SHORT $LN21@decodeStri
$LN252@decodeStri:

; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;

	mov	al, 1
$LN21@decodeStri:

; 1696 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
	npad	2
$LN254@decodeStri:
	DD	$LN12@decodeStri
	DD	$LN11@decodeStri
	DD	$LN10@decodeStri
	DD	$LN9@decodeStri
	DD	$LN8@decodeStri
	DD	$LN7@decodeStri
	DD	$LN6@decodeStri
	DD	$LN5@decodeStri
	DD	$LN4@decodeStri
	DD	$LN2@decodeStri
$LN253@decodeStri:
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	7
	DB	8
?decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::OurReader::decodeString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
unicode$1 = 48
current$ = 56
$T2 = 64
$T3 = 72
$T4 = 72
$T5 = 104
__$ArrayPad$ = 136
this$ = 208
token$ = 216
decoded$ = 224
?dtor$0@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::OurReader::decodeString'::`1'::dtor$0
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::OurReader::decodeString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
unicode$1 = 48
current$ = 56
$T2 = 64
$T3 = 72
$T4 = 72
$T5 = 104
__$ArrayPad$ = 136
this$ = 208
token$ = 216
decoded$ = 224
?dtor$1@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::OurReader::decodeString'::`1'::dtor$1
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::OurReader::decodeString'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
unicode$1 = 48
current$ = 56
$T2 = 64
$T3 = 72
$T4 = 72
$T5 = 104
__$ArrayPad$ = 136
this$ = 208
token$ = 216
decoded$ = 224
?dtor$2@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::OurReader::decodeString'::`1'::dtor$2
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??decodeString@OurReader@Json@@AEAA_NAEAVToken@12@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::OurReader::decodeString'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
_TEXT	SEGMENT
surrogatePair$1 = 48
$T2 = 56
$T3 = 64
$T4 = 64
__$ArrayPad$ = 96
this$ = 160
token$ = 168
current$ = 176
end$ = 184
unicode$ = 192
?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z PROC ; Json::OurReader::decodeUnicodeCodePoint, COMDAT

; 1701 :                                     unsigned int& unicode) {

$LN166:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 112				; 00000070H
	mov	QWORD PTR $T2[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, r9
	mov	rbx, r8
	mov	rbp, rdx
	mov	rsi, rcx
	mov	rdi, QWORD PTR unicode$[rsp]

; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))

	mov	QWORD PTR [rsp+32], rdi
	call	?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ; Json::OurReader::decodeUnicodeEscapeSequence
	test	al, al
	jne	SHORT $LN7@decodeUnic
$LN3@decodeUnic:

; 1704 :     return false;

	xor	al, al
	jmp	$LN8@decodeUnic
$LN7@decodeUnic:
	mov	eax, DWORD PTR [rdi]
	sub	eax, 55296				; 0000d800H
	cmp	eax, 1023				; 000003ffH
	ja	$LN1@decodeUnic

; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)

	mov	rcx, QWORD PTR [rbx]
	mov	rax, r14
	sub	rax, rcx
	cmp	rax, 6
	jge	SHORT $LN5@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rsp+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rsp+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 67					; 00000043H
	lea	rdx, OFFSET FLAT:??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
	lea	rcx, QWORD PTR $T4[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1711 :           current);

	mov	r9, QWORD PTR [rbx]
	mov	r8, rbp
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rsi
	call	?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::OurReader::addError
	movzx	ebx, al
$LN165@decodeUnic:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rsp+24], 16
	jb	SHORT $LN76@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN76@decodeUnic:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1711 :           current);

	movzx	eax, bl
	jmp	$LN8@decodeUnic
$LN5@decodeUnic:

; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {

	movzx	eax, BYTE PTR [rcx]
	lea	rdx, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rdx
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN4@decodeUnic
	movzx	ecx, BYTE PTR [rdx]
	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rbx], rax
	cmp	cl, 117					; 00000075H
	jne	SHORT $LN4@decodeUnic

; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {

	lea	rax, QWORD PTR surrogatePair$1[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, r14
	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, rsi
	call	?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ; Json::OurReader::decodeUnicodeEscapeSequence
	test	al, al
	je	$LN3@decodeUnic

; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);

	mov	ecx, DWORD PTR [rdi]
	and	ecx, 1023				; 000003ffH
	add	ecx, 64					; 00000040H
	shl	ecx, 10
	mov	eax, DWORD PTR surrogatePair$1[rsp]
	and	eax, 1023				; 000003ffH
	add	ecx, eax
	mov	DWORD PTR [rdi], ecx

; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else

	jmp	SHORT $LN1@decodeUnic
$LN4@decodeUnic:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 79					; 0000004fH
	lea	rdx, OFFSET FLAT:??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1722 :                       current);

	mov	r9, QWORD PTR [rbx]
	mov	r8, rbp
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rsi
	call	?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::OurReader::addError
	movzx	ebx, al
	jmp	$LN165@decodeUnic
$LN1@decodeUnic:

; 1723 :   }
; 1724 :   return true;

	mov	al, 1
$LN8@decodeUnic:

; 1725 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ENDP ; Json::OurReader::decodeUnicodeCodePoint
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
surrogatePair$1 = 48
$T2 = 56
$T3 = 64
$T4 = 64
__$ArrayPad$ = 96
this$ = 160
token$ = 168
current$ = 176
end$ = 184
unicode$ = 192
?dtor$0@?0??decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::OurReader::decodeUnicodeCodePoint'::`1'::dtor$0
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::OurReader::decodeUnicodeCodePoint'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
surrogatePair$1 = 48
$T2 = 56
$T3 = 64
$T4 = 64
__$ArrayPad$ = 96
this$ = 160
token$ = 168
current$ = 176
end$ = 184
unicode$ = 192
?dtor$1@?0??decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::OurReader::decodeUnicodeCodePoint'::`1'::dtor$1
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??decodeUnicodeCodePoint@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::OurReader::decodeUnicodeCodePoint'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z
_TEXT	SEGMENT
$T1 = 32
info$2 = 48
info$3 = 48
$T4 = 112
$T5 = 112
__$ArrayPad$ = 144
this$ = 192
token$ = 200
current$ = 208
end$ = 216
ret_unicode$ = 224
?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z PROC ; Json::OurReader::decodeUnicodeEscapeSequence, COMDAT

; 1730 :                                          unsigned int& ret_unicode) {

$LN437:
	push	rbp
	push	rsi
	push	r14
	lea	rbp, QWORD PTR [rsp-63]
	sub	rsp, 160				; 000000a0H
	mov	QWORD PTR $T1[rbp-97], -2
	mov	QWORD PTR [rsp+216], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-97], rax
	mov	rbx, r8
	mov	rsi, rdx
	mov	r14, rcx
	mov	r10, QWORD PTR ret_unicode$[rbp-97]

; 1731 :   if (end - current < 4)

	sub	r9, QWORD PTR [r8]
	cmp	r9, 4
	jge	$LN10@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-73], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-81], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-97], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 60					; 0000003cH
	lea	rdx, OFFSET FLAT:??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	rcx, QWORD PTR $T5[rbp-97]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1735 :         current);

	mov	rbx, QWORD PTR [rbx]
	mov	QWORD PTR info$3[rbp-49], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$3[rbp-57], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$3[rbp-73], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1759 :   info.token_ = token;

	movups	xmm0, XMMWORD PTR [rsi]
	movaps	XMMWORD PTR info$3[rbp-97], xmm0
	movsdx	xmm1, QWORD PTR [rsi+16]
	movsdx	QWORD PTR info$3[rbp-81], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T5[rbp-97]
	lea	rcx, QWORD PTR info$3[rbp-73]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1761 :   info.extra_ = extra;

	mov	QWORD PTR info$3[rbp-41], rbx

; 1762 :   errors_.push_back(info);

	lea	rcx, QWORD PTR [r14+40]
	lea	rdx, QWORD PTR info$3[rbp-97]
	call	?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$3[rbp-49], 16
	jb	SHORT $LN178@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$3[rbp-73]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN178@decodeUnic:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1735 :         current);

	jmp	$LN435@decodeUnic
$LN10@decodeUnic:

; 1736 :   int unicode = 0;

	xor	eax, eax

; 1737 :   for (int index = 0; index < 4; ++index) {

	xor	r8d, r8d
	npad	2
$LL9@decodeUnic:

; 1738 :     Char c = *current++;

	mov	rcx, QWORD PTR [rbx]
	movzx	edx, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR [rbx], rcx

; 1739 :     unicode *= 16;

	shl	eax, 4

; 1740 :     if (c >= '0' && c <= '9')

	lea	ecx, DWORD PTR [rdx-48]
	cmp	cl, 9
	ja	SHORT $LN6@decodeUnic

; 1741 :       unicode += c - '0';

	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN436@decodeUnic
$LN6@decodeUnic:

; 1742 :     else if (c >= 'a' && c <= 'f')

	lea	ecx, DWORD PTR [rdx-97]
	cmp	cl, 5
	ja	SHORT $LN4@decodeUnic

; 1743 :       unicode += c - 'a' + 10;

	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN436@decodeUnic
$LN4@decodeUnic:

; 1744 :     else if (c >= 'A' && c <= 'F')

	lea	ecx, DWORD PTR [rdx-65]
	cmp	cl, 5
	ja	SHORT $LN2@decodeUnic

; 1745 :       unicode += c - 'A' + 10;

	add	eax, -55				; ffffffffffffffc9H
$LN436@decodeUnic:
	movsx	ecx, dl
	add	eax, ecx

; 1737 :   for (int index = 0; index < 4; ++index) {

	inc	r8d
	cmp	r8d, 4
	jl	SHORT $LL9@decodeUnic

; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);

	mov	DWORD PTR [r10], eax

; 1753 :   return true;

	mov	al, 1
	jmp	$LN11@decodeUnic
$LN2@decodeUnic:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-73], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-81], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rbp-97], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 66					; 00000042H
	lea	rdx, OFFSET FLAT:??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	rcx, QWORD PTR $T4[rbp-97]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1750 :           current);

	mov	rbx, QWORD PTR [rbx]
	mov	QWORD PTR info$2[rbp-49], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$2[rbp-57], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$2[rbp-73], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1759 :   info.token_ = token;

	movups	xmm0, XMMWORD PTR [rsi]
	movaps	XMMWORD PTR info$2[rbp-97], xmm0
	movsdx	xmm1, QWORD PTR [rsi+16]
	movsdx	QWORD PTR info$2[rbp-81], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T4[rbp-97]
	lea	rcx, QWORD PTR info$2[rbp-73]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1761 :   info.extra_ = extra;

	mov	QWORD PTR info$2[rbp-41], rbx

; 1762 :   errors_.push_back(info);

	lea	rcx, QWORD PTR [r14+40]
	lea	rdx, QWORD PTR info$2[rbp-97]
	call	?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$2[rbp-49], 16
	jb	SHORT $LN385@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$2[rbp-73]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN385@decodeUnic:
$LN435@decodeUnic:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-73], 16
	jb	SHORT $LN417@decodeUnic
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rbp-97]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN417@decodeUnic:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1750 :           current);

	xor	al, al
$LN11@decodeUnic:

; 1754 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-97]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+216]
	add	rsp, 160				; 000000a0H
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
?decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z ENDP ; Json::OurReader::decodeUnicodeEscapeSequence
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
info$2 = 48
info$3 = 48
$T4 = 112
$T5 = 112
__$ArrayPad$ = 144
this$ = 192
token$ = 200
current$ = 208
end$ = 216
ret_unicode$ = 224
?dtor$0@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::OurReader::decodeUnicodeEscapeSequence'::`1'::dtor$0
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::OurReader::decodeUnicodeEscapeSequence'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
info$2 = 48
info$3 = 48
$T4 = 112
$T5 = 112
__$ArrayPad$ = 144
this$ = 192
token$ = 200
current$ = 208
end$ = 216
ret_unicode$ = 224
?dtor$2@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::OurReader::decodeUnicodeEscapeSequence'::`1'::dtor$2
	lea	rcx, QWORD PTR info$3[rdx]
	jmp	??1ErrorInfo@OurReader@Json@@QEAA@XZ
?dtor$2@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::OurReader::decodeUnicodeEscapeSequence'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
info$2 = 48
info$3 = 48
$T4 = 112
$T5 = 112
__$ArrayPad$ = 144
this$ = 192
token$ = 200
current$ = 208
end$ = 216
ret_unicode$ = 224
?dtor$1@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::OurReader::decodeUnicodeEscapeSequence'::`1'::dtor$1
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::OurReader::decodeUnicodeEscapeSequence'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
info$2 = 48
info$3 = 48
$T4 = 112
$T5 = 112
__$ArrayPad$ = 144
this$ = 192
token$ = 200
current$ = 208
end$ = 216
ret_unicode$ = 224
?dtor$3@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA PROC ; `Json::OurReader::decodeUnicodeEscapeSequence'::`1'::dtor$3
	lea	rcx, QWORD PTR info$2[rdx]
	jmp	??1ErrorInfo@OurReader@Json@@QEAA@XZ
?dtor$3@?0??decodeUnicodeEscapeSequence@OurReader@Json@@AEAA_NAEAVToken@12@AEAPEBDPEBDAEAI@Z@4HA ENDP ; `Json::OurReader::decodeUnicodeEscapeSequence'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z
_TEXT	SEGMENT
$T1 = 32
info$ = 48
__$ArrayPad$ = 112
this$ = 160
message$ = 168
token$ = 176
extra$ = 184
?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z PROC ; Json::OurReader::addError, COMDAT

; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {

$LN133:
	push	rbx
	push	rdi
	sub	rsp, 136				; 00000088H
	mov	QWORD PTR $T1[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r9
	mov	rbx, rcx
	mov	QWORD PTR info$[rsp+48], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR info$[rsp+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR info$[rsp+24], 0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1759 :   info.token_ = token;

	movups	xmm0, XMMWORD PTR [r8]
	movaps	XMMWORD PTR info$[rsp], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR info$[rsp+16], xmm1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 998  : 		if (this != &_Right)

	lea	rax, QWORD PTR info$[rsp+24]
	cmp	rax, rdx
	je	SHORT $LN96@addError

; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rcx, QWORD PTR info$[rsp+24]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN96@addError:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1761 :   info.extra_ = extra;

	mov	QWORD PTR info$[rsp+56], rdi

; 1762 :   errors_.push_back(info);

	lea	rcx, QWORD PTR [rbx+40]
	lea	rdx, QWORD PTR info$[rsp]
	call	?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR info$[rsp+48], 16
	jb	SHORT $LN132@addError
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR info$[rsp+24]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN132@addError:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1763 :   return false;

	xor	al, al

; 1764 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	pop	rdi
	pop	rbx
	ret	0
?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ENDP ; Json::OurReader::addError
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
info$ = 48
__$ArrayPad$ = 112
this$ = 160
message$ = 168
token$ = 176
extra$ = 184
?dtor$0@?0??addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z@4HA PROC ; `Json::OurReader::addError'::`1'::dtor$0
	lea	rcx, QWORD PTR info$[rdx]
	jmp	??1ErrorInfo@OurReader@Json@@QEAA@XZ
?dtor$0@?0??addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z@4HA ENDP ; `Json::OurReader::addError'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??0ErrorInfo@OurReader@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ErrorInfo@OurReader@Json@@QEAA@XZ PROC		; Json::OurReader::ErrorInfo::ErrorInfo, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+40], 0
	mov	rax, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx+24], 0
	ret	0
??0ErrorInfo@OurReader@Json@@QEAA@XZ ENDP		; Json::OurReader::ErrorInfo::ErrorInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??1ErrorInfo@OurReader@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ErrorInfo@OurReader@Json@@QEAA@XZ PROC		; Json::OurReader::ErrorInfo::~ErrorInfo, COMDAT
$LN36:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rcx+48], 16
	mov	rbx, rcx
	jb	SHORT $LN23@ErrorInfo
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN23@ErrorInfo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+24], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1ErrorInfo@OurReader@Json@@QEAA@XZ ENDP		; Json::OurReader::ErrorInfo::~ErrorInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z
_TEXT	SEGMENT
skip$ = 32
this$ = 80
skipUntilToken$ = 88
?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z PROC ; Json::OurReader::recoverFromError, COMDAT

; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1352 : 		return (this->_Mysize);

	mov	rdi, QWORD PTR [rcx+72]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {

	mov	esi, edx
	mov	rbx, rcx
	npad	8
$LL5@recoverFro:

; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))

	lea	rdx, QWORD PTR skip$[rsp]
	mov	rcx, rbx
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	test	al, al
	jne	SHORT $LN3@recoverFro

; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery

	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize
$LN3@recoverFro:

; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)

	mov	eax, DWORD PTR skip$[rsp]
	cmp	eax, esi
	je	SHORT $LN11@recoverFro
	test	eax, eax
	jne	SHORT $LL5@recoverFro
$LN11@recoverFro:

; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);

	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize

; 1776 :   return false;
; 1777 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	xor	al, al
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?recoverFromError@OurReader@Json@@AEAA_NW4TokenType@12@@Z ENDP ; Json::OurReader::recoverFromError
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?addErrorAndRecover@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z
_TEXT	SEGMENT
skip$1 = 32
this$ = 80
message$ = 88
token$ = 96
skipUntilToken$ = 104
?addErrorAndRecover@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z PROC ; Json::OurReader::addErrorAndRecover, COMDAT

; 1781 :                                 TokenType skipUntilToken) {

$LN17:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	esi, r9d

; 1782 :   addError(message, token);

	xor	r9d, r9d
	mov	rbx, rcx
	call	?addError@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@PEBD@Z ; Json::OurReader::addError
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1352 : 		return (this->_Mysize);

	mov	rdi, QWORD PTR [rbx+72]
$LL7@addErrorAn:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1770 :     if (!readToken(skip))

	lea	rdx, QWORD PTR skip$1[rsp]
	mov	rcx, rbx
	call	?readToken@OurReader@Json@@AEAA_NAEAVToken@12@@Z ; Json::OurReader::readToken
	test	al, al
	jne	SHORT $LN5@addErrorAn

; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery

	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize
$LN5@addErrorAn:

; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)

	mov	eax, DWORD PTR skip$1[rsp]
	cmp	eax, esi
	je	SHORT $LN13@addErrorAn
	test	eax, eax
	jne	SHORT $LL7@addErrorAn
$LN13@addErrorAn:

; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);

	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize

; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	xor	al, al
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?addErrorAndRecover@OurReader@Json@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVToken@12@W4TokenType@12@@Z ENDP ; Json::OurReader::addErrorAndRecover
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 56
this$ = 96
?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ PROC	; Json::OurReader::currentValue, COMDAT

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

$LN18:
	sub	rsp, 88					; 00000058H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T1[rsp]
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
	mov	r8, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	je	SHORT $LN14@currentVal
	mov	rax, QWORD PTR [rax]
$LN14@currentVal:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rcx, QWORD PTR [rax+16]
	mov	r8, QWORD PTR [r8+16]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	rax, QWORD PTR [rax+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, r8
	dec	rcx
	shr	rdx, 1
	and	rdx, rcx

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	r8d, 1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }

	mov	rax, QWORD PTR [rax+rdx*8]
	mov	rax, QWORD PTR [rax+r8*8]
	add	rsp, 88					; 00000058H
	ret	0
?currentValue@OurReader@Json@@AEAAAEAVValue@2@XZ ENDP	; Json::OurReader::currentValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?getNextChar@OurReader@Json@@AEAADXZ
_TEXT	SEGMENT
this$ = 8
?getNextChar@OurReader@Json@@AEAADXZ PROC		; Json::OurReader::getNextChar, COMDAT

; 1788 : OurReader::Char OurReader::getNextChar() {

	mov	rdx, rcx

; 1789 :   if (current_ == end_)

	mov	rcx, QWORD PTR [rcx+128]
	cmp	rcx, QWORD PTR [rdx+120]
	jne	SHORT $LN1@getNextCha

; 1790 :     return 0;

	xor	al, al

; 1792 : }

	ret	0
$LN1@getNextCha:

; 1791 :   return *current_++;

	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR [rdx+128], rcx

; 1792 : }

	ret	0
?getNextChar@OurReader@Json@@AEAADXZ ENDP		; Json::OurReader::getNextChar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@OurReader@Json@@AEBAXPEBDAEAH1@Z
_TEXT	SEGMENT
this$ = 8
location$ = 16
line$ = 24
column$ = 32
?getLocationLineAndColumn@OurReader@Json@@AEBAXPEBDAEAH1@Z PROC ; Json::OurReader::getLocationLineAndColumn, COMDAT

; 1797 :   Location current = begin_;

	mov	rax, QWORD PTR [rcx+112]

; 1798 :   Location lastLineStart = current;
; 1799 :   line = 0;

	mov	DWORD PTR [r8], 0
	mov	r10, rax

; 1800 :   while (current < location && current != end_) {

	cmp	rax, rdx
	jae	SHORT $LN5@getLocatio
	mov	r11, QWORD PTR [rcx+120]
$LL6@getLocatio:
	cmp	rax, r11
	je	SHORT $LN5@getLocatio

; 1801 :     Char c = *current++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax

; 1802 :     if (c == '\r') {

	cmp	cl, 13
	jne	SHORT $LN4@getLocatio

; 1803 :       if (*current == '\n')

	cmp	BYTE PTR [rax], 10
	jne	SHORT $LN3@getLocatio

; 1804 :         ++current;

	inc	rax

; 1805 :       lastLineStart = current;
; 1806 :       ++line;

	jmp	SHORT $LN3@getLocatio
$LN4@getLocatio:

; 1807 :     } else if (c == '\n') {

	cmp	cl, 10
	jne	SHORT $LN1@getLocatio
$LN3@getLocatio:

; 1808 :       lastLineStart = current;
; 1809 :       ++line;

	inc	DWORD PTR [r8]
	mov	r10, rax
$LN1@getLocatio:

; 1800 :   while (current < location && current != end_) {

	cmp	rax, rdx
	jb	SHORT $LL6@getLocatio
$LN5@getLocatio:

; 1810 :     }
; 1811 :   }
; 1812 :   // column & line start at 1
; 1813 :   column = int(location - lastLineStart) + 1;
; 1814 :   ++line;

	inc	DWORD PTR [r8]
	sub	edx, r10d
	inc	edx
	mov	DWORD PTR [r9], edx

; 1815 : }

	ret	0
?getLocationLineAndColumn@OurReader@Json@@AEBAXPEBDAEAH1@Z ENDP ; Json::OurReader::getLocationLineAndColumn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@OurReader@Json@@AEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z
_TEXT	SEGMENT
$T1 = 48
buffer$ = 56
__$ArrayPad$ = 112
this$ = 144
__$ReturnUdt$ = 152
location$ = 160
?getLocationLineAndColumn@OurReader@Json@@AEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z PROC ; Json::OurReader::getLocationLineAndColumn, COMDAT

; 1817 : JSONCPP_STRING OurReader::getLocationLineAndColumn(Location location) const {

$LN63:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1797 :   Location current = begin_;

	mov	rax, QWORD PTR [rcx+112]
	xor	ebx, ebx

; 1817 : JSONCPP_STRING OurReader::getLocationLineAndColumn(Location location) const {

	mov	rdi, rdx
	mov	DWORD PTR $T1[rsp], ebx

; 1798 :   Location lastLineStart = current;

	mov	rdx, rax

; 1799 :   line = 0;

	mov	r9d, ebx

; 1800 :   while (current < location && current != end_) {

	cmp	rax, r8
	jae	SHORT $LN61@getLocatio
	mov	r10, QWORD PTR [rcx+120]
$LL10@getLocatio:
	cmp	rax, r10
	je	SHORT $LN61@getLocatio

; 1801 :     Char c = *current++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax

; 1802 :     if (c == '\r') {

	cmp	cl, 13
	jne	SHORT $LN8@getLocatio

; 1803 :       if (*current == '\n')

	cmp	BYTE PTR [rax], 10
	jne	SHORT $LN7@getLocatio

; 1804 :         ++current;

	inc	rax

; 1805 :       lastLineStart = current;
; 1806 :       ++line;

	jmp	SHORT $LN7@getLocatio
$LN8@getLocatio:

; 1807 :     } else if (c == '\n') {

	cmp	cl, 10
	jne	SHORT $LN5@getLocatio
$LN7@getLocatio:

; 1808 :       lastLineStart = current;
; 1809 :       ++line;

	inc	r9d
	mov	rdx, rax
$LN5@getLocatio:

; 1800 :   while (current < location && current != end_) {

	cmp	rax, r8
	jb	SHORT $LL10@getLocatio
$LN61@getLocatio:

; 1818 :   int line, column;
; 1819 :   getLocationLineAndColumn(location, line, column);
; 1820 :   char buffer[18 + 16 + 16 + 1];
; 1821 :   snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);

	sub	r8d, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	edx, 51					; 00000033H

; 1810 :     }
; 1811 :   }
; 1812 :   // column & line start at 1
; 1813 :   column = int(location - lastLineStart) + 1;

	inc	r8d

; 1814 :   ++line;

	inc	r9d

; 1818 :   int line, column;
; 1819 :   getLocationLineAndColumn(location, line, column);
; 1820 :   char buffer[18 + 16 + 16 + 1];
; 1821 :   snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);

	mov	DWORD PTR [rsp+32], r8d
	lea	r8, OFFSET FLAT:??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
	call	QWORD PTR __imp_sprintf_s
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi], bl

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR buffer$[rsp], bl
	je	SHORT $LN56@getLocatio
	lea	rax, QWORD PTR buffer$[rsp]
	or	rbx, -1
$LL60@getLocatio:
	inc	rbx
	cmp	BYTE PTR [rax+rbx], 0
	jne	SHORT $LL60@getLocatio
$LN56@getLocatio:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	r8, rbx
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1822 :   return buffer;

	mov	rax, rdi

; 1823 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+168]
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
?getLocationLineAndColumn@OurReader@Json@@AEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z ENDP ; Json::OurReader::getLocationLineAndColumn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 88
$T8 = 88
itError$9 = 88
$T10 = 120
$T11 = 120
$T12 = 120
__$ArrayPad$ = 152
this$ = 224
__$ReturnUdt$ = 232
?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Json::OurReader::getFormattedErrorMessages, COMDAT

; 1825 : JSONCPP_STRING OurReader::getFormattedErrorMessages() const {

$LN344:
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 160				; 000000a0H
	mov	QWORD PTR $T2[rbp-121], -2
	mov	QWORD PTR [rsp+240], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-121], rax
	mov	rdi, rdx
	mov	r13, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-121], rdx
	xor	r12d, r12d
	mov	DWORD PTR $T1[rbp-121], r12d
	mov	QWORD PTR [rdx+24], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+16], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdx], r12b
	mov	DWORD PTR $T1[rbp-121], 1
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1827 :   for (Errors::const_iterator itError = errors_.begin();

	lea	rdx, QWORD PTR itError$9[rbp-121]
	add	rcx, 40					; 00000028H
	call	?begin@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::begin

; 1829 :        ++itError) {

	lea	rdx, QWORD PTR $T6[rbp-121]
	lea	rcx, QWORD PTR [r13+40]
	call	?end@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::end
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 465  : 		return (this->_Myoff == _Right._Myoff);

	mov	rbx, QWORD PTR itError$9[rbp-105]
	cmp	rbx, QWORD PTR [rax+16]

; 466  : 		}
; 467  : 
; 468  : 	bool operator!=(const _Myiter& _Right) const
; 469  : 		{	// test for iterator inequality
; 470  : 		return (!(*this == _Right));

	setne	al
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1829 :        ++itError) {

	test	al, al
	je	$LN343@getFormatt
	mov	r14, QWORD PTR itError$9[rbp-121]
	npad	2
$LL55@getFormatt:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	r14, r14
	mov	rax, r12
	je	SHORT $LN68@getFormatt
	mov	rax, QWORD PTR [r14]
$LN68@getFormatt:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rcx, QWORD PTR [rax+16]
	dec	rcx
	and	rcx, rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1830 :     const ErrorInfo& error = *itError;

	mov	rax, QWORD PTR [rax+8]
	mov	rsi, QWORD PTR [rax+rcx*8]

; 1831 :     formattedMessage +=
; 1832 :         "* " + getLocationLineAndColumn(error.token_.start_) + "\n";

	mov	r8, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR $T12[rbp-121]
	mov	rcx, r13
	call	?getLocationLineAndColumn@OurReader@Json@@AEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z ; Json::OurReader::getLocationLineAndColumn
	npad	1
	mov	r8, rax
	lea	rdx, OFFSET FLAT:??_C@_02KAOAMBHJ@?$CK?5?$AA@
	lea	rcx, QWORD PTR $T8[rbp-121]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	mov	rdx, rax
	lea	rcx, QWORD PTR $T5[rbp-121]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@PEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T5[rbp-97], 16
	jb	SHORT $LN95@getFormatt
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T5[rbp-121]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN95@getFormatt:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-97], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-105], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-121], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T8[rbp-97], 16
	jb	SHORT $LN127@getFormatt
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T8[rbp-121]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN127@getFormatt:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-97], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T8[rbp-105], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T8[rbp-121], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T12[rbp-97], 16
	jb	SHORT $LN159@getFormatt
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T12[rbp-121]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN159@getFormatt:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1833 :     formattedMessage += "  " + error.message_ + "\n";

	lea	r8, QWORD PTR [rsi+24]
	lea	rdx, OFFSET FLAT:??_C@_02KNHHEEKP@?5?5?$AA@
	lea	rcx, QWORD PTR $T11[rbp-121]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rbp-121]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@PEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-97], 16
	jb	SHORT $LN195@getFormatt
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rbp-121]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN195@getFormatt:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-97], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-105], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rbp-121], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T11[rbp-97], 16
	jb	SHORT $LN227@getFormatt
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T11[rbp-121]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN227@getFormatt:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1834 :     if (error.extra_)

	mov	r8, QWORD PTR [rsi+56]
	test	r8, r8
	je	$LN3@getFormatt

; 1835 :       formattedMessage +=
; 1836 :           "See " + getLocationLineAndColumn(error.extra_) + " for detail.\n";

	lea	rdx, QWORD PTR $T10[rbp-121]
	mov	rcx, r13
	call	?getLocationLineAndColumn@OurReader@Json@@AEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z ; Json::OurReader::getLocationLineAndColumn
	npad	1
	mov	r8, rax
	lea	rdx, OFFSET FLAT:??_C@_04JBAOJHKB@See?5?$AA@
	lea	rcx, QWORD PTR $T7[rbp-121]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
	mov	rdx, rax
	lea	rcx, QWORD PTR $T3[rbp-121]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@PEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T3[rbp-97], 16
	jb	SHORT $LN263@getFormatt
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T3[rbp-121]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN263@getFormatt:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rbp-97], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rbp-105], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rbp-121], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T7[rbp-97], 16
	jb	SHORT $LN295@getFormatt
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T7[rbp-121]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN295@getFormatt:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-97], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T7[rbp-105], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T7[rbp-121], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T10[rbp-97], 16
	jb	SHORT $LN3@getFormatt
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T10[rbp-121]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN3@getFormatt:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 370  : 		++_Myoff;

	inc	rbx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1829 :        ++itError) {

	lea	rdx, QWORD PTR $T6[rbp-121]
	lea	rcx, QWORD PTR [r13+40]
	call	?end@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::end
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 465  : 		return (this->_Myoff == _Right._Myoff);

	cmp	rbx, QWORD PTR [rax+16]
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1829 :        ++itError) {

	jne	$LL55@getFormatt
$LN343@getFormatt:

; 1837 :   }
; 1838 :   return formattedMessage;

	mov	rax, rdi

; 1839 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-121]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+240]
	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
	int	3
?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::OurReader::getFormattedErrorMessages
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 88
$T8 = 88
itError$9 = 88
$T10 = 120
$T11 = 120
$T12 = 120
__$ArrayPad$ = 152
this$ = 224
__$ReturnUdt$ = 232
?dtor$0@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 88
$T8 = 88
itError$9 = 88
$T10 = 120
$T11 = 120
$T12 = 120
__$ArrayPad$ = 152
this$ = 224
__$ReturnUdt$ = 232
?dtor$1@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$1
	lea	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 88
$T8 = 88
itError$9 = 88
$T10 = 120
$T11 = 120
$T12 = 120
__$ArrayPad$ = 152
this$ = 224
__$ReturnUdt$ = 232
?dtor$2@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$2
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 88
$T8 = 88
itError$9 = 88
$T10 = 120
$T11 = 120
$T12 = 120
__$ArrayPad$ = 152
this$ = 224
__$ReturnUdt$ = 232
?dtor$3@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$3
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 88
$T8 = 88
itError$9 = 88
$T10 = 120
$T11 = 120
$T12 = 120
__$ArrayPad$ = 152
this$ = 224
__$ReturnUdt$ = 232
?dtor$4@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$4
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 88
$T8 = 88
itError$9 = 88
$T10 = 120
$T11 = 120
$T12 = 120
__$ArrayPad$ = 152
this$ = 224
__$ReturnUdt$ = 232
?dtor$5@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$5
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 88
$T8 = 88
itError$9 = 88
$T10 = 120
$T11 = 120
$T12 = 120
__$ArrayPad$ = 152
this$ = 224
__$ReturnUdt$ = 232
?dtor$6@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$6
	lea	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 88
$T8 = 88
itError$9 = 88
$T10 = 120
$T11 = 120
$T12 = 120
__$ArrayPad$ = 152
this$ = 224
__$ReturnUdt$ = 232
?dtor$7@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$7
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 88
$T8 = 88
itError$9 = 88
$T10 = 120
$T11 = 120
$T12 = 120
__$ArrayPad$ = 152
this$ = 224
__$ReturnUdt$ = 232
?dtor$8@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$8
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Json::OurReader::getFormattedErrorMessages'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >, COMDAT
	ret	0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
collectComments$ = 72
features$ = 80
??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z PROC	; Json::OurCharReader::OurCharReader, COMDAT

; 1905 :   {}

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
	lea	rax, OFFSET FLAT:??_7OurCharReader@Json@@6B@
	mov	QWORD PTR [rcx], rax
	mov	BYTE PTR [rcx+8], dl
	add	rcx, 16
	mov	rdx, r8
	call	??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z ; Json::OurReader::OurReader
	npad	1
	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z ENDP	; Json::OurCharReader::OurCharReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
collectComments$ = 72
features$ = 80
?dtor$0@?0???0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z@4HA PROC ; `Json::OurCharReader::OurCharReader'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1CharReader@Json@@UEAA@XZ		; Json::CharReader::~CharReader
?dtor$0@?0???0OurCharReader@Json@@QEAA@_NAEBVOurFeatures@1@@Z@4HA ENDP ; `Json::OurCharReader::OurCharReader'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?parse@OurCharReader@Json@@UEAA_NPEBD0PEAVValue@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
__$ArrayPad$ = 80
this$ = 128
beginDoc$ = 136
endDoc$ = 144
root$ = 152
errs$ = 160
?parse@OurCharReader@Json@@UEAA_NPEBD0PEAVValue@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::OurCharReader::parse, COMDAT

; 1908 :       Value* root, JSONCPP_STRING* errs) JSONCPP_OVERRIDE {

$LN48:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1909 :     bool ok = reader_.parse(beginDoc, endDoc, *root, collectComments_);

	movzx	eax, BYTE PTR [rcx+8]
	mov	rdi, QWORD PTR errs$[rsp]
	lea	rsi, QWORD PTR [rcx+16]
	mov	rcx, rsi
	mov	BYTE PTR [rsp+32], al
	call	?parse@OurReader@Json@@QEAA_NPEBD0AEAVValue@2@_N@Z ; Json::OurReader::parse
	movzx	ebx, al

; 1910 :     if (errs) {

	test	rdi, rdi
	je	SHORT $LN46@parse

; 1911 :       *errs = reader_.getFormattedErrorMessages();

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rsi
	call	?getFormattedErrorMessages@OurReader@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::OurReader::getFormattedErrorMessages
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 903  : 		if (this != &_Right)

	cmp	rdi, rax
	je	SHORT $LN8@parse
	mov	rdx, rax
	mov	rcx, rdi
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
$LN8@parse:

; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T1[rsp+24], 16
	jb	SHORT $LN46@parse
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN46@parse:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1913 :     return ok;

	movzx	eax, bl

; 1914 :   }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?parse@OurCharReader@Json@@UEAA_NPEBD0PEAVValue@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::OurCharReader::parse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\include\json\reader.h
;	COMDAT ??_GOurCharReader@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GOurCharReader@Json@@UEAAPEAXI@Z PROC		; Json::OurCharReader::`scalar deleting destructor', COMDAT
$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	add	rcx, 16
	mov	ebx, edx
	call	??1OurReader@Json@@QEAA@XZ

; 251  :   virtual ~CharReader() {}

	lea	rax, OFFSET FLAT:??_7CharReader@Json@@6B@
	mov	QWORD PTR [rdi], rax
	test	bl, 1
	je	SHORT $LN8@scalar
	mov	rcx, rdi
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN8@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GOurCharReader@Json@@UEAAPEAXI@Z ENDP		; Json::OurCharReader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0CharReader@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0CharReader@Json@@QEAA@XZ PROC			; Json::CharReader::CharReader, COMDAT
	lea	rax, OFFSET FLAT:??_7CharReader@Json@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0CharReader@Json@@QEAA@XZ ENDP			; Json::CharReader::CharReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??1OurReader@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1OurReader@Json@@QEAA@XZ PROC				; Json::OurReader::~OurReader, COMDAT
$LN94:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rcx+176], 16
	mov	rdi, rcx
	jb	SHORT $LN23@OurReader
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rcx+152]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN23@OurReader:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	esi, esi

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+176], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+168], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi+152], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rdi+104], 16
	jb	SHORT $LN55@OurReader
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdi+80]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN55@OurReader:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+104], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+96], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1215 : 		_Tidy();

	lea	rcx, QWORD PTR [rdi+40]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi+80], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1215 : 		_Tidy();

	call	?_Tidy@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAXXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Tidy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdi+40]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1215 : 		_Tidy();

	mov	rcx, rdi

; 907  : 		this->_Myproxy = 0;

	mov	QWORD PTR [rdi+40], rsi

; 1215 : 		_Tidy();

	call	?_Tidy@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAXXZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Tidy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	mov	rbx, QWORD PTR [rsp+48]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 907  : 		this->_Myproxy = 0;

	mov	QWORD PTR [rdi], rsi
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1OurReader@Json@@QEAA@XZ ENDP				; Json::OurReader::~OurReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\include\json\reader.h
;	COMDAT ??1OurCharReader@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1OurCharReader@Json@@UEAA@XZ PROC			; Json::OurCharReader::~OurCharReader, COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	add	rcx, 16
	call	??1OurReader@Json@@QEAA@XZ

; 251  :   virtual ~CharReader() {}

	lea	rax, OFFSET FLAT:??_7CharReader@Json@@6B@
	mov	QWORD PTR [rbx], rax
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1OurCharReader@Json@@UEAA@XZ ENDP			; Json::OurCharReader::~OurCharReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\include\json\reader.h
;	COMDAT ??_GCharReaderBuilder@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_GCharReaderBuilder@Json@@UEAAPEAXI@Z PROC		; Json::CharReaderBuilder::`scalar deleting destructor', COMDAT
$LN11:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	ebx, edx
	mov	rdi, rcx
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1922 : {}

	lea	rax, OFFSET FLAT:??_7CharReaderBuilder@Json@@6B@
	mov	QWORD PTR [rcx], rax
	add	rcx, 8
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	npad	1
; File e:\jsoncpp-master\include\json\reader.h

; 275  :     virtual ~Factory() {}

	lea	rax, OFFSET FLAT:??_7Factory@CharReader@Json@@6B@
	mov	QWORD PTR [rdi], rax
	test	bl, 1
	je	SHORT $LN10@scalar
	mov	rcx, rdi
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN10@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??_GCharReaderBuilder@Json@@UEAAPEAXI@Z ENDP		; Json::CharReaderBuilder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
?dtor$0@?0???_GCharReaderBuilder@Json@@UEAAPEAXI@Z@4HA PROC ; `Json::CharReaderBuilder::`scalar deleting destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1Factory@CharReader@Json@@UEAA@XZ	; Json::CharReader::Factory::~Factory
?dtor$0@?0???_GCharReaderBuilder@Json@@UEAAPEAXI@Z@4HA ENDP ; `Json::CharReaderBuilder::`scalar deleting destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\include\json\reader.h
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ??1CharReaderBuilder@Json@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1CharReaderBuilder@Json@@UEAA@XZ PROC			; Json::CharReaderBuilder::~CharReaderBuilder, COMDAT

; 1922 : {}

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
	lea	rax, OFFSET FLAT:??_7CharReaderBuilder@Json@@6B@
	mov	QWORD PTR [rcx], rax
	add	rcx, 8
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	npad	1
; File e:\jsoncpp-master\include\json\reader.h

; 275  :     virtual ~Factory() {}

	lea	rax, OFFSET FLAT:??_7Factory@CharReader@Json@@6B@
	mov	QWORD PTR [rbx], rax
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1922 : {}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??1CharReaderBuilder@Json@@UEAA@XZ ENDP			; Json::CharReaderBuilder::~CharReaderBuilder
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1CharReaderBuilder@Json@@UEAA@XZ@4HA PROC	; `Json::CharReaderBuilder::~CharReaderBuilder'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1Factory@CharReader@Json@@UEAA@XZ	; Json::CharReader::Factory::~Factory
?dtor$0@?0???1CharReaderBuilder@Json@@UEAA@XZ@4HA ENDP	; `Json::CharReaderBuilder::~CharReaderBuilder'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp
;	COMDAT ?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ PROC ; Json::CharReaderBuilder::newCharReader, COMDAT

; 1924 : {

$LN424:
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rbp
	mov	QWORD PTR [rsp+104], rsi

; 1925 :   bool collectComments = settings_["collectComments"].asBool();

	lea	rdi, QWORD PTR [rcx+8]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0BA@MMGBJGAD@collectComments?$AA@+15
	lea	rdx, OFFSET FLAT:??_C@_0BA@MMGBJGAD@collectComments?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	xor	ebp, ebp
	lea	rbx, OFFSET FLAT:?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B
	test	rax, rax
	jne	SHORT $LN7@newCharRea

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN9@newCharRea
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, bpl

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rbp

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN9@newCharRea:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN7@newCharRea:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1925 :   bool collectComments = settings_["collectComments"].asBool();

	mov	rcx, rax
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	movzx	esi, al

; 915  : OurFeatures OurFeatures::all() { return OurFeatures(); }

	xor	edx, edx
	mov	QWORD PTR $T2[rsp], rdx

; 1926 :   OurFeatures features = OurFeatures::all();

	movsdx	xmm0, QWORD PTR $T2[rsp]
	movsdx	QWORD PTR features$[rsp], xmm0
	mov	DWORD PTR features$[rsp+8], edx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0O@DMCAHIJE@allowComments?$AA@+13
	lea	rdx, OFFSET FLAT:??_C@_0O@DMCAHIJE@allowComments?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN50@newCharRea

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN52@newCharRea
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, 0

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rbp

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN52@newCharRea:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN50@newCharRea:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1927 :   features.allowComments_ = settings_["allowComments"].asBool();

	mov	rcx, rax
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	mov	BYTE PTR features$[rsp], al
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0L@BOEIFNHO@strictRoot?$AA@+10
	lea	rdx, OFFSET FLAT:??_C@_0L@BOEIFNHO@strictRoot?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN91@newCharRea

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN93@newCharRea
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, 0

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rbp

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN93@newCharRea:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN91@newCharRea:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1928 :   features.strictRoot_ = settings_["strictRoot"].asBool();

	mov	rcx, rax
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	mov	BYTE PTR features$[rsp+1], al
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0BN@FGKEHPGK@allowDroppedNullPlaceholders?$AA@+28
	lea	rdx, OFFSET FLAT:??_C@_0BN@FGKEHPGK@allowDroppedNullPlaceholders?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN132@newCharRea

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN134@newCharRea
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, 0

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rbp

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN134@newCharRea:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN132@newCharRea:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1929 :   features.allowDroppedNullPlaceholders_ = settings_["allowDroppedNullPlaceholders"].asBool();

	mov	rcx, rax
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	mov	BYTE PTR features$[rsp+2], al
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0BB@CACNEFJM@allowNumericKeys?$AA@+16
	lea	rdx, OFFSET FLAT:??_C@_0BB@CACNEFJM@allowNumericKeys?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN173@newCharRea

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN175@newCharRea
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, 0

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rbp

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN175@newCharRea:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN173@newCharRea:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1930 :   features.allowNumericKeys_ = settings_["allowNumericKeys"].asBool();

	mov	rcx, rax
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	mov	BYTE PTR features$[rsp+3], al
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0BC@IPFEJEO@allowSingleQuotes?$AA@+17
	lea	rdx, OFFSET FLAT:??_C@_0BC@IPFEJEO@allowSingleQuotes?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN214@newCharRea

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN216@newCharRea
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, 0

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rbp

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN216@newCharRea:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN214@newCharRea:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1931 :   features.allowSingleQuotes_ = settings_["allowSingleQuotes"].asBool();

	mov	rcx, rax
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	mov	BYTE PTR features$[rsp+4], al
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0L@LJHGMJAL@stackLimit?$AA@+10
	lea	rdx, OFFSET FLAT:??_C@_0L@LJHGMJAL@stackLimit?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN255@newCharRea

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN257@newCharRea
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, 0

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rbp

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN257@newCharRea:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN255@newCharRea:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1932 :   features.stackLimit_ = settings_["stackLimit"].asInt();

	mov	rcx, rax
	call	?asInt@Value@Json@@QEBAHXZ		; Json::Value::asInt
	mov	DWORD PTR features$[rsp+8], eax
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0M@MCPHKFFB@failIfExtra?$AA@+11
	lea	rdx, OFFSET FLAT:??_C@_0M@MCPHKFFB@failIfExtra?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN296@newCharRea

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN298@newCharRea
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, 0

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rbp

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN298@newCharRea:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN296@newCharRea:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1933 :   features.failIfExtra_ = settings_["failIfExtra"].asBool();

	mov	rcx, rax
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	mov	BYTE PTR features$[rsp+5], al
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0O@CGKMCCPN@rejectDupKeys?$AA@+13
	lea	rdx, OFFSET FLAT:??_C@_0O@CGKMCCPN@rejectDupKeys?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN337@newCharRea

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN339@newCharRea
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, 0

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rbp

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN339@newCharRea:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN337@newCharRea:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1934 :   features.rejectDupKeys_ = settings_["rejectDupKeys"].asBool();

	mov	rcx, rax
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	mov	BYTE PTR features$[rsp+6], al
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0BD@EAKIPOJB@allowSpecialFloats?$AA@+18
	lea	rdx, OFFSET FLAT:??_C@_0BD@EAKIPOJB@allowSpecialFloats?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN377@newCharRea

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN378@newCharRea
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, 0

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rbp

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1

; 1091 :   if (!found) return nullSingleton();

	jmp	SHORT $LN378@newCharRea
$LN377@newCharRea:

; 1092 :   return *found;

	mov	rbx, rax
$LN378@newCharRea:
; File e:\jsoncpp-master\src\lib_json\json_reader.cpp

; 1935 :   features.allowSpecialFloats_ = settings_["allowSpecialFloats"].asBool();

	mov	rcx, rbx
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	mov	BYTE PTR features$[rsp+7], al

; 1936 :   return new OurCharReader(collectComments, features);

	mov	ecx, 216				; 000000d8H
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	rbx, rax
	mov	QWORD PTR $T3[rsp], rax
	test	rax, rax
	je	SHORT $LN3@newCharRea

; 916  : 
; 917  : // Implementation of class Reader
; 918  : // ////////////////////////////////
; 919  : 
; 920  : // exact copy of Reader, renamed to OurReader
; 921  : class OurReader {
; 922  : public:
; 923  :   typedef char Char;
; 924  :   typedef const Char* Location;
; 925  :   struct StructuredError {
; 926  :     ptrdiff_t offset_start;
; 927  :     ptrdiff_t offset_limit;
; 928  :     JSONCPP_STRING message;
; 929  :   };
; 930  : 
; 931  :   OurReader(OurFeatures const& features);
; 932  :   bool parse(const char* beginDoc,
; 933  :              const char* endDoc,
; 934  :              Value& root,
; 935  :              bool collectComments = true);
; 936  :   JSONCPP_STRING getFormattedErrorMessages() const;
; 937  :   std::vector<StructuredError> getStructuredErrors() const;
; 938  :   bool pushError(const Value& value, const JSONCPP_STRING& message);
; 939  :   bool pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra);
; 940  :   bool good() const;
; 941  : 
; 942  : private:
; 943  :   OurReader(OurReader const&);  // no impl
; 944  :   void operator=(OurReader const&);  // no impl
; 945  : 
; 946  :   enum TokenType {
; 947  :     tokenEndOfStream = 0,
; 948  :     tokenObjectBegin,
; 949  :     tokenObjectEnd,
; 950  :     tokenArrayBegin,
; 951  :     tokenArrayEnd,
; 952  :     tokenString,
; 953  :     tokenNumber,
; 954  :     tokenTrue,
; 955  :     tokenFalse,
; 956  :     tokenNull,
; 957  :     tokenNaN,
; 958  :     tokenPosInf,
; 959  :     tokenNegInf,
; 960  :     tokenArraySeparator,
; 961  :     tokenMemberSeparator,
; 962  :     tokenComment,
; 963  :     tokenError
; 964  :   };
; 965  : 
; 966  :   class Token {
; 967  :   public:
; 968  :     TokenType type_;
; 969  :     Location start_;
; 970  :     Location end_;
; 971  :   };
; 972  : 
; 973  :   class ErrorInfo {
; 974  :   public:
; 975  :     Token token_;
; 976  :     JSONCPP_STRING message_;
; 977  :     Location extra_;
; 978  :   };
; 979  : 
; 980  :   typedef std::deque<ErrorInfo> Errors;
; 981  : 
; 982  :   bool readToken(Token& token);
; 983  :   void skipSpaces();
; 984  :   bool match(Location pattern, int patternLength);
; 985  :   bool readComment();
; 986  :   bool readCStyleComment();
; 987  :   bool readCppStyleComment();
; 988  :   bool readString();
; 989  :   bool readStringSingleQuote();
; 990  :   bool readNumber(bool checkInf);
; 991  :   bool readValue();
; 992  :   bool readObject(Token& token);
; 993  :   bool readArray(Token& token);
; 994  :   bool decodeNumber(Token& token);
; 995  :   bool decodeNumber(Token& token, Value& decoded);
; 996  :   bool decodeString(Token& token);
; 997  :   bool decodeString(Token& token, JSONCPP_STRING& decoded);
; 998  :   bool decodeDouble(Token& token);
; 999  :   bool decodeDouble(Token& token, Value& decoded);
; 1000 :   bool decodeUnicodeCodePoint(Token& token,
; 1001 :                               Location& current,
; 1002 :                               Location end,
; 1003 :                               unsigned int& unicode);
; 1004 :   bool decodeUnicodeEscapeSequence(Token& token,
; 1005 :                                    Location& current,
; 1006 :                                    Location end,
; 1007 :                                    unsigned int& unicode);
; 1008 :   bool addError(const JSONCPP_STRING& message, Token& token, Location extra = 0);
; 1009 :   bool recoverFromError(TokenType skipUntilToken);
; 1010 :   bool addErrorAndRecover(const JSONCPP_STRING& message,
; 1011 :                           Token& token,
; 1012 :                           TokenType skipUntilToken);
; 1013 :   void skipUntilSpace();
; 1014 :   Value& currentValue();
; 1015 :   Char getNextChar();
; 1016 :   void
; 1017 :   getLocationLineAndColumn(Location location, int& line, int& column) const;
; 1018 :   JSONCPP_STRING getLocationLineAndColumn(Location location) const;
; 1019 :   void addComment(Location begin, Location end, CommentPlacement placement);
; 1020 :   void skipCommentTokens(Token& token);
; 1021 : 
; 1022 :   typedef std::stack<Value*> Nodes;
; 1023 :   Nodes nodes_;
; 1024 :   Errors errors_;
; 1025 :   JSONCPP_STRING document_;
; 1026 :   Location begin_;
; 1027 :   Location end_;
; 1028 :   Location current_;
; 1029 :   Location lastValueEnd_;
; 1030 :   Value* lastValue_;
; 1031 :   JSONCPP_STRING commentsBefore_;
; 1032 : 
; 1033 :   OurFeatures const features_;
; 1034 :   bool collectComments_;
; 1035 : };  // OurReader
; 1036 : 
; 1037 : // complete copy of Read impl, for OurReader
; 1038 : 
; 1039 : OurReader::OurReader(OurFeatures const& features)
; 1040 :     : errors_(), document_(), begin_(), end_(), current_(), lastValueEnd_(),
; 1041 :       lastValue_(), commentsBefore_(),
; 1042 :       features_(features), collectComments_() {
; 1043 : }
; 1044 : 
; 1045 : bool OurReader::parse(const char* beginDoc,
; 1046 :                    const char* endDoc,
; 1047 :                    Value& root,
; 1048 :                    bool collectComments) {
; 1049 :   if (!features_.allowComments_) {
; 1050 :     collectComments = false;
; 1051 :   }
; 1052 : 
; 1053 :   begin_ = beginDoc;
; 1054 :   end_ = endDoc;
; 1055 :   collectComments_ = collectComments;
; 1056 :   current_ = begin_;
; 1057 :   lastValueEnd_ = 0;
; 1058 :   lastValue_ = 0;
; 1059 :   commentsBefore_.clear();
; 1060 :   errors_.clear();
; 1061 :   while (!nodes_.empty())
; 1062 :     nodes_.pop();
; 1063 :   nodes_.push(&root);
; 1064 : 
; 1065 :   bool successful = readValue();
; 1066 :   Token token;
; 1067 :   skipCommentTokens(token);
; 1068 :   if (features_.failIfExtra_) {
; 1069 :     if ((features_.strictRoot_ || token.type_ != tokenError) && token.type_ != tokenEndOfStream) {
; 1070 :       addError("Extra non-whitespace after JSON value.", token);
; 1071 :       return false;
; 1072 :     }
; 1073 :   }
; 1074 :   if (collectComments_ && !commentsBefore_.empty())
; 1075 :     root.setComment(commentsBefore_, commentAfter);
; 1076 :   if (features_.strictRoot_) {
; 1077 :     if (!root.isArray() && !root.isObject()) {
; 1078 :       // Set error location to start of doc, ideally should be first token found
; 1079 :       // in doc
; 1080 :       token.type_ = tokenError;
; 1081 :       token.start_ = beginDoc;
; 1082 :       token.end_ = endDoc;
; 1083 :       addError(
; 1084 :           "A valid JSON document must be either an array or an object value.",
; 1085 :           token);
; 1086 :       return false;
; 1087 :     }
; 1088 :   }
; 1089 :   return successful;
; 1090 : }
; 1091 : 
; 1092 : bool OurReader::readValue() {
; 1093 :   //  To preserve the old behaviour we cast size_t to int.
; 1094 :   if (static_cast<int>(nodes_.size()) > features_.stackLimit_) throwRuntimeError("Exceeded stackLimit in readValue().");
; 1095 :   Token token;
; 1096 :   skipCommentTokens(token);
; 1097 :   bool successful = true;
; 1098 : 
; 1099 :   if (collectComments_ && !commentsBefore_.empty()) {
; 1100 :     currentValue().setComment(commentsBefore_, commentBefore);
; 1101 :     commentsBefore_.clear();
; 1102 :   }
; 1103 : 
; 1104 :   switch (token.type_) {
; 1105 :   case tokenObjectBegin:
; 1106 :     successful = readObject(token);
; 1107 :     currentValue().setOffsetLimit(current_ - begin_);
; 1108 :     break;
; 1109 :   case tokenArrayBegin:
; 1110 :     successful = readArray(token);
; 1111 :     currentValue().setOffsetLimit(current_ - begin_);
; 1112 :     break;
; 1113 :   case tokenNumber:
; 1114 :     successful = decodeNumber(token);
; 1115 :     break;
; 1116 :   case tokenString:
; 1117 :     successful = decodeString(token);
; 1118 :     break;
; 1119 :   case tokenTrue:
; 1120 :     {
; 1121 :     Value v(true);
; 1122 :     currentValue().swapPayload(v);
; 1123 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1124 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1125 :     }
; 1126 :     break;
; 1127 :   case tokenFalse:
; 1128 :     {
; 1129 :     Value v(false);
; 1130 :     currentValue().swapPayload(v);
; 1131 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1132 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1133 :     }
; 1134 :     break;
; 1135 :   case tokenNull:
; 1136 :     {
; 1137 :     Value v;
; 1138 :     currentValue().swapPayload(v);
; 1139 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1140 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1141 :     }
; 1142 :     break;
; 1143 :   case tokenNaN:
; 1144 :     {
; 1145 :     Value v(std::numeric_limits<double>::quiet_NaN());
; 1146 :     currentValue().swapPayload(v);
; 1147 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1148 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1149 :     }
; 1150 :     break;
; 1151 :   case tokenPosInf:
; 1152 :     {
; 1153 :     Value v(std::numeric_limits<double>::infinity());
; 1154 :     currentValue().swapPayload(v);
; 1155 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1156 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1157 :     }
; 1158 :     break;
; 1159 :   case tokenNegInf:
; 1160 :     {
; 1161 :     Value v(-std::numeric_limits<double>::infinity());
; 1162 :     currentValue().swapPayload(v);
; 1163 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1164 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1165 :     }
; 1166 :     break;
; 1167 :   case tokenArraySeparator:
; 1168 :   case tokenObjectEnd:
; 1169 :   case tokenArrayEnd:
; 1170 :     if (features_.allowDroppedNullPlaceholders_) {
; 1171 :       // "Un-read" the current token and mark the current value as a null
; 1172 :       // token.
; 1173 :       current_--;
; 1174 :       Value v;
; 1175 :       currentValue().swapPayload(v);
; 1176 :       currentValue().setOffsetStart(current_ - begin_ - 1);
; 1177 :       currentValue().setOffsetLimit(current_ - begin_);
; 1178 :       break;
; 1179 :     } // else, fall through ...
; 1180 :   default:
; 1181 :     currentValue().setOffsetStart(token.start_ - begin_);
; 1182 :     currentValue().setOffsetLimit(token.end_ - begin_);
; 1183 :     return addError("Syntax error: value, object or array expected.", token);
; 1184 :   }
; 1185 : 
; 1186 :   if (collectComments_) {
; 1187 :     lastValueEnd_ = current_;
; 1188 :     lastValue_ = &currentValue();
; 1189 :   }
; 1190 : 
; 1191 :   return successful;
; 1192 : }
; 1193 : 
; 1194 : void OurReader::skipCommentTokens(Token& token) {
; 1195 :   if (features_.allowComments_) {
; 1196 :     do {
; 1197 :       readToken(token);
; 1198 :     } while (token.type_ == tokenComment);
; 1199 :   } else {
; 1200 :     readToken(token);
; 1201 :   }
; 1202 : }
; 1203 : 
; 1204 : bool OurReader::readToken(Token& token) {
; 1205 :   skipSpaces();
; 1206 :   token.start_ = current_;
; 1207 :   Char c = getNextChar();
; 1208 :   bool ok = true;
; 1209 :   switch (c) {
; 1210 :   case '{':
; 1211 :     token.type_ = tokenObjectBegin;
; 1212 :     break;
; 1213 :   case '}':
; 1214 :     token.type_ = tokenObjectEnd;
; 1215 :     break;
; 1216 :   case '[':
; 1217 :     token.type_ = tokenArrayBegin;
; 1218 :     break;
; 1219 :   case ']':
; 1220 :     token.type_ = tokenArrayEnd;
; 1221 :     break;
; 1222 :   case '"':
; 1223 :     token.type_ = tokenString;
; 1224 :     ok = readString();
; 1225 :     break;
; 1226 :   case '\'':
; 1227 :     if (features_.allowSingleQuotes_) {
; 1228 :     token.type_ = tokenString;
; 1229 :     ok = readStringSingleQuote();
; 1230 :     break;
; 1231 :     } // else continue
; 1232 :   case '/':
; 1233 :     token.type_ = tokenComment;
; 1234 :     ok = readComment();
; 1235 :     break;
; 1236 :   case '0':
; 1237 :   case '1':
; 1238 :   case '2':
; 1239 :   case '3':
; 1240 :   case '4':
; 1241 :   case '5':
; 1242 :   case '6':
; 1243 :   case '7':
; 1244 :   case '8':
; 1245 :   case '9':
; 1246 :     token.type_ = tokenNumber;
; 1247 :     readNumber(false);
; 1248 :     break;
; 1249 :   case '-':
; 1250 :     if (readNumber(true)) {
; 1251 :       token.type_ = tokenNumber;
; 1252 :     } else {
; 1253 :       token.type_ = tokenNegInf;
; 1254 :       ok = features_.allowSpecialFloats_ && match("nfinity", 7);
; 1255 :     }
; 1256 :     break;
; 1257 :   case 't':
; 1258 :     token.type_ = tokenTrue;
; 1259 :     ok = match("rue", 3);
; 1260 :     break;
; 1261 :   case 'f':
; 1262 :     token.type_ = tokenFalse;
; 1263 :     ok = match("alse", 4);
; 1264 :     break;
; 1265 :   case 'n':
; 1266 :     token.type_ = tokenNull;
; 1267 :     ok = match("ull", 3);
; 1268 :     break;
; 1269 :   case 'N':
; 1270 :     if (features_.allowSpecialFloats_) {
; 1271 :       token.type_ = tokenNaN;
; 1272 :       ok = match("aN", 2);
; 1273 :     } else {
; 1274 :       ok = false;
; 1275 :     }
; 1276 :     break;
; 1277 :   case 'I':
; 1278 :     if (features_.allowSpecialFloats_) {
; 1279 :       token.type_ = tokenPosInf;
; 1280 :       ok = match("nfinity", 7);
; 1281 :     } else {
; 1282 :       ok = false;
; 1283 :     }
; 1284 :     break;
; 1285 :   case ',':
; 1286 :     token.type_ = tokenArraySeparator;
; 1287 :     break;
; 1288 :   case ':':
; 1289 :     token.type_ = tokenMemberSeparator;
; 1290 :     break;
; 1291 :   case 0:
; 1292 :     token.type_ = tokenEndOfStream;
; 1293 :     break;
; 1294 :   default:
; 1295 :     ok = false;
; 1296 :     break;
; 1297 :   }
; 1298 :   if (!ok)
; 1299 :     token.type_ = tokenError;
; 1300 :   token.end_ = current_;
; 1301 :   return true;
; 1302 : }
; 1303 : 
; 1304 : void OurReader::skipSpaces() {
; 1305 :   while (current_ != end_) {
; 1306 :     Char c = *current_;
; 1307 :     if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
; 1308 :       ++current_;
; 1309 :     else
; 1310 :       break;
; 1311 :   }
; 1312 : }
; 1313 : 
; 1314 : bool OurReader::match(Location pattern, int patternLength) {
; 1315 :   if (end_ - current_ < patternLength)
; 1316 :     return false;
; 1317 :   int index = patternLength;
; 1318 :   while (index--)
; 1319 :     if (current_[index] != pattern[index])
; 1320 :       return false;
; 1321 :   current_ += patternLength;
; 1322 :   return true;
; 1323 : }
; 1324 : 
; 1325 : bool OurReader::readComment() {
; 1326 :   Location commentBegin = current_ - 1;
; 1327 :   Char c = getNextChar();
; 1328 :   bool successful = false;
; 1329 :   if (c == '*')
; 1330 :     successful = readCStyleComment();
; 1331 :   else if (c == '/')
; 1332 :     successful = readCppStyleComment();
; 1333 :   if (!successful)
; 1334 :     return false;
; 1335 : 
; 1336 :   if (collectComments_) {
; 1337 :     CommentPlacement placement = commentBefore;
; 1338 :     if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
; 1339 :       if (c != '*' || !containsNewLine(commentBegin, current_))
; 1340 :         placement = commentAfterOnSameLine;
; 1341 :     }
; 1342 : 
; 1343 :     addComment(commentBegin, current_, placement);
; 1344 :   }
; 1345 :   return true;
; 1346 : }
; 1347 : 
; 1348 : void
; 1349 : OurReader::addComment(Location begin, Location end, CommentPlacement placement) {
; 1350 :   assert(collectComments_);
; 1351 :   const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
; 1352 :   if (placement == commentAfterOnSameLine) {
; 1353 :     assert(lastValue_ != 0);
; 1354 :     lastValue_->setComment(normalized, placement);
; 1355 :   } else {
; 1356 :     commentsBefore_ += normalized;
; 1357 :   }
; 1358 : }
; 1359 : 
; 1360 : bool OurReader::readCStyleComment() {
; 1361 :   while ((current_ + 1) < end_) {
; 1362 :     Char c = getNextChar();
; 1363 :     if (c == '*' && *current_ == '/')
; 1364 :       break;
; 1365 :   }
; 1366 :   return getNextChar() == '/';
; 1367 : }
; 1368 : 
; 1369 : bool OurReader::readCppStyleComment() {
; 1370 :   while (current_ != end_) {
; 1371 :     Char c = getNextChar();
; 1372 :     if (c == '\n')
; 1373 :       break;
; 1374 :     if (c == '\r') {
; 1375 :       // Consume DOS EOL. It will be normalized in addComment.
; 1376 :       if (current_ != end_ && *current_ == '\n')
; 1377 :         getNextChar();
; 1378 :       // Break on Moc OS 9 EOL.
; 1379 :       break;
; 1380 :     }
; 1381 :   }
; 1382 :   return true;
; 1383 : }
; 1384 : 
; 1385 : bool OurReader::readNumber(bool checkInf) {
; 1386 :   const char *p = current_;
; 1387 :   if (checkInf && p != end_ && *p == 'I') {
; 1388 :     current_ = ++p;
; 1389 :     return false;
; 1390 :   }
; 1391 :   char c = '0'; // stopgap for already consumed character
; 1392 :   // integral part
; 1393 :   while (c >= '0' && c <= '9')
; 1394 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1395 :   // fractional part
; 1396 :   if (c == '.') {
; 1397 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1398 :     while (c >= '0' && c <= '9')
; 1399 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1400 :   }
; 1401 :   // exponential part
; 1402 :   if (c == 'e' || c == 'E') {
; 1403 :     c = (current_ = p) < end_ ? *p++ : '\0';
; 1404 :     if (c == '+' || c == '-')
; 1405 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1406 :     while (c >= '0' && c <= '9')
; 1407 :       c = (current_ = p) < end_ ? *p++ : '\0';
; 1408 :   }
; 1409 :   return true;
; 1410 : }
; 1411 : bool OurReader::readString() {
; 1412 :   Char c = 0;
; 1413 :   while (current_ != end_) {
; 1414 :     c = getNextChar();
; 1415 :     if (c == '\\')
; 1416 :       getNextChar();
; 1417 :     else if (c == '"')
; 1418 :       break;
; 1419 :   }
; 1420 :   return c == '"';
; 1421 : }
; 1422 : 
; 1423 : 
; 1424 : bool OurReader::readStringSingleQuote() {
; 1425 :   Char c = 0;
; 1426 :   while (current_ != end_) {
; 1427 :     c = getNextChar();
; 1428 :     if (c == '\\')
; 1429 :       getNextChar();
; 1430 :     else if (c == '\'')
; 1431 :       break;
; 1432 :   }
; 1433 :   return c == '\'';
; 1434 : }
; 1435 : 
; 1436 : bool OurReader::readObject(Token& tokenStart) {
; 1437 :   Token tokenName;
; 1438 :   JSONCPP_STRING name;
; 1439 :   Value init(objectValue);
; 1440 :   currentValue().swapPayload(init);
; 1441 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1442 :   while (readToken(tokenName)) {
; 1443 :     bool initialTokenOk = true;
; 1444 :     while (tokenName.type_ == tokenComment && initialTokenOk)
; 1445 :       initialTokenOk = readToken(tokenName);
; 1446 :     if (!initialTokenOk)
; 1447 :       break;
; 1448 :     if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
; 1449 :       return true;
; 1450 :     name.clear();
; 1451 :     if (tokenName.type_ == tokenString) {
; 1452 :       if (!decodeString(tokenName, name))
; 1453 :         return recoverFromError(tokenObjectEnd);
; 1454 :     } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
; 1455 :       Value numberName;
; 1456 :       if (!decodeNumber(tokenName, numberName))
; 1457 :         return recoverFromError(tokenObjectEnd);
; 1458 :       name = numberName.asString();
; 1459 :     } else {
; 1460 :       break;
; 1461 :     }
; 1462 : 
; 1463 :     Token colon;
; 1464 :     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
; 1465 :       return addErrorAndRecover(
; 1466 :           "Missing ':' after object member name", colon, tokenObjectEnd);
; 1467 :     }
; 1468 :     if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
; 1469 :     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
; 1470 :       JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
; 1471 :       return addErrorAndRecover(
; 1472 :           msg, tokenName, tokenObjectEnd);
; 1473 :     }
; 1474 :     Value& value = currentValue()[name];
; 1475 :     nodes_.push(&value);
; 1476 :     bool ok = readValue();
; 1477 :     nodes_.pop();
; 1478 :     if (!ok) // error already set
; 1479 :       return recoverFromError(tokenObjectEnd);
; 1480 : 
; 1481 :     Token comma;
; 1482 :     if (!readToken(comma) ||
; 1483 :         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
; 1484 :          comma.type_ != tokenComment)) {
; 1485 :       return addErrorAndRecover(
; 1486 :           "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
; 1487 :     }
; 1488 :     bool finalizeTokenOk = true;
; 1489 :     while (comma.type_ == tokenComment && finalizeTokenOk)
; 1490 :       finalizeTokenOk = readToken(comma);
; 1491 :     if (comma.type_ == tokenObjectEnd)
; 1492 :       return true;
; 1493 :   }
; 1494 :   return addErrorAndRecover(
; 1495 :       "Missing '}' or object member name", tokenName, tokenObjectEnd);
; 1496 : }
; 1497 : 
; 1498 : bool OurReader::readArray(Token& tokenStart) {
; 1499 :   Value init(arrayValue);
; 1500 :   currentValue().swapPayload(init);
; 1501 :   currentValue().setOffsetStart(tokenStart.start_ - begin_);
; 1502 :   skipSpaces();
; 1503 :   if (current_ != end_ && *current_ == ']') // empty array
; 1504 :   {
; 1505 :     Token endArray;
; 1506 :     readToken(endArray);
; 1507 :     return true;
; 1508 :   }
; 1509 :   int index = 0;
; 1510 :   for (;;) {
; 1511 :     Value& value = currentValue()[index++];
; 1512 :     nodes_.push(&value);
; 1513 :     bool ok = readValue();
; 1514 :     nodes_.pop();
; 1515 :     if (!ok) // error already set
; 1516 :       return recoverFromError(tokenArrayEnd);
; 1517 : 
; 1518 :     Token token;
; 1519 :     // Accept Comment after last item in the array.
; 1520 :     ok = readToken(token);
; 1521 :     while (token.type_ == tokenComment && ok) {
; 1522 :       ok = readToken(token);
; 1523 :     }
; 1524 :     bool badTokenType =
; 1525 :         (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
; 1526 :     if (!ok || badTokenType) {
; 1527 :       return addErrorAndRecover(
; 1528 :           "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
; 1529 :     }
; 1530 :     if (token.type_ == tokenArrayEnd)
; 1531 :       break;
; 1532 :   }
; 1533 :   return true;
; 1534 : }
; 1535 : 
; 1536 : bool OurReader::decodeNumber(Token& token) {
; 1537 :   Value decoded;
; 1538 :   if (!decodeNumber(token, decoded))
; 1539 :     return false;
; 1540 :   currentValue().swapPayload(decoded);
; 1541 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1542 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1543 :   return true;
; 1544 : }
; 1545 : 
; 1546 : bool OurReader::decodeNumber(Token& token, Value& decoded) {
; 1547 :   // Attempts to parse the number as an integer. If the number is
; 1548 :   // larger than the maximum supported value of an integer then
; 1549 :   // we decode the number as a double.
; 1550 :   Location current = token.start_;
; 1551 :   bool isNegative = *current == '-';
; 1552 :   if (isNegative)
; 1553 :     ++current;
; 1554 :   // TODO: Help the compiler do the div and mod at compile time or get rid of them.
; 1555 :   Value::LargestUInt maxIntegerValue =
; 1556 :       isNegative ? Value::LargestUInt(-Value::minLargestInt)
; 1557 :                  : Value::maxLargestUInt;
; 1558 :   Value::LargestUInt threshold = maxIntegerValue / 10;
; 1559 :   Value::LargestUInt value = 0;
; 1560 :   while (current < token.end_) {
; 1561 :     Char c = *current++;
; 1562 :     if (c < '0' || c > '9')
; 1563 :       return decodeDouble(token, decoded);
; 1564 :     Value::UInt digit(static_cast<Value::UInt>(c - '0'));
; 1565 :     if (value >= threshold) {
; 1566 :       // We've hit or exceeded the max value divided by 10 (rounded down). If
; 1567 :       // a) we've only just touched the limit, b) this is the last digit, and
; 1568 :       // c) it's small enough to fit in that rounding delta, we're okay.
; 1569 :       // Otherwise treat this number as a double to avoid overflow.
; 1570 :       if (value > threshold || current != token.end_ ||
; 1571 :           digit > maxIntegerValue % 10) {
; 1572 :         return decodeDouble(token, decoded);
; 1573 :       }
; 1574 :     }
; 1575 :     value = value * 10 + digit;
; 1576 :   }
; 1577 :   if (isNegative)
; 1578 :     decoded = -Value::LargestInt(value);
; 1579 :   else if (value <= Value::LargestUInt(Value::maxInt))
; 1580 :     decoded = Value::LargestInt(value);
; 1581 :   else
; 1582 :     decoded = value;
; 1583 :   return true;
; 1584 : }
; 1585 : 
; 1586 : bool OurReader::decodeDouble(Token& token) {
; 1587 :   Value decoded;
; 1588 :   if (!decodeDouble(token, decoded))
; 1589 :     return false;
; 1590 :   currentValue().swapPayload(decoded);
; 1591 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1592 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1593 :   return true;
; 1594 : }
; 1595 : 
; 1596 : bool OurReader::decodeDouble(Token& token, Value& decoded) {
; 1597 :   double value = 0;
; 1598 :   const int bufferSize = 32;
; 1599 :   int count;
; 1600 :   ptrdiff_t const length = token.end_ - token.start_;
; 1601 : 
; 1602 :   // Sanity check to avoid buffer overflow exploits.
; 1603 :   if (length < 0) {
; 1604 :     return addError("Unable to parse token length", token);
; 1605 :   }
; 1606 :   size_t const ulength = static_cast<size_t>(length);
; 1607 : 
; 1608 :   // Avoid using a string constant for the format control string given to
; 1609 :   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 1610 :   // info:
; 1611 :   //
; 1612 :   //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 1613 :   char format[] = "%lf";
; 1614 : 
; 1615 :   if (length <= bufferSize) {
; 1616 :     Char buffer[bufferSize + 1];
; 1617 :     memcpy(buffer, token.start_, ulength);
; 1618 :     buffer[length] = 0;
; 1619 :     fixNumericLocaleInput(buffer, buffer + length);
; 1620 :     count = sscanf(buffer, format, &value);
; 1621 :   } else {
; 1622 :     JSONCPP_STRING buffer(token.start_, token.end_);
; 1623 :     count = sscanf(buffer.c_str(), format, &value);
; 1624 :   }
; 1625 : 
; 1626 :   if (count != 1)
; 1627 :     return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
; 1628 :                         "' is not a number.",
; 1629 :                     token);
; 1630 :   decoded = value;
; 1631 :   return true;
; 1632 : }
; 1633 : 
; 1634 : bool OurReader::decodeString(Token& token) {
; 1635 :   JSONCPP_STRING decoded_string;
; 1636 :   if (!decodeString(token, decoded_string))
; 1637 :     return false;
; 1638 :   Value decoded(decoded_string);
; 1639 :   currentValue().swapPayload(decoded);
; 1640 :   currentValue().setOffsetStart(token.start_ - begin_);
; 1641 :   currentValue().setOffsetLimit(token.end_ - begin_);
; 1642 :   return true;
; 1643 : }
; 1644 : 
; 1645 : bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
; 1646 :   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
; 1647 :   Location current = token.start_ + 1; // skip '"'
; 1648 :   Location end = token.end_ - 1;       // do not include '"'
; 1649 :   while (current != end) {
; 1650 :     Char c = *current++;
; 1651 :     if (c == '"')
; 1652 :       break;
; 1653 :     else if (c == '\\') {
; 1654 :       if (current == end)
; 1655 :         return addError("Empty escape sequence in string", token, current);
; 1656 :       Char escape = *current++;
; 1657 :       switch (escape) {
; 1658 :       case '"':
; 1659 :         decoded += '"';
; 1660 :         break;
; 1661 :       case '/':
; 1662 :         decoded += '/';
; 1663 :         break;
; 1664 :       case '\\':
; 1665 :         decoded += '\\';
; 1666 :         break;
; 1667 :       case 'b':
; 1668 :         decoded += '\b';
; 1669 :         break;
; 1670 :       case 'f':
; 1671 :         decoded += '\f';
; 1672 :         break;
; 1673 :       case 'n':
; 1674 :         decoded += '\n';
; 1675 :         break;
; 1676 :       case 'r':
; 1677 :         decoded += '\r';
; 1678 :         break;
; 1679 :       case 't':
; 1680 :         decoded += '\t';
; 1681 :         break;
; 1682 :       case 'u': {
; 1683 :         unsigned int unicode;
; 1684 :         if (!decodeUnicodeCodePoint(token, current, end, unicode))
; 1685 :           return false;
; 1686 :         decoded += codePointToUTF8(unicode);
; 1687 :       } break;
; 1688 :       default:
; 1689 :         return addError("Bad escape sequence in string", token, current);
; 1690 :       }
; 1691 :     } else {
; 1692 :       decoded += c;
; 1693 :     }
; 1694 :   }
; 1695 :   return true;
; 1696 : }
; 1697 : 
; 1698 : bool OurReader::decodeUnicodeCodePoint(Token& token,
; 1699 :                                     Location& current,
; 1700 :                                     Location end,
; 1701 :                                     unsigned int& unicode) {
; 1702 : 
; 1703 :   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
; 1704 :     return false;
; 1705 :   if (unicode >= 0xD800 && unicode <= 0xDBFF) {
; 1706 :     // surrogate pairs
; 1707 :     if (end - current < 6)
; 1708 :       return addError(
; 1709 :           "additional six characters expected to parse unicode surrogate pair.",
; 1710 :           token,
; 1711 :           current);
; 1712 :     unsigned int surrogatePair;
; 1713 :     if (*(current++) == '\\' && *(current++) == 'u') {
; 1714 :       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
; 1715 :         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
; 1716 :       } else
; 1717 :         return false;
; 1718 :     } else
; 1719 :       return addError("expecting another \\u token to begin the second half of "
; 1720 :                       "a unicode surrogate pair",
; 1721 :                       token,
; 1722 :                       current);
; 1723 :   }
; 1724 :   return true;
; 1725 : }
; 1726 : 
; 1727 : bool OurReader::decodeUnicodeEscapeSequence(Token& token,
; 1728 :                                          Location& current,
; 1729 :                                          Location end,
; 1730 :                                          unsigned int& ret_unicode) {
; 1731 :   if (end - current < 4)
; 1732 :     return addError(
; 1733 :         "Bad unicode escape sequence in string: four digits expected.",
; 1734 :         token,
; 1735 :         current);
; 1736 :   int unicode = 0;
; 1737 :   for (int index = 0; index < 4; ++index) {
; 1738 :     Char c = *current++;
; 1739 :     unicode *= 16;
; 1740 :     if (c >= '0' && c <= '9')
; 1741 :       unicode += c - '0';
; 1742 :     else if (c >= 'a' && c <= 'f')
; 1743 :       unicode += c - 'a' + 10;
; 1744 :     else if (c >= 'A' && c <= 'F')
; 1745 :       unicode += c - 'A' + 10;
; 1746 :     else
; 1747 :       return addError(
; 1748 :           "Bad unicode escape sequence in string: hexadecimal digit expected.",
; 1749 :           token,
; 1750 :           current);
; 1751 :   }
; 1752 :   ret_unicode = static_cast<unsigned int>(unicode);
; 1753 :   return true;
; 1754 : }
; 1755 : 
; 1756 : bool
; 1757 : OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
; 1758 :   ErrorInfo info;
; 1759 :   info.token_ = token;
; 1760 :   info.message_ = message;
; 1761 :   info.extra_ = extra;
; 1762 :   errors_.push_back(info);
; 1763 :   return false;
; 1764 : }
; 1765 : 
; 1766 : bool OurReader::recoverFromError(TokenType skipUntilToken) {
; 1767 :   size_t errorCount = errors_.size();
; 1768 :   Token skip;
; 1769 :   for (;;) {
; 1770 :     if (!readToken(skip))
; 1771 :       errors_.resize(errorCount); // discard errors caused by recovery
; 1772 :     if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
; 1773 :       break;
; 1774 :   }
; 1775 :   errors_.resize(errorCount);
; 1776 :   return false;
; 1777 : }
; 1778 : 
; 1779 : bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
; 1780 :                                 Token& token,
; 1781 :                                 TokenType skipUntilToken) {
; 1782 :   addError(message, token);
; 1783 :   return recoverFromError(skipUntilToken);
; 1784 : }
; 1785 : 
; 1786 : Value& OurReader::currentValue() { return *(nodes_.top()); }
; 1787 : 
; 1788 : OurReader::Char OurReader::getNextChar() {
; 1789 :   if (current_ == end_)
; 1790 :     return 0;
; 1791 :   return *current_++;
; 1792 : }
; 1793 : 
; 1794 : void OurReader::getLocationLineAndColumn(Location location,
; 1795 :                                       int& line,
; 1796 :                                       int& column) const {
; 1797 :   Location current = begin_;
; 1798 :   Location lastLineStart = current;
; 1799 :   line = 0;
; 1800 :   while (current < location && current != end_) {
; 1801 :     Char c = *current++;
; 1802 :     if (c == '\r') {
; 1803 :       if (*current == '\n')
; 1804 :         ++current;
; 1805 :       lastLineStart = current;
; 1806 :       ++line;
; 1807 :     } else if (c == '\n') {
; 1808 :       lastLineStart = current;
; 1809 :       ++line;
; 1810 :     }
; 1811 :   }
; 1812 :   // column & line start at 1
; 1813 :   column = int(location - lastLineStart) + 1;
; 1814 :   ++line;
; 1815 : }
; 1816 : 
; 1817 : JSONCPP_STRING OurReader::getLocationLineAndColumn(Location location) const {
; 1818 :   int line, column;
; 1819 :   getLocationLineAndColumn(location, line, column);
; 1820 :   char buffer[18 + 16 + 16 + 1];
; 1821 :   snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
; 1822 :   return buffer;
; 1823 : }
; 1824 : 
; 1825 : JSONCPP_STRING OurReader::getFormattedErrorMessages() const {
; 1826 :   JSONCPP_STRING formattedMessage;
; 1827 :   for (Errors::const_iterator itError = errors_.begin();
; 1828 :        itError != errors_.end();
; 1829 :        ++itError) {
; 1830 :     const ErrorInfo& error = *itError;
; 1831 :     formattedMessage +=
; 1832 :         "* " + getLocationLineAndColumn(error.token_.start_) + "\n";
; 1833 :     formattedMessage += "  " + error.message_ + "\n";
; 1834 :     if (error.extra_)
; 1835 :       formattedMessage +=
; 1836 :           "See " + getLocationLineAndColumn(error.extra_) + " for detail.\n";
; 1837 :   }
; 1838 :   return formattedMessage;
; 1839 : }
; 1840 : 
; 1841 : std::vector<OurReader::StructuredError> OurReader::getStructuredErrors() const {
; 1842 :   std::vector<OurReader::StructuredError> allErrors;
; 1843 :   for (Errors::const_iterator itError = errors_.begin();
; 1844 :        itError != errors_.end();
; 1845 :        ++itError) {
; 1846 :     const ErrorInfo& error = *itError;
; 1847 :     OurReader::StructuredError structured;
; 1848 :     structured.offset_start = error.token_.start_ - begin_;
; 1849 :     structured.offset_limit = error.token_.end_ - begin_;
; 1850 :     structured.message = error.message_;
; 1851 :     allErrors.push_back(structured);
; 1852 :   }
; 1853 :   return allErrors;
; 1854 : }
; 1855 : 
; 1856 : bool OurReader::pushError(const Value& value, const JSONCPP_STRING& message) {
; 1857 :   ptrdiff_t length = end_ - begin_;
; 1858 :   if(value.getOffsetStart() > length
; 1859 :     || value.getOffsetLimit() > length)
; 1860 :     return false;
; 1861 :   Token token;
; 1862 :   token.type_ = tokenError;
; 1863 :   token.start_ = begin_ + value.getOffsetStart();
; 1864 :   token.end_ = end_ + value.getOffsetLimit();
; 1865 :   ErrorInfo info;
; 1866 :   info.token_ = token;
; 1867 :   info.message_ = message;
; 1868 :   info.extra_ = 0;
; 1869 :   errors_.push_back(info);
; 1870 :   return true;
; 1871 : }
; 1872 : 
; 1873 : bool OurReader::pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra) {
; 1874 :   ptrdiff_t length = end_ - begin_;
; 1875 :   if(value.getOffsetStart() > length
; 1876 :     || value.getOffsetLimit() > length
; 1877 :     || extra.getOffsetLimit() > length)
; 1878 :     return false;
; 1879 :   Token token;
; 1880 :   token.type_ = tokenError;
; 1881 :   token.start_ = begin_ + value.getOffsetStart();
; 1882 :   token.end_ = begin_ + value.getOffsetLimit();
; 1883 :   ErrorInfo info;
; 1884 :   info.token_ = token;
; 1885 :   info.message_ = message;
; 1886 :   info.extra_ = begin_ + extra.getOffsetStart();
; 1887 :   errors_.push_back(info);
; 1888 :   return true;
; 1889 : }
; 1890 : 
; 1891 : bool OurReader::good() const {
; 1892 :   return !errors_.size();
; 1893 : }
; 1894 : 
; 1895 : 
; 1896 : class OurCharReader : public CharReader {
; 1897 :   bool const collectComments_;
; 1898 :   OurReader reader_;
; 1899 : public:
; 1900 :   OurCharReader(
; 1901 :     bool collectComments,
; 1902 :     OurFeatures const& features)
; 1903 :   : collectComments_(collectComments)
; 1904 :   , reader_(features)
; 1905 :   {}

	lea	rax, OFFSET FLAT:??_7OurCharReader@Json@@6B@
	mov	QWORD PTR [rbx], rax
	mov	BYTE PTR [rbx+8], sil
	lea	rcx, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR features$[rsp]
	call	??0OurReader@Json@@QEAA@AEBVOurFeatures@1@@Z ; Json::OurReader::OurReader
	npad	1

; 1936 :   return new OurCharReader(collectComments, features);

	mov	rax, rbx
	jmp	SHORT $LN4@newCharRea
$LN3@newCharRea:
	mov	rax, rbp
$LN4@newCharRea:

; 1937 : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ ENDP ; Json::CharReaderBuilder::newCharReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$1@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$1
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$1@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$7@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$7
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$7@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$13@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$13
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$13@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$19@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$19
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$19@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$25@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$25
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$25@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$31@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$31
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$31@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$31
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$37@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$37
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$37@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$37
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$43@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$43
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$43@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$43
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$49@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$49
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$49@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$49
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$55@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$55
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$55@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$55
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$0@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$0
	mov	rcx, QWORD PTR $T3[rdx]
	rex_jmp	QWORD PTR __imp_??3@YAXPEAX@Z
?dtor$0@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
features$ = 40
$T3 = 80
this$ = 80
?dtor$61@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA PROC ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$61
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1CharReader@Json@@UEAA@XZ		; Json::CharReader::~CharReader
?dtor$61@?0??newCharReader@CharReaderBuilder@Json@@UEBAPEAVCharReader@2@XZ@4HA ENDP ; `Json::CharReaderBuilder::newCharReader'::`1'::dtor$61
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rbx, QWORD PTR [rcx+136]
	mov	rcx, rbx
	call	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	rex_jmp	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD0@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 859  : 		{	// construct from [_First, _Last), const pointers

$LN42:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], 0

; 859  : 		{	// construct from [_First, _Last), const pointers

	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 862  : 		if (_First != _Last)

	cmp	rdx, r8
	je	SHORT $LN40@basic_stri

; 863  : 			assign(&*_First, _Last - _First);

	sub	r8, rdx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN40@basic_stri:

; 864  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT

; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)

	mov	rax, QWORD PTR [rcx+16]
	cmp	rdx, rax
	ja	SHORT $LN4@resize

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+24], 16

; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN12@resize
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR [rcx]
$LN12@resize:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx+rdx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1766 : 		}

	ret	0
$LN4@resize:

; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

	sub	rdx, rax
	xor	r8d, r8d
	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ??0?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ PROC ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >, COMDAT

; 28   : 		{	// construct with empty container

$LN53:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	eax, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack

; 28   : 		{	// construct with empty container

	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rax

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rax

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rax

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	lea	ecx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN22@stack

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN22@stack:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack

; 29   : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN52@stack:
??0?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ?push@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z PROC ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::push, COMDAT

; 108  : 		c.push_back(_STD move(_Val));

	jmp	?push_back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::push_back
?push@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z ENDP ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::push
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ?empty@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEBA_NXZ PROC ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::empty, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1362 : 		return (this->_Mysize == 0);

	xor	eax, eax
	cmp	QWORD PTR [rcx+32], rax
	sete	al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack

; 121  : 		}

	ret	0
?empty@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEBA_NXZ ENDP ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ?size@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::size, COMDAT

; 125  : 		return (c.size());

	mov	rax, QWORD PTR [rcx+32]

; 126  : 		}

	ret	0
?size@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ?top@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 56
this$ = 96
?top@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ PROC ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::top, COMDAT

; 129  : 		{	// return last element of mutable stack

$LN16:
	sub	rsp, 88					; 00000058H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T1[rsp]
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	je	SHORT $LN12@top
	mov	r8, QWORD PTR [r8]
$LN12@top:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [r8+16]
	dec	rax
	mov	rcx, rdx
	shr	rcx, 1
	and	rcx, rax

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	and	edx, 1
	mov	rax, QWORD PTR [rax+rcx*8]
	lea	rax, QWORD PTR [rax+rdx*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack

; 131  : 		}

	add	rsp, 88					; 00000058H
	ret	0
?top@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ ENDP ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::top
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack
;	COMDAT ?pop@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAXXZ PROC ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::pop, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1491 : 		if (--this->_Mysize == 0)

	dec	QWORD PTR [rcx+32]
	jne	SHORT $LN3@pop

; 1492 : 			this->_Myoff = 0;

	mov	QWORD PTR [rcx+24], 0
$LN3@pop:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\stack

; 146  : 		}

	ret	0
?pop@?$stack@PEAVValue@Json@@V?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::stack<Json::Value * __ptr64,std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::pop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAA@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT

; 951  : 		{	// construct empty deque

$LN49:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	eax, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 951  : 		{	// construct empty deque

	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rax

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rax

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rax

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	lea	ecx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN19@deque

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN19@deque:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx

; 952  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN48@deque:
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAA@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize, COMDAT

; 1334 : 		{	// determine new length, padding as needed

$LN65:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rbx, rcx

; 1335 : 		while (this->_Mysize < _Newsize)

	cmp	QWORD PTR [rcx+32], rdx
	jae	SHORT $LN58@resize
$LL4@resize:

; 1336 : 			emplace_back();

	mov	rcx, rbx
	call	??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>
	cmp	QWORD PTR [rbx+32], rsi
	jb	SHORT $LL4@resize
$LN58@resize:

; 1337 : 
; 1338 : 		while (_Newsize < this->_Mysize)

	cmp	rsi, QWORD PTR [rbx+32]
	jae	SHORT $LN1@resize
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], rdi
	xor	ebp, ebp
	npad	10
$LL2@resize:

; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);
; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	rdx, QWORD PTR [rbx+24]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rax, QWORD PTR [rbx+16]

; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);
; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	dec	rdx

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	dec	rax

; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);
; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	add	rdx, QWORD PTR [rbx+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	and	rdx, rax

; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);
; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	rax, QWORD PTR [rbx+8]
	mov	rdi, QWORD PTR [rax+rdx*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rdi+48], 16
	jb	SHORT $LN45@resize
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdi+24]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN45@resize:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+40], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi+24], bpl
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1491 : 		if (--this->_Mysize == 0)

	dec	QWORD PTR [rbx+32]
	jne	SHORT $LN7@resize

; 1492 : 			this->_Myoff = 0;

	mov	QWORD PTR [rbx+24], rbp
$LN7@resize:

; 1337 : 
; 1338 : 		while (_Newsize < this->_Mysize)

	cmp	rsi, QWORD PTR [rbx+32]
	jb	SHORT $LL2@resize
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+48]
$LN1@resize:

; 1339 : 			pop_back();
; 1340 : 		}

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAX_K@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size, COMDAT

; 1352 : 		return (this->_Mysize);

	mov	rax, QWORD PTR [rcx+32]

; 1353 : 		}

	ret	0
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
$T1 = 32
_Ptr$ = 64
this$ = 64
_Val$ = 72
$T2 = 80
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back, COMDAT

; 1462 : 		{	// insert element at end

$LN87:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+88], rsi
	mov	rsi, rdx
	mov	rbx, rcx

; 1464 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rcx+32]
	inc	rax
	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN2@push_back
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@push_back:
	mov	r8, QWORD PTR [rbx+16]
	dec	r8
	and	QWORD PTR [rbx+24], r8
	mov	rdx, QWORD PTR [rbx+24]
	add	rdx, QWORD PTR [rbx+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	and	r8, rdx

; 1464 : 		_PUSH_BACK_BEGIN;

	lea	rdi, QWORD PTR [r8*8]
	mov	rax, QWORD PTR [rbx+8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN1@push_back
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	rcx, rax
	test	rax, rax
	jne	SHORT $LN16@push_back

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN16@push_back:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1464 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rax], rcx
$LN1@push_back:

; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	rax, QWORD PTR [rbx+8]
	mov	rdi, QWORD PTR [rdi+rax]
	mov	QWORD PTR _Ptr$[rsp], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	QWORD PTR $T2[rsp], rdi
	test	rdi, rdi
	je	SHORT $LN36@push_back
	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rdi], xmm0
	movsdx	xmm1, QWORD PTR [rsi+16]
	movsdx	QWORD PTR [rdi+16], xmm1
	lea	rcx, QWORD PTR [rdi+24]
	mov	QWORD PTR [rcx+24], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
	lea	rdx, QWORD PTR [rsi+24]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	rax, QWORD PTR [rsi+56]
	mov	QWORD PTR [rdi+56], rax
$LN36@push_back:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1467 : 		_PUSH_BACK_END;

	inc	QWORD PTR [rbx+32]

; 1468 : 		}

	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN86@push_back:
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Ptr$ = 64
this$ = 64
_Val$ = 72
$T2 = 80
?dtor$0@?0??push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z@4HA PROC ; `std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@Reader@Json@@@Z@4HA ENDP ; `std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear, COMDAT

; 1643 : 		_Tidy();

	jmp	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >, COMDAT

; 951  : 		{	// construct empty deque

$LN49:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	eax, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 951  : 		{	// construct empty deque

	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rax

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rax

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rax

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	lea	ecx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN19@deque

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN19@deque:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx

; 952  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN48@deque:
??0?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??1?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::~deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >, COMDAT

; 1214 : 		{	// destroy the deque

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1215 : 		_Tidy();

	call	?_Tidy@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAXXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Tidy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 907  : 		this->_Myproxy = 0;

	mov	QWORD PTR [rbx], 0

; 1216 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::~deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?begin@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::begin, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [rcx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1256 : 		return (const_iterator(this->_Myoff, this));

	mov	r8, QWORD PTR [rcx+24]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 114  : 		{	// construct orphaned iterator

	mov	QWORD PTR [rdx+8], 0

; 171  : 			_Myproxy = _Parent_proxy;

	mov	QWORD PTR [rdx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 305  : 		_Myoff = _Off;

	mov	QWORD PTR [rdx+16], r8

; 1256 : 		return (const_iterator(this->_Myoff, this));

	mov	rax, rdx

; 1257 : 		}

	ret	0
?begin@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?end@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::end, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [rcx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1266 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));

	mov	r8, QWORD PTR [rcx+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 114  : 		{	// construct orphaned iterator

	mov	QWORD PTR [rdx+8], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1266 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));

	add	r8, QWORD PTR [rcx+24]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 171  : 			_Myproxy = _Parent_proxy;

	mov	QWORD PTR [rdx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1266 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));

	mov	rax, rdx

; 305  : 		_Myoff = _Off;

	mov	QWORD PTR [rdx+16], r8

; 1267 : 		}

	ret	0
?end@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize, COMDAT

; 1334 : 		{	// determine new length, padding as needed

$LN65:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rbx, rcx

; 1335 : 		while (this->_Mysize < _Newsize)

	cmp	QWORD PTR [rcx+32], rdx
	jae	SHORT $LN58@resize
$LL4@resize:

; 1336 : 			emplace_back();

	mov	rcx, rbx
	call	??$emplace_back@$$$V@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::emplace_back<>
	cmp	QWORD PTR [rbx+32], rsi
	jb	SHORT $LL4@resize
$LN58@resize:

; 1337 : 
; 1338 : 		while (_Newsize < this->_Mysize)

	cmp	rsi, QWORD PTR [rbx+32]
	jae	SHORT $LN1@resize
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], rdi
	xor	ebp, ebp
	npad	10
$LL2@resize:

; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);
; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	rdx, QWORD PTR [rbx+24]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rax, QWORD PTR [rbx+16]

; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);
; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	dec	rdx

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	dec	rax

; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);
; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	add	rdx, QWORD PTR [rbx+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	and	rdx, rax

; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);
; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	rax, QWORD PTR [rbx+8]
	mov	rdi, QWORD PTR [rax+rdx*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rdi+48], 16
	jb	SHORT $LN45@resize
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdi+24]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN45@resize:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+40], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi+24], bpl
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1491 : 		if (--this->_Mysize == 0)

	dec	QWORD PTR [rbx+32]
	jne	SHORT $LN7@resize

; 1492 : 			this->_Myoff = 0;

	mov	QWORD PTR [rbx+24], rbp
$LN7@resize:

; 1337 : 
; 1338 : 		while (_Newsize < this->_Mysize)

	cmp	rsi, QWORD PTR [rbx+32]
	jb	SHORT $LL2@resize
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+48]
$LN1@resize:

; 1339 : 			pop_back();
; 1340 : 		}

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?resize@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAX_K@Z ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?size@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::size, COMDAT

; 1352 : 		return (this->_Mysize);

	mov	rax, QWORD PTR [rcx+32]

; 1353 : 		}

	ret	0
?size@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z
_TEXT	SEGMENT
$T1 = 32
_Ptr$ = 64
this$ = 64
_Val$ = 72
$T2 = 80
?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back, COMDAT

; 1462 : 		{	// insert element at end

$LN87:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+88], rsi
	mov	rsi, rdx
	mov	rbx, rcx

; 1464 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rcx+32]
	inc	rax
	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN2@push_back
	call	?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Growmap
$LN2@push_back:
	mov	r8, QWORD PTR [rbx+16]
	dec	r8
	and	QWORD PTR [rbx+24], r8
	mov	rdx, QWORD PTR [rbx+24]
	add	rdx, QWORD PTR [rbx+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	and	r8, rdx

; 1464 : 		_PUSH_BACK_BEGIN;

	lea	rdi, QWORD PTR [r8*8]
	mov	rax, QWORD PTR [rbx+8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN1@push_back
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	rcx, rax
	test	rax, rax
	jne	SHORT $LN16@push_back

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN16@push_back:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1464 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rax], rcx
$LN1@push_back:

; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	rax, QWORD PTR [rbx+8]
	mov	rdi, QWORD PTR [rdi+rax]
	mov	QWORD PTR _Ptr$[rsp], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	QWORD PTR $T2[rsp], rdi
	test	rdi, rdi
	je	SHORT $LN36@push_back
	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rdi], xmm0
	movsdx	xmm1, QWORD PTR [rsi+16]
	movsdx	QWORD PTR [rdi+16], xmm1
	lea	rcx, QWORD PTR [rdi+24]
	mov	QWORD PTR [rcx+24], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
	lea	rdx, QWORD PTR [rsi+24]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	rax, QWORD PTR [rsi+56]
	mov	QWORD PTR [rdi+56], rax
$LN36@push_back:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1467 : 		_PUSH_BACK_END;

	inc	QWORD PTR [rbx+32]

; 1468 : 		}

	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN86@push_back:
?push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Ptr$ = 64
this$ = 64
_Val$ = 72
$T2 = 80
?dtor$0@?0??push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z@4HA PROC ; `std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??push_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXAEBVErrorInfo@OurReader@Json@@@Z@4HA ENDP ; `std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::push_back'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?clear@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::clear, COMDAT

; 1643 : 		_Tidy();

	jmp	?_Tidy@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAXXZ ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Tidy
?clear@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBAAEBVErrorInfo@OurReader@Json@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBAAEBVErrorInfo@OurReader@Json@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator*, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rax, QWORD PTR [rcx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 322  : 		{	// return designated object

	mov	rdx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	rax, rax
	jne	SHORT $LN5@operator
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rcx, QWORD PTR [rax+16]

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 331  : 		_SCL_SECURE_OUT_OF_RANGE;
; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [rax+8]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	dec	rcx
	and	rcx, QWORD PTR [rdx+16]

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 331  : 		_SCL_SECURE_OUT_OF_RANGE;
; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [rax+rcx*8]

; 345  : 		}

	ret	0
$LN5@operator:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rax, QWORD PTR [rax]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rcx, QWORD PTR [rax+16]

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 331  : 		_SCL_SECURE_OUT_OF_RANGE;
; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [rax+8]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	dec	rcx
	and	rcx, QWORD PTR [rdx+16]

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 331  : 		_SCL_SECURE_OUT_OF_RANGE;
; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [rax+rcx*8]

; 345  : 		}

	ret	0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBAAEBVErrorInfo@OurReader@Json@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator++, COMDAT

; 354  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 355  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 356  : 		if (_Mycont == 0
; 357  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 358  : 		{	// report error
; 359  : 		_DEBUG_ERROR("deque iterator not incrementable");
; 360  : 		_SCL_SECURE_OUT_OF_RANGE;
; 361  : 		}
; 362  : 
; 363  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 364  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 365  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 366  : 		_SCL_SECURE_VALIDATE_RANGE(
; 367  : 			this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 368  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 369  : 
; 370  : 		++_Myoff;

	inc	QWORD PTR [rcx+16]

; 371  : 		return (*this);

	mov	rax, rcx

; 372  : 		}

	ret	0
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator!=, COMDAT

; 465  : 		return (this->_Myoff == _Right._Myoff);

	mov	rdx, QWORD PTR [rdx+16]
	cmp	QWORD PTR [rcx+16], rdx

; 470  : 		return (!(*this == _Right));

	setne	al

; 471  : 		}

	ret	0
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
;	COMDAT ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 40
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T2 = 80
??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 492  : 		{	// construct empty writable character buffer

$LN51:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	rdi, rcx
	mov	DWORD PTR $T2[rsp], 0
	lea	rax, OFFSET FLAT:??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	mov	QWORD PTR [rcx], rax
	add	rcx, 136				; 00000088H
	call	QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	mov	DWORD PTR $T2[rsp], 1
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, QWORD PTR [rdi+8]
	mov	rcx, rdi
	call	QWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	npad	1
	mov	rax, QWORD PTR [rdi]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rcx+rdi], rax
	mov	rax, QWORD PTR [rdi]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-136]
	mov	DWORD PTR [rcx+rdi-4], edx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

	lea	rcx, QWORD PTR [rdi+8]
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rdi+8], rax

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode
; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}
; 33   : 
; 34   : 	explicit basic_stringbuf(const _Mystr& _Str,
; 35   : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 36   : 		{	// construct character buffer from string, mode
; 37   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
; 38   : 		}
; 39   : 
; 40   : 	basic_stringbuf(_Myt&& _Right)
; 41   : 		{	// construct by moving _Right
; 42   : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 43   : 		}
; 44   : 
; 45   : 	_Myt& operator=(_Myt&& _Right)
; 46   : 		{	// assign from _Right
; 47   : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 48   : 		return (*this);
; 49   : 		}
; 50   : 
; 51   : 	void _Assign_rv(_Myt&& _Right)
; 52   : 		{	// assign by moving _Right
; 53   : 		if (this != &_Right)
; 54   : 			{	// different, worth moving
; 55   : 			_Tidy();
; 56   : 			this->swap(_Right);
; 57   : 			}
; 58   : 		}
; 59   : 
; 60   : 	void swap(_Myt& _Right)
; 61   : 		{	// swap with _Right
; 62   : 		if (this != &_Right)
; 63   : 			{	// different, worth swapping
; 64   : 			_Mysb::swap(_Right);
; 65   : 			_STD swap(_Seekhigh, _Right._Seekhigh);
; 66   : 			_STD swap(_Mystate, _Right._Mystate);
; 67   : 			_Swap_adl(_Al, _Right._Al);
; 68   : 			}
; 69   : 		}
; 70   : 
; 71   : 	basic_stringbuf(const _Myt&) = delete;
; 72   : 	_Myt& operator=(const _Myt&) = delete;
; 73   : 
; 74   : 	virtual ~basic_stringbuf() _NOEXCEPT
; 75   : 		{	// destroy the object
; 76   : 		_Tidy();
; 77   : 		}
; 78   : 
; 79   : 	enum
; 80   : 		{	// constants for bits in stream state
; 81   : 		_Allocated = 1,	// set if character array storage has been allocated
; 82   : 		_Constant = 2,	// set if character array nonmutable
; 83   : 		_Noread = 4,	// set if character array cannot be read
; 84   : 		_Append = 8,	// set if all writes are appends
; 85   : 		_Atend = 16};	// set if initial writes are appends
; 86   : 	typedef int _Strstate;
; 87   : 
; 88   : 	typedef typename _Traits::int_type int_type;
; 89   : 	typedef typename _Traits::pos_type pos_type;
; 90   : 	typedef typename _Traits::off_type off_type;
; 91   : 
; 92   : 	_Mystr str() const
; 93   : 		{	// return string copy of character array
; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)
; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);
; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)
; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());
; 103  : 			return (_Str);
; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;
; 108  : 			return (_Nul);
; 109  : 			}
; 110  : 		}
; 111  : 
; 112  : 	void str(const _Mystr& _Newstr)
; 113  : 		{	// replace character array from string
; 114  : 		_Tidy();
; 115  : 		_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
; 116  : 		}
; 117  : 
; 118  : protected:
; 119  : 	virtual int_type overflow(int_type _Meta = _Traits::eof())
; 120  : 		{	// put an element to stream
; 121  : 		if (_Mystate & _Constant)
; 122  : 			return (_Traits::eof());	// array nonmutable, fail
; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))
; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code
; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)
; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());
; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())
; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 134  : 			return (_Meta);
; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0
; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE
; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)
; 145  : 				_Inc /= 2;	// increment causes overflow, halve it
; 146  : 			if (_Inc == 0)
; 147  : 				return (_Traits::eof());	// buffer can't grow, fail
; 148  : 
; 149  : 			_Newsize += _Inc;
; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);
; 152  : 			_Elem *_Oldptr = _Mysb::eback();
; 153  : 
; 154  : 			if (0 < _Oldsize)
; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);
; 156  : 
; 157  : 			if (_Oldsize == 0)
; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);
; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 163  : 				else
; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);
; 165  : 				}
; 166  : 			else
; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)
; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 174  : 				else
; 175  : 					_Mysb::setg(_Newptr,
; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)
; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);
; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}
; 188  : 
; 189  : 	virtual int_type pbackfail(int_type _Meta = _Traits::eof())
; 190  : 		{	// put an element back to stream
; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)
; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail
; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);
; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);
; 202  : 			return (_Traits::not_eof(_Meta));
; 203  : 			}
; 204  : 		}
; 205  : 
; 206  : 	virtual int_type underflow()
; 207  : 		{	// get an element from stream, but don't point past it
; 208  : 		if (_Mysb::gptr() == 0)
; 209  : 			return (_Traits::eof());	// no character buffer, fail
; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())
; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered
; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))
; 214  : 			return (_Traits::eof());	// can't read, fail
; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())
; 218  : 				_Seekhigh = _Mysb::pptr();
; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));
; 221  : 			}
; 222  : 		}
; 223  : 
; 224  : 	virtual pos_type seekoff(off_type _Off,
; 225  : 		ios_base::seekdir _Way,
; 226  : 		ios_base::openmode _Which = ios_base::in | ios_base::out)
; 227  : 		{	// change position by _Off, according to _Way, _Mode
; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)
; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)
; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 235  : 			else if (_Way == ios_base::cur
; 236  : 				&& (_Which & ios_base::out) == 0)
; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());
; 238  : 			else if (_Way != ios_base::beg)
; 239  : 				_Off = _BADOFF;
; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else
; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)
; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 255  : 			else if (_Way == ios_base::cur)
; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());
; 257  : 			else if (_Way != ios_base::beg)
; 258  : 				_Off = _BADOFF;
; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 261  : 				_Mysb::pbump((int)(_Mysb::eback()
; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else
; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)
; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 271  : 		return (pos_type(_Off));
; 272  : 		}
; 273  : 
; 274  : 	virtual pos_type seekpos(pos_type _Ptr,
; 275  : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 276  : 		{	// change position to _Pos, according to _Mode
; 277  : 		streamoff _Off = (streamoff)_Ptr;
; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 280  : 
; 281  : 		if (_Off == _BADOFF)
; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)
; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else
; 293  : 				_Off = _BADOFF;
; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 298  : 				_Mysb::pbump((int)(_Mysb::eback()
; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else
; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 305  : 		return (streampos(_Off));
; 306  : 		}
; 307  : 
; 308  : 	void _Init(const _Elem *_Ptr,
; 309  : 		size_t _Count, _Strstate _State)
; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state
; 311  : 		_Seekhigh = 0;

	mov	QWORD PTR [rdi+112], 0

; 312  : 		_Mystate = _State;

	mov	DWORD PTR [rdi+120], 4

; 493  : 		}

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 40
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T2 = 80
?dtor$0@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 136				; 00000088H
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 40
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T2 = 80
?dtor$1@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 16
	rex_jmp	QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 40
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T2 = 80
?dtor$3@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
;	COMDAT ??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 536  : 		{	// destroy the object

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rcx-136]
	mov	rdi, rcx
	movsxd	rdx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rdx+rcx-136], rax
	mov	rax, QWORD PTR [rcx-136]
	movsxd	rdx, DWORD PTR [rax+4]

; 75   : 		{	// destroy the object

	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 536  : 		{	// destroy the object

	lea	r8d, DWORD PTR [rdx-136]
	mov	DWORD PTR [rdx+rcx-140], r8d

; 78   : 
; 79   : 	enum
; 80   : 		{	// constants for bits in stream state
; 81   : 		_Allocated = 1,	// set if character array storage has been allocated
; 82   : 		_Constant = 2,	// set if character array nonmutable
; 83   : 		_Noread = 4,	// set if character array cannot be read
; 84   : 		_Append = 8,	// set if all writes are appends
; 85   : 		_Atend = 16};	// set if initial writes are appends
; 86   : 	typedef int _Strstate;
; 87   : 
; 88   : 	typedef typename _Traits::int_type int_type;
; 89   : 	typedef typename _Traits::pos_type pos_type;
; 90   : 	typedef typename _Traits::off_type off_type;
; 91   : 
; 92   : 	_Mystr str() const
; 93   : 		{	// return string copy of character array
; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)
; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);
; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)
; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());
; 103  : 			return (_Str);
; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;
; 108  : 			return (_Nul);
; 109  : 			}
; 110  : 		}
; 111  : 
; 112  : 	void str(const _Mystr& _Newstr)
; 113  : 		{	// replace character array from string
; 114  : 		_Tidy();
; 115  : 		_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
; 116  : 		}
; 117  : 
; 118  : protected:
; 119  : 	virtual int_type overflow(int_type _Meta = _Traits::eof())
; 120  : 		{	// put an element to stream
; 121  : 		if (_Mystate & _Constant)
; 122  : 			return (_Traits::eof());	// array nonmutable, fail
; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))
; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code
; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)
; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());
; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())
; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 134  : 			return (_Meta);
; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0
; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE
; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)
; 145  : 				_Inc /= 2;	// increment causes overflow, halve it
; 146  : 			if (_Inc == 0)
; 147  : 				return (_Traits::eof());	// buffer can't grow, fail
; 148  : 
; 149  : 			_Newsize += _Inc;
; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);
; 152  : 			_Elem *_Oldptr = _Mysb::eback();
; 153  : 
; 154  : 			if (0 < _Oldsize)
; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);
; 156  : 
; 157  : 			if (_Oldsize == 0)
; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);
; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 163  : 				else
; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);
; 165  : 				}
; 166  : 			else
; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)
; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 174  : 				else
; 175  : 					_Mysb::setg(_Newptr,
; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)
; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);
; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}
; 188  : 
; 189  : 	virtual int_type pbackfail(int_type _Meta = _Traits::eof())
; 190  : 		{	// put an element back to stream
; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)
; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail
; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);
; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);
; 202  : 			return (_Traits::not_eof(_Meta));
; 203  : 			}
; 204  : 		}
; 205  : 
; 206  : 	virtual int_type underflow()
; 207  : 		{	// get an element from stream, but don't point past it
; 208  : 		if (_Mysb::gptr() == 0)
; 209  : 			return (_Traits::eof());	// no character buffer, fail
; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())
; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered
; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))
; 214  : 			return (_Traits::eof());	// can't read, fail
; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())
; 218  : 				_Seekhigh = _Mysb::pptr();
; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));
; 221  : 			}
; 222  : 		}
; 223  : 
; 224  : 	virtual pos_type seekoff(off_type _Off,
; 225  : 		ios_base::seekdir _Way,
; 226  : 		ios_base::openmode _Which = ios_base::in | ios_base::out)
; 227  : 		{	// change position by _Off, according to _Way, _Mode
; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)
; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)
; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 235  : 			else if (_Way == ios_base::cur
; 236  : 				&& (_Which & ios_base::out) == 0)
; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());
; 238  : 			else if (_Way != ios_base::beg)
; 239  : 				_Off = _BADOFF;
; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else
; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)
; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 255  : 			else if (_Way == ios_base::cur)
; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());
; 257  : 			else if (_Way != ios_base::beg)
; 258  : 				_Off = _BADOFF;
; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 261  : 				_Mysb::pbump((int)(_Mysb::eback()
; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else
; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)
; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 271  : 		return (pos_type(_Off));
; 272  : 		}
; 273  : 
; 274  : 	virtual pos_type seekpos(pos_type _Ptr,
; 275  : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 276  : 		{	// change position to _Pos, according to _Mode
; 277  : 		streamoff _Off = (streamoff)_Ptr;
; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 280  : 
; 281  : 		if (_Off == _BADOFF)
; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)
; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else
; 293  : 				_Off = _BADOFF;
; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 298  : 				_Mysb::pbump((int)(_Mysb::eback()
; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else
; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 305  : 		return (streampos(_Off));
; 306  : 		}
; 307  : 
; 308  : 	void _Init(const _Elem *_Ptr,
; 309  : 		size_t _Count, _Strstate _State)
; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state
; 311  : 		_Seekhigh = 0;
; 312  : 		_Mystate = _State;
; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)

	test	BYTE PTR [rcx-16], 1

; 75   : 		{	// destroy the object

	mov	QWORD PTR [rcx-128], rax

; 78   : 
; 79   : 	enum
; 80   : 		{	// constants for bits in stream state
; 81   : 		_Allocated = 1,	// set if character array storage has been allocated
; 82   : 		_Constant = 2,	// set if character array nonmutable
; 83   : 		_Noread = 4,	// set if character array cannot be read
; 84   : 		_Append = 8,	// set if all writes are appends
; 85   : 		_Atend = 16};	// set if initial writes are appends
; 86   : 	typedef int _Strstate;
; 87   : 
; 88   : 	typedef typename _Traits::int_type int_type;
; 89   : 	typedef typename _Traits::pos_type pos_type;
; 90   : 	typedef typename _Traits::off_type off_type;
; 91   : 
; 92   : 	_Mystr str() const
; 93   : 		{	// return string copy of character array
; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)
; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);
; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)
; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());
; 103  : 			return (_Str);
; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;
; 108  : 			return (_Nul);
; 109  : 			}
; 110  : 		}
; 111  : 
; 112  : 	void str(const _Mystr& _Newstr)
; 113  : 		{	// replace character array from string
; 114  : 		_Tidy();
; 115  : 		_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
; 116  : 		}
; 117  : 
; 118  : protected:
; 119  : 	virtual int_type overflow(int_type _Meta = _Traits::eof())
; 120  : 		{	// put an element to stream
; 121  : 		if (_Mystate & _Constant)
; 122  : 			return (_Traits::eof());	// array nonmutable, fail
; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))
; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code
; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)
; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());
; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())
; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 134  : 			return (_Meta);
; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0
; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE
; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)
; 145  : 				_Inc /= 2;	// increment causes overflow, halve it
; 146  : 			if (_Inc == 0)
; 147  : 				return (_Traits::eof());	// buffer can't grow, fail
; 148  : 
; 149  : 			_Newsize += _Inc;
; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);
; 152  : 			_Elem *_Oldptr = _Mysb::eback();
; 153  : 
; 154  : 			if (0 < _Oldsize)
; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);
; 156  : 
; 157  : 			if (_Oldsize == 0)
; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);
; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 163  : 				else
; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);
; 165  : 				}
; 166  : 			else
; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)
; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 174  : 				else
; 175  : 					_Mysb::setg(_Newptr,
; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)
; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);
; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}
; 188  : 
; 189  : 	virtual int_type pbackfail(int_type _Meta = _Traits::eof())
; 190  : 		{	// put an element back to stream
; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)
; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail
; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);
; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);
; 202  : 			return (_Traits::not_eof(_Meta));
; 203  : 			}
; 204  : 		}
; 205  : 
; 206  : 	virtual int_type underflow()
; 207  : 		{	// get an element from stream, but don't point past it
; 208  : 		if (_Mysb::gptr() == 0)
; 209  : 			return (_Traits::eof());	// no character buffer, fail
; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())
; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered
; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))
; 214  : 			return (_Traits::eof());	// can't read, fail
; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())
; 218  : 				_Seekhigh = _Mysb::pptr();
; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));
; 221  : 			}
; 222  : 		}
; 223  : 
; 224  : 	virtual pos_type seekoff(off_type _Off,
; 225  : 		ios_base::seekdir _Way,
; 226  : 		ios_base::openmode _Which = ios_base::in | ios_base::out)
; 227  : 		{	// change position by _Off, according to _Way, _Mode
; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)
; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)
; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 235  : 			else if (_Way == ios_base::cur
; 236  : 				&& (_Which & ios_base::out) == 0)
; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());
; 238  : 			else if (_Way != ios_base::beg)
; 239  : 				_Off = _BADOFF;
; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else
; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)
; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 255  : 			else if (_Way == ios_base::cur)
; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());
; 257  : 			else if (_Way != ios_base::beg)
; 258  : 				_Off = _BADOFF;
; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 261  : 				_Mysb::pbump((int)(_Mysb::eback()
; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else
; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)
; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 271  : 		return (pos_type(_Off));
; 272  : 		}
; 273  : 
; 274  : 	virtual pos_type seekpos(pos_type _Ptr,
; 275  : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 276  : 		{	// change position to _Pos, according to _Mode
; 277  : 		streamoff _Off = (streamoff)_Ptr;
; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 280  : 
; 281  : 		if (_Off == _BADOFF)
; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)
; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else
; 293  : 				_Off = _BADOFF;
; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 298  : 				_Mysb::pbump((int)(_Mysb::eback()
; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else
; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 305  : 		return (streampos(_Off));
; 306  : 		}
; 307  : 
; 308  : 	void _Init(const _Elem *_Ptr,
; 309  : 		size_t _Count, _Strstate _State)
; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state
; 311  : 		_Seekhigh = 0;
; 312  : 		_Mystate = _State;
; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)

	je	SHORT $LN20@basic_ostr
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 216  : 		return (*_IGfirst);

	mov	rcx, QWORD PTR [rcx-104]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN20@basic_ostr:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 247  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rdi-104]
	xor	ecx, ecx
	mov	QWORD PTR [rax], rcx

; 248  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rdi-72]
	mov	QWORD PTR [rax], rcx

; 249  : 		*_IGcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR [rdi-48]
	mov	DWORD PTR [rax], ecx

; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);
; 278  : 		}
; 279  : 
; 280  : 	void __CLR_OR_THIS_CALL pbump(int _Off)
; 281  : 		{	// alter current position in write buffer by _Off
; 282  : 		*_IPcount -= _Off;
; 283  : 		*_IPnext += _Off;
; 284  : 		}
; 285  : 
; 286  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Last)
; 287  : 		{	// set pointers for write buffer
; 288  : 		*_IPfirst = _First;

	mov	rax, QWORD PTR [rdi-96]
	mov	QWORD PTR [rax], rcx

; 289  : 		*_IPnext = _First;

	mov	rax, QWORD PTR [rdi-64]
	mov	QWORD PTR [rax], rcx

; 290  : 		*_IPcount = (int)(_Last - _First);

	mov	rax, QWORD PTR [rdi-40]
	mov	DWORD PTR [rax], ecx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

	and	DWORD PTR [rdi-16], -2
	mov	QWORD PTR [rdi-24], rcx

; 76   : 		_Tidy();
; 77   : 		}

	lea	rcx, QWORD PTR [rdi-128]
	call	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ

; 537  : 		}

	lea	rcx, QWORD PTR [rdi-120]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	rex_jmp	QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
;	COMDAT ?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT

; 545  : 		{	// return string copy of character array

$LN6:
	push	rbx
	sub	rsp, 48					; 00000030H

; 546  : 		return (_Stringbuffer.str());

	add	rcx, 8
	mov	rbx, rdx
	mov	DWORD PTR $T1[rsp], 0
	call	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
	mov	rax, rbx

; 547  : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN8:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rsi, QWORD PTR [rcx-136]
	mov	edi, edx
	lea	rcx, QWORD PTR [rsi+136]
	call	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, QWORD PTR [rsi+136]
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
	test	dil, 1
	je	SHORT $LN6@scalar
	mov	rcx, rsi
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN6@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
_Ch$dead$ = 24
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT

; 1770 : 		if (_Newsize <= this->_Mysize)

	mov	rax, QWORD PTR [rcx+16]
	cmp	rdx, rax
	ja	SHORT $LN2@resize

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+24], 16

; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN10@resize
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR [rcx]
$LN10@resize:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx+rdx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1774 : 		}

	ret	0
$LN2@resize:

; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

	sub	rdx, rax
	xor	r8d, r8d
	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA@XZ PROC ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >, COMDAT

; 951  : 		{	// construct empty deque

$LN49:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	eax, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 951  : 		{	// construct empty deque

	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rax

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rax

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rax

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	lea	ecx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN19@deque

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN19@deque:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx

; 952  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN48@deque:
??0?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA@XZ ENDP ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?push_back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z PROC ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::push_back, COMDAT

; 1129 : 		{	// insert element at end

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rcx, QWORD PTR [rcx+32]
	mov	r14, rdx
	movzx	eax, cl
	add	al, BYTE PTR [rbx+24]
	test	al, 1
	jne	SHORT $LN2@push_back
	lea	rax, QWORD PTR [rcx+2]
	shr	rax, 1
	cmp	QWORD PTR [rbx+16], rax
	ja	SHORT $LN2@push_back
	mov	rcx, rbx
	call	?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Growmap
$LN2@push_back:
	mov	rdx, QWORD PTR [rbx+16]
	lea	rax, QWORD PTR [rdx*2-1]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	lea	rcx, QWORD PTR [rdx-1]

; 1131 : 		_PUSH_BACK_BEGIN;

	and	QWORD PTR [rbx+24], rax
	mov	rdi, QWORD PTR [rbx+24]
	add	rdi, QWORD PTR [rbx+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rax, rdi
	shr	rax, 1
	and	rcx, rax

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rbx+8]
	lea	rsi, QWORD PTR [rcx*8]
	cmp	QWORD PTR [rsi+rax], 0
	jne	SHORT $LN1@push_back
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	rcx, rax
	test	rax, rax
	jne	SHORT $LN16@push_back

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN16@push_back:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1131 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rsi+rax], rcx
$LN1@push_back:

; 1132 : 		this->_Getal().construct(
; 1133 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 			_STD forward<value_type>(_Val));

	mov	rax, QWORD PTR [rbx+8]
	and	edi, 1
	mov	rax, QWORD PTR [rax+rsi]
	lea	rcx, QWORD PTR [rax+rdi*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN38@push_back
	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR [rcx], rax
$LN38@push_back:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1135 : 		_PUSH_BACK_END;

	inc	QWORD PTR [rbx+32]

; 1136 : 		}

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN45@push_back:
?push_back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAX$$QEAPEAVValue@Json@@@Z ENDP ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?size@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ PROC ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::size, COMDAT

; 1352 : 		return (this->_Mysize);

	mov	rax, QWORD PTR [rcx+32]

; 1353 : 		}

	ret	0
?size@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ ENDP ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 56
this$ = 96
?back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ PROC ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::back, COMDAT

; 1415 : 		{	// return last element of mutable sequence

$LN14:
	sub	rsp, 88					; 00000058H

; 1416 : 		return (*(end() - 1));

	lea	rdx, QWORD PTR $T1[rsp]
	call	?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	je	SHORT $LN10@back
	mov	r8, QWORD PTR [r8]
$LN10@back:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [r8+16]
	dec	rax
	mov	rcx, rdx
	shr	rcx, 1
	and	rcx, rax

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	and	edx, 1
	mov	rax, QWORD PTR [rax+rcx*8]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1417 : 		}

	add	rsp, 88					; 00000058H
	ret	0
?back@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAAEAPEAVValue@Json@@XZ ENDP ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Count$dead$ = 72
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap, COMDAT

; 1772 : 		{	// grow map by at least _Count pointers, _Mapsize a power of 2

$LN169:
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H

; 1773 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1774 : 			"The _Xlen() test should always be performed.");
; 1775 : 
; 1776 : 		typedef typename _Alpty::pointer _Blockptr;
; 1777 : 		_Alpty _Almap(this->_Getal());
; 1778 : 		size_type _Newsize = 0 < this->_Mapsize ? this->_Mapsize : 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	ebx, 1
	mov	rbp, rcx
	test	rdx, rdx
	mov	rcx, 288230376151711743			; 03ffffffffffffffH
	cmovne	rbx, rdx
$LL7@Growmap:

; 1779 : 		while (_Newsize - this->_Mapsize < _Count || _Newsize < _DEQUEMAPSIZ)

	mov	rax, rbx
	sub	rax, rdx
	cmp	rax, 1
	jb	SHORT $LN5@Growmap
	cmp	rbx, 8
	jae	SHORT $LN6@Growmap
$LN5@Growmap:

; 1780 : 			{	// scale _Newsize to 2^N >= _Mapsize + _Count
; 1781 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

	mov	rax, rcx
	sub	rax, rbx
	cmp	rax, rbx
	jb	$LN151@Growmap

; 1782 : 				_Xlen();	// result too long
; 1783 : 			_Newsize *= 2;

	add	rbx, rbx

; 1784 : 			}

	jmp	SHORT $LL7@Growmap
$LN6@Growmap:

; 1785 : 		_Count = _Newsize - this->_Mapsize;

	sub	rbx, rdx
	mov	QWORD PTR [rsp+88], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

	xor	r14d, r14d
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1788 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize + _Count);

	lea	rcx, QWORD PTR [rdx+rbx]
	mov	QWORD PTR [rsp+32], r15
	mov	r15, QWORD PTR [rbp+24]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

	test	rcx, rcx
	je	SHORT $LN32@Growmap

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN31@Growmap
	lea	rcx, QWORD PTR [rcx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	r14, rax
	test	rax, rax
	jne	SHORT $LN32@Growmap
$LN31@Growmap:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN32@Growmap:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1793 : 			_Myptr, _Almap);	// copy initial to end

	mov	rax, QWORD PTR [rbp+8]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, QWORD PTR [rbp+16]
	lea	rsi, QWORD PTR [r15*8]
	shl	rdi, 3
	lea	rdx, QWORD PTR [rsi+rax]
	lea	rcx, QWORD PTR [rsi+r14]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdi, rdx
	add	rdi, rax
	sar	rdi, 3

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rdi, QWORD PTR [rdi*8]
	mov	r8, rdi
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1798 : 				_Myptr, _Almap);	// copy rest of old

	mov	rdx, QWORD PTR [rbp+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	add	rax, rdi
	mov	rcx, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1794 : 		if (_Myboff <= _Count)

	cmp	r15, rbx
	ja	SHORT $LN3@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sar	rsi, 3
	mov	QWORD PTR [rsp+80], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1800 : 				_Almap);	// clear suffix of new

	mov	r12, rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rsi, QWORD PTR [rsi*8]
	mov	r8, rsi
	call	QWORD PTR __imp_memmove
	add	rax, rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1800 : 				_Almap);	// clear suffix of new

	sub	r12, r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	je	SHORT $LN81@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1798 : 				_Myptr, _Almap);	// copy rest of old

	mov	rdi, rax
	mov	rcx, r12
	xor	eax, eax
	rep stosq
$LN81@Growmap:
	mov	r12, QWORD PTR [rsp+80]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	r15, r15
	je	SHORT $LN139@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	mov	rdi, r14
	mov	rcx, r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1804 : 		else

	jmp	SHORT $LN167@Growmap
$LN3@Growmap:

; 1808 : 				_Myptr, _Almap);	// copy more old

	lea	rdi, QWORD PTR [rbx*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	r8, rdi
	and	r8, -8
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1811 : 				_Newmap, _Almap);	// copy rest of old

	mov	rax, QWORD PTR [rbp+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	rcx, r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1811 : 				_Newmap, _Almap);	// copy rest of old

	lea	rdx, QWORD PTR [rdi+rax]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rsi, rdx
	add	rsi, rax
	sar	rsi, 3

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rsi, QWORD PTR [rsi*8]
	mov	r8, rsi
	call	QWORD PTR __imp_memmove
	add	rax, rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rbx, rbx
	je	SHORT $LN139@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1808 : 				_Myptr, _Almap);	// copy more old

	mov	rdi, rax
	mov	rcx, rbx
$LN167@Growmap:
	xor	eax, eax
	rep stosq
$LN139@Growmap:

; 1812 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1813 : 				_Almap);	// clear rest to initial block
; 1814 : 			}
; 1815 : 
; 1816 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1817 : 			_Almap);
; 1818 : 		if (this->_Map != _Mapptr())

	mov	rcx, QWORD PTR [rbp+8]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	test	rcx, rcx
	je	SHORT $LN144@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN144@Growmap:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1823 : 		this->_Mapsize += _Count;

	add	QWORD PTR [rbp+16], rbx
	mov	r15, QWORD PTR [rsp+32]
	mov	QWORD PTR [rbp+8], r14
	mov	r14, QWORD PTR [rsp+88]

; 1824 : 		}

	add	rsp, 40					; 00000028H
	pop	rbp
	pop	rbx
	ret	0
$LN151@Growmap:

; 1763 : 		_Xlength_error("deque<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN168@Growmap:
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT

; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())

$LN43:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	eax, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())

	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rax

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rax

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rax

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	lea	ecx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN14@Deque_allo

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN14@Deque_allo:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx

; 873  : 		{	// construct allocators from _Al
; 874  : 		_Alloc_proxy();
; 875  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN42@Deque_allo:
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate, COMDAT

; 846  : 		{	// allocate array of _Count elements

$LN16:
	sub	rsp, 40					; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN1@allocate

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN1@allocate:

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN15@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Mode$dead$ = 72
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

$LN43:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rbx], rax

; 33   : 
; 34   : 	explicit basic_stringbuf(const _Mystr& _Str,
; 35   : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 36   : 		{	// construct character buffer from string, mode
; 37   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
; 38   : 		}
; 39   : 
; 40   : 	basic_stringbuf(_Myt&& _Right)
; 41   : 		{	// construct by moving _Right
; 42   : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 43   : 		}
; 44   : 
; 45   : 	_Myt& operator=(_Myt&& _Right)
; 46   : 		{	// assign from _Right
; 47   : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 48   : 		return (*this);
; 49   : 		}
; 50   : 
; 51   : 	void _Assign_rv(_Myt&& _Right)
; 52   : 		{	// assign by moving _Right
; 53   : 		if (this != &_Right)
; 54   : 			{	// different, worth moving
; 55   : 			_Tidy();
; 56   : 			this->swap(_Right);
; 57   : 			}
; 58   : 		}
; 59   : 
; 60   : 	void swap(_Myt& _Right)
; 61   : 		{	// swap with _Right
; 62   : 		if (this != &_Right)
; 63   : 			{	// different, worth swapping
; 64   : 			_Mysb::swap(_Right);
; 65   : 			_STD swap(_Seekhigh, _Right._Seekhigh);
; 66   : 			_STD swap(_Mystate, _Right._Mystate);
; 67   : 			_Swap_adl(_Al, _Right._Al);
; 68   : 			}
; 69   : 		}
; 70   : 
; 71   : 	basic_stringbuf(const _Myt&) = delete;
; 72   : 	_Myt& operator=(const _Myt&) = delete;
; 73   : 
; 74   : 	virtual ~basic_stringbuf() _NOEXCEPT
; 75   : 		{	// destroy the object
; 76   : 		_Tidy();
; 77   : 		}
; 78   : 
; 79   : 	enum
; 80   : 		{	// constants for bits in stream state
; 81   : 		_Allocated = 1,	// set if character array storage has been allocated
; 82   : 		_Constant = 2,	// set if character array nonmutable
; 83   : 		_Noread = 4,	// set if character array cannot be read
; 84   : 		_Append = 8,	// set if all writes are appends
; 85   : 		_Atend = 16};	// set if initial writes are appends
; 86   : 	typedef int _Strstate;
; 87   : 
; 88   : 	typedef typename _Traits::int_type int_type;
; 89   : 	typedef typename _Traits::pos_type pos_type;
; 90   : 	typedef typename _Traits::off_type off_type;
; 91   : 
; 92   : 	_Mystr str() const
; 93   : 		{	// return string copy of character array
; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)
; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);
; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)
; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());
; 103  : 			return (_Str);
; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;
; 108  : 			return (_Nul);
; 109  : 			}
; 110  : 		}
; 111  : 
; 112  : 	void str(const _Mystr& _Newstr)
; 113  : 		{	// replace character array from string
; 114  : 		_Tidy();
; 115  : 		_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
; 116  : 		}
; 117  : 
; 118  : protected:
; 119  : 	virtual int_type overflow(int_type _Meta = _Traits::eof())
; 120  : 		{	// put an element to stream
; 121  : 		if (_Mystate & _Constant)
; 122  : 			return (_Traits::eof());	// array nonmutable, fail
; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))
; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code
; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)
; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());
; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())
; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 134  : 			return (_Meta);
; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0
; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE
; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)
; 145  : 				_Inc /= 2;	// increment causes overflow, halve it
; 146  : 			if (_Inc == 0)
; 147  : 				return (_Traits::eof());	// buffer can't grow, fail
; 148  : 
; 149  : 			_Newsize += _Inc;
; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);
; 152  : 			_Elem *_Oldptr = _Mysb::eback();
; 153  : 
; 154  : 			if (0 < _Oldsize)
; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);
; 156  : 
; 157  : 			if (_Oldsize == 0)
; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);
; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 163  : 				else
; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);
; 165  : 				}
; 166  : 			else
; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)
; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);
; 174  : 				else
; 175  : 					_Mysb::setg(_Newptr,
; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)
; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);
; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}
; 188  : 
; 189  : 	virtual int_type pbackfail(int_type _Meta = _Traits::eof())
; 190  : 		{	// put an element back to stream
; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)
; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail
; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);
; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);
; 202  : 			return (_Traits::not_eof(_Meta));
; 203  : 			}
; 204  : 		}
; 205  : 
; 206  : 	virtual int_type underflow()
; 207  : 		{	// get an element from stream, but don't point past it
; 208  : 		if (_Mysb::gptr() == 0)
; 209  : 			return (_Traits::eof());	// no character buffer, fail
; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())
; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered
; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))
; 214  : 			return (_Traits::eof());	// can't read, fail
; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())
; 218  : 				_Seekhigh = _Mysb::pptr();
; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));
; 221  : 			}
; 222  : 		}
; 223  : 
; 224  : 	virtual pos_type seekoff(off_type _Off,
; 225  : 		ios_base::seekdir _Way,
; 226  : 		ios_base::openmode _Which = ios_base::in | ios_base::out)
; 227  : 		{	// change position by _Off, according to _Way, _Mode
; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)
; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)
; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 235  : 			else if (_Way == ios_base::cur
; 236  : 				&& (_Which & ios_base::out) == 0)
; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());
; 238  : 			else if (_Way != ios_base::beg)
; 239  : 				_Off = _BADOFF;
; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else
; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)
; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)
; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());
; 255  : 			else if (_Way == ios_base::cur)
; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());
; 257  : 			else if (_Way != ios_base::beg)
; 258  : 				_Off = _BADOFF;
; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 261  : 				_Mysb::pbump((int)(_Mysb::eback()
; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else
; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)
; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 271  : 		return (pos_type(_Off));
; 272  : 		}
; 273  : 
; 274  : 	virtual pos_type seekpos(pos_type _Ptr,
; 275  : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 276  : 		{	// change position to _Pos, according to _Mode
; 277  : 		streamoff _Off = (streamoff)_Ptr;
; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer
; 280  : 
; 281  : 		if (_Off == _BADOFF)
; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)
; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else
; 293  : 				_Off = _BADOFF;
; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)
; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
; 298  : 				_Mysb::pbump((int)(_Mysb::eback()
; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else
; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail
; 305  : 		return (streampos(_Off));
; 306  : 		}
; 307  : 
; 308  : 	void _Init(const _Elem *_Ptr,
; 309  : 		size_t _Count, _Strstate _State)
; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state
; 311  : 		_Seekhigh = 0;

	mov	QWORD PTR [rbx+104], 0

; 312  : 		_Mystate = _State;

	mov	DWORD PTR [rbx+112], 4

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode
; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}

	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Mode$dead$ = 72
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
_Nul$2 = 40
_Str$3 = 40
_Str$4 = 40
__$ArrayPad$ = 72
this$ = 96
__$ReturnUdt$ = 104
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT

; 93   : 		{	// return string copy of character array

$LN533:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-80], rax
	xor	edi, edi
	mov	rbx, rdx

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

	mov	edx, DWORD PTR [rcx+112]
	mov	DWORD PTR $T1[rbp-80], edi
	test	dl, 2
	jne	$LN4@str
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 231  : 		return (*_IPnext);

	mov	rax, QWORD PTR [rcx+64]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

	mov	r9, QWORD PTR [rax]
	test	r9, r9
	je	$LN4@str

; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());

	mov	r8, QWORD PTR [rcx+104]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 226  : 		return (*_IPfirst);

	mov	rax, QWORD PTR [rcx+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 768  : 		assign(_Ptr, _Count);

	lea	rcx, QWORD PTR _Str$4[rbp-80]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 226  : 		return (*_IPfirst);

	mov	rdx, QWORD PTR [rax]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());

	cmp	r8, r9
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR _Str$4[rbp-56], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());

	cmovb	r8, r9
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR _Str$4[rbp-64], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR _Str$4[rbp-80], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());

	sub	r8, rdx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 768  : 		assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	mov	rdx, QWORD PTR _Str$4[rbp-56]
	cmp	rdx, 16
	jae	SHORT $LN103@str

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	r8, QWORD PTR _Str$4[rbp-64]
	inc	r8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN102@str
	lea	rdx, QWORD PTR _Str$4[rbp-80]
	mov	rcx, rbx
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

	mov	rdx, QWORD PTR _Str$4[rbp-56]

; 944  : 		this->_Mysize = _Right._Mysize;

	mov	rcx, QWORD PTR _Str$4[rbp-64]
	mov	QWORD PTR [rbx+16], rcx

; 945  : 		this->_Myres = _Right._Myres;

	mov	QWORD PTR [rbx+24], rdx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 98   : 			return (_Str);

	jmp	$LN530@str
$LN103@str:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Str$4[rbp-80]
	mov	QWORD PTR [rbx], rcx
$LN102@str:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 944  : 		this->_Mysize = _Right._Mysize;

	mov	rcx, QWORD PTR _Str$4[rbp-64]

; 945  : 		this->_Myres = _Right._Myres;

	mov	QWORD PTR [rbx+24], rdx
	mov	QWORD PTR [rbx+16], rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 98   : 			return (_Str);

	jmp	$LN530@str
$LN4@str:

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

	test	dl, 4
	jne	SHORT $LN2@str
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 221  : 		return (*_IGnext);

	mov	rax, QWORD PTR [rcx+56]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	je	SHORT $LN2@str
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 236  : 		return (*_IGnext + *_IGcount);

	mov	rax, QWORD PTR [rcx+80]
	movsxd	r8, DWORD PTR [rax]

; 216  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rcx+24]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 768  : 		assign(_Ptr, _Count);

	lea	rcx, QWORD PTR _Str$3[rbp-80]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 236  : 		return (*_IGnext + *_IGcount);

	add	r8, rdx

; 216  : 		return (*_IGfirst);

	mov	rdx, QWORD PTR [rax]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR _Str$3[rbp-56], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

	sub	r8, rdx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR _Str$3[rbp-64], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR _Str$3[rbp-80], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 768  : 		assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 939  : 		else

	jmp	SHORT $LN531@str
$LN2@str:

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR _Nul$2[rbp-56], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR _Nul$2[rbp-64], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR _Nul$2[rbp-80], dil
$LN531@str:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	mov	rcx, QWORD PTR _Nul$2[rbp-56]
	cmp	rcx, 16
	jae	SHORT $LN443@str

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	r8, QWORD PTR _Nul$2[rbp-64]
	inc	r8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN442@str
	lea	rdx, QWORD PTR _Nul$2[rbp-80]
	mov	rcx, rbx
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

	mov	rcx, QWORD PTR _Nul$2[rbp-56]
	jmp	SHORT $LN442@str
$LN443@str:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR _Nul$2[rbp-80]
	mov	QWORD PTR [rbx], rax
$LN442@str:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 944  : 		this->_Mysize = _Right._Mysize;

	mov	rax, QWORD PTR _Nul$2[rbp-64]

; 945  : 		this->_Myres = _Right._Myres;

	mov	QWORD PTR [rbx+24], rcx
	mov	QWORD PTR [rbx+16], rax
$LN530@str:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\sstream

; 108  : 			return (_Nul);

	mov	rax, rbx

; 109  : 			}
; 110  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-80]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	rbp
	ret	0
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?pop_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::pop_back, COMDAT

; 1471 : 		{	// erase element at end

$LN52:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	r8, QWORD PTR [rcx+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rax, QWORD PTR [rcx+16]

; 1471 : 		{	// erase element at end

	mov	rbx, rcx

; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	dec	r8

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	dec	rax

; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	add	r8, QWORD PTR [rcx+24]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	and	r8, rax

; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	rax, QWORD PTR [rcx+8]
	mov	rdi, QWORD PTR [rax+r8*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rdi+48], 16
	jb	SHORT $LN39@pop_back
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdi+24]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN39@pop_back:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	eax, eax

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+40], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi+24], al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1491 : 		if (--this->_Mysize == 0)

	dec	QWORD PTR [rbx+32]
	jne	SHORT $LN1@pop_back

; 1492 : 			this->_Myoff = 0;

	mov	QWORD PTR [rbx+24], rax
$LN1@pop_back:

; 1493 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1494 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?pop_back@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Count$dead$ = 72
?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Growmap, COMDAT

; 1772 : 		{	// grow map by at least _Count pointers, _Mapsize a power of 2

$LN169:
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H

; 1773 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1774 : 			"The _Xlen() test should always be performed.");
; 1775 : 
; 1776 : 		typedef typename _Alpty::pointer _Blockptr;
; 1777 : 		_Alpty _Almap(this->_Getal());
; 1778 : 		size_type _Newsize = 0 < this->_Mapsize ? this->_Mapsize : 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	ebx, 1
	mov	rbp, rcx
	test	rdx, rdx
	mov	rcx, 288230376151711743			; 03ffffffffffffffH
	cmovne	rbx, rdx
$LL7@Growmap:

; 1779 : 		while (_Newsize - this->_Mapsize < _Count || _Newsize < _DEQUEMAPSIZ)

	mov	rax, rbx
	sub	rax, rdx
	cmp	rax, 1
	jb	SHORT $LN5@Growmap
	cmp	rbx, 8
	jae	SHORT $LN6@Growmap
$LN5@Growmap:

; 1780 : 			{	// scale _Newsize to 2^N >= _Mapsize + _Count
; 1781 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

	mov	rax, rcx
	sub	rax, rbx
	cmp	rax, rbx
	jb	$LN151@Growmap

; 1782 : 				_Xlen();	// result too long
; 1783 : 			_Newsize *= 2;

	add	rbx, rbx

; 1784 : 			}

	jmp	SHORT $LL7@Growmap
$LN6@Growmap:

; 1785 : 		_Count = _Newsize - this->_Mapsize;

	sub	rbx, rdx
	mov	QWORD PTR [rsp+88], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

	xor	r14d, r14d
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1788 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize + _Count);

	lea	rcx, QWORD PTR [rdx+rbx]
	mov	QWORD PTR [rsp+32], r15
	mov	r15, QWORD PTR [rbp+24]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

	test	rcx, rcx
	je	SHORT $LN32@Growmap

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN31@Growmap
	lea	rcx, QWORD PTR [rcx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	r14, rax
	test	rax, rax
	jne	SHORT $LN32@Growmap
$LN31@Growmap:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN32@Growmap:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1793 : 			_Myptr, _Almap);	// copy initial to end

	mov	rax, QWORD PTR [rbp+8]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, QWORD PTR [rbp+16]
	lea	rsi, QWORD PTR [r15*8]
	shl	rdi, 3
	lea	rdx, QWORD PTR [rsi+rax]
	lea	rcx, QWORD PTR [rsi+r14]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdi, rdx
	add	rdi, rax
	sar	rdi, 3

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rdi, QWORD PTR [rdi*8]
	mov	r8, rdi
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1798 : 				_Myptr, _Almap);	// copy rest of old

	mov	rdx, QWORD PTR [rbp+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	add	rax, rdi
	mov	rcx, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1794 : 		if (_Myboff <= _Count)

	cmp	r15, rbx
	ja	SHORT $LN3@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sar	rsi, 3
	mov	QWORD PTR [rsp+80], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1800 : 				_Almap);	// clear suffix of new

	mov	r12, rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rsi, QWORD PTR [rsi*8]
	mov	r8, rsi
	call	QWORD PTR __imp_memmove
	add	rax, rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1800 : 				_Almap);	// clear suffix of new

	sub	r12, r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	je	SHORT $LN81@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1798 : 				_Myptr, _Almap);	// copy rest of old

	mov	rdi, rax
	mov	rcx, r12
	xor	eax, eax
	rep stosq
$LN81@Growmap:
	mov	r12, QWORD PTR [rsp+80]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	r15, r15
	je	SHORT $LN139@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	mov	rdi, r14
	mov	rcx, r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1804 : 		else

	jmp	SHORT $LN167@Growmap
$LN3@Growmap:

; 1808 : 				_Myptr, _Almap);	// copy more old

	lea	rdi, QWORD PTR [rbx*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	r8, rdi
	and	r8, -8
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1811 : 				_Newmap, _Almap);	// copy rest of old

	mov	rax, QWORD PTR [rbp+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	rcx, r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1811 : 				_Newmap, _Almap);	// copy rest of old

	lea	rdx, QWORD PTR [rdi+rax]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rsi, rdx
	add	rsi, rax
	sar	rsi, 3

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rsi, QWORD PTR [rsi*8]
	mov	r8, rsi
	call	QWORD PTR __imp_memmove
	add	rax, rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rbx, rbx
	je	SHORT $LN139@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1808 : 				_Myptr, _Almap);	// copy more old

	mov	rdi, rax
	mov	rcx, rbx
$LN167@Growmap:
	xor	eax, eax
	rep stosq
$LN139@Growmap:

; 1812 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1813 : 				_Almap);	// clear rest to initial block
; 1814 : 			}
; 1815 : 
; 1816 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1817 : 			_Almap);
; 1818 : 		if (this->_Map != _Mapptr())

	mov	rcx, QWORD PTR [rbp+8]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	test	rcx, rcx
	je	SHORT $LN144@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN144@Growmap:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1823 : 		this->_Mapsize += _Count;

	add	QWORD PTR [rbp+16], rbx
	mov	r15, QWORD PTR [rsp+32]
	mov	QWORD PTR [rbp+8], r14
	mov	r14, QWORD PTR [rsp+88]

; 1824 : 		}

	add	rsp, 40					; 00000028H
	pop	rbp
	pop	rbx
	ret	0
$LN151@Growmap:

; 1763 : 		_Xlength_error("deque<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN168@Growmap:
?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAXXZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Tidy, COMDAT

; 1827 : 		{	// free all storage

$LN83:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 783  : 		}
; 784  : 
; 785  : 	_Mapptr _Map;		// pointer to array of pointers to blocks
; 786  : 	size_type _Mapsize;	// size of map array, zero or 2^N
; 787  : 	size_type _Myoff;	// offset of initial element
; 788  : 	size_type _Mysize;	// current length of sequence
; 789  : 	};
; 790  : 
; 791  : 		// TEMPLATE CLASS _Deque_alloc
; 792  : template<bool _Al_has_storage,
; 793  : 	class _Alloc_types>
; 794  : 	class _Deque_alloc
; 795  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 796  : 	{	// base class for deque to hold allocator with storage
; 797  : public:
; 798  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 799  : 
; 800  : 	typedef _Deque_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 801  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 802  : 	typedef typename _Alloc_types::_Alty _Alty;
; 803  : 
; 804  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 805  : 
; 806  : 	_Deque_alloc(const _Alloc& _Al = _Alloc())
; 807  : 		: _Alval(_Al)
; 808  : 		{	// construct allocators from _Al
; 809  : 		_Alloc_proxy();
; 810  : 		}
; 811  : 
; 812  : 	~_Deque_alloc() _NOEXCEPT
; 813  : 		{	// destroy proxy
; 814  : 		_Free_proxy();
; 815  : 		}
; 816  : 
; 817  : 	void _Change_alloc(const _Alty& _Al)
; 818  : 		{	// replace old allocator
; 819  : 		_Free_proxy();
; 820  : 		this->_Alval = _Al;
; 821  : 		_Alloc_proxy();
; 822  : 		}
; 823  : 
; 824  : 	void _Swap_alloc(_Myt& _Right)
; 825  : 		{	// swap allocators
; 826  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 827  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 828  : 		}
; 829  : 
; 830  : 	void _Alloc_proxy()
; 831  : 		{	// construct proxy from _Alval
; 832  : 		typename _Alty::template rebind<_Container_proxy>::other
; 833  : 			_Alproxy(this->_Alval);
; 834  : 		this->_Myproxy = _Alproxy.allocate(1);
; 835  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 836  : 		this->_Myproxy->_Mycont = this;
; 837  : 		}
; 838  : 
; 839  : 	void _Free_proxy()
; 840  : 		{	// destroy proxy
; 841  : 		typename _Alty::template rebind<_Container_proxy>::other
; 842  : 			_Alproxy(this->_Alval);
; 843  : 		this->_Orphan_all();
; 844  : 		_Alproxy.destroy(this->_Myproxy);
; 845  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 846  : 		this->_Myproxy = 0;
; 847  : 		}
; 848  : 
; 849  : 	_Alty& _Getal()
; 850  : 		{	// get reference to allocator
; 851  : 		return (this->_Alval);
; 852  : 		}
; 853  : 
; 854  : 	const _Alty& _Getal() const
; 855  : 		{	// get reference to allocator
; 856  : 		return (this->_Alval);
; 857  : 		}
; 858  : 	};
; 859  : 
; 860  : template<class _Alloc_types>
; 861  : 	class _Deque_alloc<false, _Alloc_types>
; 862  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 863  : 	{	// base class for deque to hold allocator with no storage
; 864  : public:
; 865  : 	typedef _Deque_alloc<false, _Alloc_types> _Myt;
; 866  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 867  : 
; 868  : 	typedef typename _Alloc_types::_Alty _Alty;
; 869  : 
; 870  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 871  : 
; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())
; 873  : 		{	// construct allocators from _Al
; 874  : 		_Alloc_proxy();
; 875  : 		}
; 876  : 
; 877  : 	~_Deque_alloc() _NOEXCEPT
; 878  : 		{	// destroy proxy
; 879  : 		_Free_proxy();
; 880  : 		}
; 881  : 
; 882  : 	void _Change_alloc(const _Alty&)
; 883  : 		{	// replace old allocator
; 884  : 		}
; 885  : 
; 886  : 	void _Swap_alloc(_Myt& _Right)
; 887  : 		{	// swap allocators
; 888  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 889  : 		}
; 890  : 
; 891  : 	void _Alloc_proxy()
; 892  : 		{	// construct proxy from _Alval
; 893  : 		typename _Alty::template rebind<_Container_proxy>::other
; 894  : 			_Alproxy;
; 895  : 		this->_Myproxy = _Alproxy.allocate(1);
; 896  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 897  : 		this->_Myproxy->_Mycont = this;
; 898  : 		}
; 899  : 
; 900  : 	void _Free_proxy()
; 901  : 		{	// destroy proxy
; 902  : 		typename _Alty::template rebind<_Container_proxy>::other
; 903  : 			_Alproxy;
; 904  : 		this->_Orphan_all();
; 905  : 		_Alproxy.destroy(this->_Myproxy);
; 906  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 907  : 		this->_Myproxy = 0;
; 908  : 		}
; 909  : 
; 910  : 	_Alty _Getal() const
; 911  : 		{	// get reference to allocator
; 912  : 		return (_Alty());
; 913  : 		}
; 914  : 	};
; 915  : 
; 916  : 		// TEMPLATE CLASS deque
; 917  : template<class _Ty,
; 918  : 	class _Alloc = allocator<_Ty> >
; 919  : 	class deque
; 920  : 		: public _Deque_alloc<!is_empty<_Alloc>::value,
; 921  : 			_Deque_base_types<_Ty, _Alloc> >
; 922  : 	{	// circular queue of pointers to blocks
; 923  : public:
; 924  : 	typedef deque<_Ty, _Alloc> _Myt;
; 925  : 	typedef _Deque_alloc<!is_empty<_Alloc>::value,
; 926  : 		_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 927  : 	typedef _Alloc allocator_type;
; 928  : 
; 929  : 	typedef typename _Mybase::_Alty _Alty;
; 930  : 	typedef typename _Mybase::_Alpty _Alpty;
; 931  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 932  : 
; 933  : 	typedef typename _Mybase::value_type value_type;
; 934  : 	typedef typename _Mybase::size_type size_type;
; 935  : 	typedef typename _Mybase::difference_type difference_type;
; 936  : 	typedef typename _Mybase::pointer pointer;
; 937  : 	typedef typename _Mybase::const_pointer const_pointer;
; 938  : 	typedef typename _Mybase::reference reference;
; 939  : 	typedef typename _Mybase::const_reference const_reference;
; 940  : 
; 941  : 	typedef typename _Mybase::iterator iterator;
; 942  : 	typedef typename _Mybase::const_iterator const_iterator;
; 943  : 
; 944  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 945  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 946  : 
; 947  : 	static const int _EEM_DS = _DEQUESIZ;
; 948  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 949  : 	deque()
; 950  : 		: _Mybase()
; 951  : 		{	// construct empty deque
; 952  : 		}
; 953  : 
; 954  : 	explicit deque(const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct empty deque with allocator
; 957  : 		}
; 958  : 
; 959  : 	explicit deque(size_type _Count)
; 960  : 		: _Mybase()
; 961  : 		{	// construct from _Count * value_type()
; 962  : 		resize(_Count);
; 963  : 		}
; 964  : 
; 965  : 	deque(size_type _Count, const value_type& _Val)
; 966  : 		: _Mybase()
; 967  : 		{	// construct from _Count * _Val
; 968  : 		_Construct_n(_Count, _Val);
; 969  : 		}
; 970  : 
; 971  : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 972  : 		: _Mybase(_Al)
; 973  : 		{	// construct from _Count * _Val with allocator
; 974  : 		_Construct_n(_Count, _Val);
; 975  : 		}
; 976  : 
; 977  : 	deque(const _Myt& _Right)
; 978  : 
; 979  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 980  : 
; 981  : 
; 982  : 		{	// construct by copying _Right
; 983  : 		_Construct(_Right.begin(), _Right.end());
; 984  : 		}
; 985  : 
; 986  : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 987  : 		: _Mybase(_Al)
; 988  : 		{	// construct by copying _Right
; 989  : 		_Construct(_Right.begin(), _Right.end());
; 990  : 		}
; 991  : 
; 992  : 	template<class _Iter,
; 993  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 994  : 			void>::type>
; 995  : 		deque(_Iter _First, _Iter _Last)
; 996  : 		: _Mybase()
; 997  : 		{	// construct from [_First, _Last)
; 998  : 		_Construct(_First, _Last);
; 999  : 		}
; 1000 : 
; 1001 : 	template<class _Iter,
; 1002 : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 1003 : 			void>::type>
; 1004 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 1005 : 		: _Mybase(_Al)
; 1006 : 		{	// construct from [_First, _Last) with allocator
; 1007 : 		_Construct(_First, _Last);
; 1008 : 		}
; 1009 : 
; 1010 : 	template<class _Iter>
; 1011 : 		void _Construct(_Iter _First, _Iter _Last)
; 1012 : 		{	// initialize from [_First, _Last), input iterators
; 1013 : 		_TRY_BEGIN
; 1014 : 
; 1015 : 		for (; _First != _Last; ++_First)
; 1016 : 			emplace_back(*_First);
; 1017 : 
; 1018 : 		_CATCH_ALL
; 1019 : 		_Tidy();
; 1020 : 		_RERAISE;
; 1021 : 		_CATCH_END
; 1022 : 		}
; 1023 : 
; 1024 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1025 : 		{	// construct from _Count * _Val
; 1026 : 		_TRY_BEGIN
; 1027 : 		for (; 0 < _Count; --_Count)
; 1028 : 			push_back(_Val);
; 1029 : 		_CATCH_ALL
; 1030 : 		_Tidy();
; 1031 : 		_RERAISE;
; 1032 : 		_CATCH_END
; 1033 : 		}
; 1034 : 
; 1035 : #define _PUSH_FRONT_BEGIN \
; 1036 : 	if (this->_Myoff % _DEQUESIZ == 0 \
; 1037 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1038 : 		_Growmap(1); \
; 1039 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1040 : 	size_type _Newoff = this->_Myoff != 0 ? this->_Myoff \
; 1041 : 		: this->_Mapsize * _DEQUESIZ; \
; 1042 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1043 : 	if (this->_Map[_Block] == pointer()) \
; 1044 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1045 : 
; 1046 : #define _PUSH_FRONT_END \
; 1047 : 	this->_Myoff = _Newoff; \
; 1048 : 	++this->_Mysize
; 1049 : 
; 1050 : #define _PUSH_BACK_BEGIN \
; 1051 : 	if ((this->_Myoff + this->_Mysize) % _DEQUESIZ == 0 \
; 1052 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1053 : 		_Growmap(1); \
; 1054 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1055 : 	size_type _Newoff = this->_Myoff + this->_Mysize; \
; 1056 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1057 : 	if (this->_Map[_Block] == pointer()) \
; 1058 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1059 : 
; 1060 : #define _PUSH_BACK_END \
; 1061 : 	++this->_Mysize
; 1062 : 
; 1063 : 	deque(_Myt&& _Right)
; 1064 : 		: _Mybase(_Right._Getal())
; 1065 : 		{	// construct by moving _Right
; 1066 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1067 : 		}
; 1068 : 
; 1069 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1070 : 		: _Mybase(_Al)
; 1071 : 		{	// construct by moving _Right
; 1072 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1073 : 		}
; 1074 : 
; 1075 : 	_Myt& operator=(_Myt&& _Right)
; 1076 : 		{	// assign by moving _Right
; 1077 : 		if (this != &_Right)
; 1078 : 			{	// different, assign it
; 1079 : 			_Tidy();
; 1080 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1081 : 				&& this->_Getal() != _Right._Getal())
; 1082 : 				this->_Change_alloc(_Right._Getal());
; 1083 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1084 : 			}
; 1085 : 		return (*this);
; 1086 : 		}
; 1087 : 
; 1088 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1089 : 		{	// move from _Right, stealing its contents
; 1090 : 		this->_Swap_all((_Myt&)_Right);
; 1091 : 		this->_Map = _Right._Map;
; 1092 : 		this->_Mapsize = _Right._Mapsize;
; 1093 : 		this->_Myoff = _Right._Myoff;
; 1094 : 		this->_Mysize = _Right._Mysize;
; 1095 : 
; 1096 : 		_Right._Map = _Mapptr();
; 1097 : 		_Right._Mapsize = 0;
; 1098 : 		_Right._Myoff = 0;
; 1099 : 		_Right._Mysize = 0;
; 1100 : 		}
; 1101 : 
; 1102 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1103 : 		{	// move from _Right, possibly moving its contents
; 1104 : 		if (get_allocator() == _Right.get_allocator())
; 1105 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1106 : 		else
; 1107 : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 1108 : 				_STD make_move_iterator(_Right.end()));
; 1109 : 		}
; 1110 : 
; 1111 : 	void _Assign_rv(_Myt&& _Right)
; 1112 : 		{	// assign by moving _Right
; 1113 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1114 : 			typename _Alty::propagate_on_container_move_assignment());
; 1115 : 		}
; 1116 : 
; 1117 : 
; 1118 : 	void push_front(value_type&& _Val)
; 1119 : 		{	// insert element at beginning
; 1120 : 		this->_Orphan_all();
; 1121 : 		_PUSH_FRONT_BEGIN;
; 1122 : 		this->_Getal().construct(
; 1123 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1124 : 			_STD forward<value_type>(_Val));
; 1125 : 		_PUSH_FRONT_END;
; 1126 : 		}
; 1127 : 
; 1128 : 	void push_back(value_type&& _Val)
; 1129 : 		{	// insert element at end
; 1130 : 		this->_Orphan_all();
; 1131 : 		_PUSH_BACK_BEGIN;
; 1132 : 		this->_Getal().construct(
; 1133 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 			_STD forward<value_type>(_Val));
; 1135 : 		_PUSH_BACK_END;
; 1136 : 		}
; 1137 : 
; 1138 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1139 : 		{	// insert _Val at _Where
; 1140 : 		return (emplace(_Where, _STD move(_Val)));
; 1141 : 		}
; 1142 : 
; 1143 : 	template<class... _Valty>
; 1144 : 		void emplace_front(_Valty&&... _Val)
; 1145 : 		{	// insert element at beginning
; 1146 : 		this->_Orphan_all();
; 1147 : 		_PUSH_FRONT_BEGIN;
; 1148 : 		this->_Getal().construct(
; 1149 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1150 : 			_STD forward<_Valty>(_Val)...);
; 1151 : 		_PUSH_FRONT_END;
; 1152 : 		}
; 1153 : 
; 1154 : 	template<class... _Valty>
; 1155 : 		void emplace_back(_Valty&&... _Val)
; 1156 : 		{	// insert element at end
; 1157 : 		this->_Orphan_all();
; 1158 : 		_PUSH_BACK_BEGIN;
; 1159 : 		this->_Getal().construct(
; 1160 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1161 : 			_STD forward<_Valty>(_Val)...);
; 1162 : 		_PUSH_BACK_END;
; 1163 : 		}
; 1164 : 
; 1165 : 	template<class... _Valty>
; 1166 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1167 : 		{	// insert element at _Where
; 1168 : 		size_type _Off = _Where - begin();
; 1169 : 
; 1170 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1171 : 		if (this->_Mysize < _Off)
; 1172 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1173 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1174 : 
; 1175 : 		if (_Off <= this->_Mysize / 2)
; 1176 : 			{	// closer to front, push to front then rotate
; 1177 : 			emplace_front(_STD forward<_Valty>(_Val)...);
; 1178 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off);
; 1179 : 			}
; 1180 : 		else
; 1181 : 			{	// closer to back, push to back then rotate
; 1182 : 			emplace_back(_STD forward<_Valty>(_Val)...);
; 1183 : 			_STD rotate(begin() + _Off, end() - 1, end());
; 1184 : 			}
; 1185 : 		return (begin() + _Off);
; 1186 : 		}
; 1187 : 
; 1188 : 
; 1189 : 	deque(_XSTD initializer_list<value_type> _Ilist,
; 1190 : 		const _Alloc& _Al = allocator_type())
; 1191 : 		: _Mybase(_Al)
; 1192 : 		{	// construct from initializer_list
; 1193 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1194 : 		}
; 1195 : 
; 1196 : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 1197 : 		{	// assign initializer_list
; 1198 : 		assign(_Ilist.begin(), _Ilist.end());
; 1199 : 		return (*this);
; 1200 : 		}
; 1201 : 
; 1202 : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 1203 : 		{	// assign initializer_list
; 1204 : 		assign(_Ilist.begin(), _Ilist.end());
; 1205 : 		}
; 1206 : 
; 1207 : 	iterator insert(const_iterator _Where,
; 1208 : 		_XSTD initializer_list<value_type> _Ilist)
; 1209 : 		{	// insert initializer_list
; 1210 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1211 : 		}
; 1212 : 
; 1213 : 	~deque() _NOEXCEPT
; 1214 : 		{	// destroy the deque
; 1215 : 		_Tidy();
; 1216 : 		}
; 1217 : 
; 1218 : 	_Myt& operator=(const _Myt& _Right)
; 1219 : 		{	// assign _Right
; 1220 : 		if (this != &_Right)
; 1221 : 			{	// different, assign it
; 1222 : 			if (this->_Getal() != _Right._Getal()
; 1223 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1224 : 				{	// change allocator before copying
; 1225 : 				_Tidy();
; 1226 : 				this->_Change_alloc(_Right._Getal());
; 1227 : 				}
; 1228 : 
; 1229 : 			this->_Orphan_all();
; 1230 : 
; 1231 : 			if (_Right._Mysize == 0)
; 1232 : 				clear();
; 1233 : 			else if (_Right._Mysize <= this->_Mysize)
; 1234 : 				{	// enough elements, copy new and destroy old
; 1235 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1236 : 					begin());
; 1237 : 				erase(_Mid, end());
; 1238 : 				}
; 1239 : 			else
; 1240 : 				{	// new sequence longer, copy and construct new
; 1241 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;
; 1242 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1243 : 				insert(end(), _Mid, _Right.end());
; 1244 : 				}
; 1245 : 			}
; 1246 : 		return (*this);
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator begin() _NOEXCEPT
; 1250 : 		{	// return iterator for beginning of mutable sequence
; 1251 : 		return (iterator(this->_Myoff, this));
; 1252 : 		}
; 1253 : 
; 1254 : 	const_iterator begin() const _NOEXCEPT
; 1255 : 		{	// return iterator for beginning of nonmutable sequence
; 1256 : 		return (const_iterator(this->_Myoff, this));
; 1257 : 		}
; 1258 : 
; 1259 : 	iterator end() _NOEXCEPT
; 1260 : 		{	// return iterator for end of mutable sequence
; 1261 : 		return (iterator(this->_Myoff + this->_Mysize, this));
; 1262 : 		}
; 1263 : 
; 1264 : 	const_iterator end() const _NOEXCEPT
; 1265 : 		{	// return iterator for end of nonmutable sequence
; 1266 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));
; 1267 : 		}
; 1268 : 
; 1269 : 	iterator _Make_iter(const_iterator _Where) const
; 1270 : 		{	// make iterator from const_iterator
; 1271 : 		return (iterator(_Where._Myoff, this));
; 1272 : 		}
; 1273 : 
; 1274 : 	reverse_iterator rbegin() _NOEXCEPT
; 1275 : 		{	// return iterator for beginning of reversed mutable sequence
; 1276 : 		return (reverse_iterator(end()));
; 1277 : 		}
; 1278 : 
; 1279 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1280 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1281 : 		return (const_reverse_iterator(end()));
; 1282 : 		}
; 1283 : 
; 1284 : 	reverse_iterator rend() _NOEXCEPT
; 1285 : 		{	// return iterator for end of reversed mutable sequence
; 1286 : 		return (reverse_iterator(begin()));
; 1287 : 		}
; 1288 : 
; 1289 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1290 : 		{	// return iterator for end of reversed nonmutable sequence
; 1291 : 		return (const_reverse_iterator(begin()));
; 1292 : 		}
; 1293 : 
; 1294 : 	const_iterator cbegin() const _NOEXCEPT
; 1295 : 		{	// return iterator for beginning of nonmutable sequence
; 1296 : 		return (((const _Myt *)this)->begin());
; 1297 : 		}
; 1298 : 
; 1299 : 	const_iterator cend() const _NOEXCEPT
; 1300 : 		{	// return iterator for end of nonmutable sequence
; 1301 : 		return (((const _Myt *)this)->end());
; 1302 : 		}
; 1303 : 
; 1304 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1306 : 		return (((const _Myt *)this)->rbegin());
; 1307 : 		}
; 1308 : 
; 1309 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1310 : 		{	// return iterator for end of reversed nonmutable sequence
; 1311 : 		return (((const _Myt *)this)->rend());
; 1312 : 		}
; 1313 : 
; 1314 : 	void shrink_to_fit()
; 1315 : 		{	// reduce capacity
; 1316 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize;
; 1317 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1318 : 
; 1319 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1320 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1321 : 
; 1322 : 		if ((empty() && 0 < this->_Mapsize)
; 1323 : 			|| (!empty()
; 1324 : 				&& size() <= _Newcapacity
; 1325 : 				&& _Newcapacity < _Oldcapacity))
; 1326 : 			{	// worth shrinking, do it
; 1327 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1328 : 				_STD make_move_iterator(end()));
; 1329 : 			swap(_Tmp);
; 1330 : 			}
; 1331 : 		}
; 1332 : 
; 1333 : 	void resize(size_type _Newsize)
; 1334 : 		{	// determine new length, padding as needed
; 1335 : 		while (this->_Mysize < _Newsize)
; 1336 : 			emplace_back();
; 1337 : 
; 1338 : 		while (_Newsize < this->_Mysize)
; 1339 : 			pop_back();
; 1340 : 		}
; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);

	xor	esi, esi

; 1827 : 		{	// free all storage

	mov	rbx, rcx

; 783  : 		}
; 784  : 
; 785  : 	_Mapptr _Map;		// pointer to array of pointers to blocks
; 786  : 	size_type _Mapsize;	// size of map array, zero or 2^N
; 787  : 	size_type _Myoff;	// offset of initial element
; 788  : 	size_type _Mysize;	// current length of sequence
; 789  : 	};
; 790  : 
; 791  : 		// TEMPLATE CLASS _Deque_alloc
; 792  : template<bool _Al_has_storage,
; 793  : 	class _Alloc_types>
; 794  : 	class _Deque_alloc
; 795  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 796  : 	{	// base class for deque to hold allocator with storage
; 797  : public:
; 798  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 799  : 
; 800  : 	typedef _Deque_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 801  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 802  : 	typedef typename _Alloc_types::_Alty _Alty;
; 803  : 
; 804  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 805  : 
; 806  : 	_Deque_alloc(const _Alloc& _Al = _Alloc())
; 807  : 		: _Alval(_Al)
; 808  : 		{	// construct allocators from _Al
; 809  : 		_Alloc_proxy();
; 810  : 		}
; 811  : 
; 812  : 	~_Deque_alloc() _NOEXCEPT
; 813  : 		{	// destroy proxy
; 814  : 		_Free_proxy();
; 815  : 		}
; 816  : 
; 817  : 	void _Change_alloc(const _Alty& _Al)
; 818  : 		{	// replace old allocator
; 819  : 		_Free_proxy();
; 820  : 		this->_Alval = _Al;
; 821  : 		_Alloc_proxy();
; 822  : 		}
; 823  : 
; 824  : 	void _Swap_alloc(_Myt& _Right)
; 825  : 		{	// swap allocators
; 826  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 827  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 828  : 		}
; 829  : 
; 830  : 	void _Alloc_proxy()
; 831  : 		{	// construct proxy from _Alval
; 832  : 		typename _Alty::template rebind<_Container_proxy>::other
; 833  : 			_Alproxy(this->_Alval);
; 834  : 		this->_Myproxy = _Alproxy.allocate(1);
; 835  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 836  : 		this->_Myproxy->_Mycont = this;
; 837  : 		}
; 838  : 
; 839  : 	void _Free_proxy()
; 840  : 		{	// destroy proxy
; 841  : 		typename _Alty::template rebind<_Container_proxy>::other
; 842  : 			_Alproxy(this->_Alval);
; 843  : 		this->_Orphan_all();
; 844  : 		_Alproxy.destroy(this->_Myproxy);
; 845  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 846  : 		this->_Myproxy = 0;
; 847  : 		}
; 848  : 
; 849  : 	_Alty& _Getal()
; 850  : 		{	// get reference to allocator
; 851  : 		return (this->_Alval);
; 852  : 		}
; 853  : 
; 854  : 	const _Alty& _Getal() const
; 855  : 		{	// get reference to allocator
; 856  : 		return (this->_Alval);
; 857  : 		}
; 858  : 	};
; 859  : 
; 860  : template<class _Alloc_types>
; 861  : 	class _Deque_alloc<false, _Alloc_types>
; 862  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 863  : 	{	// base class for deque to hold allocator with no storage
; 864  : public:
; 865  : 	typedef _Deque_alloc<false, _Alloc_types> _Myt;
; 866  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 867  : 
; 868  : 	typedef typename _Alloc_types::_Alty _Alty;
; 869  : 
; 870  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 871  : 
; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())
; 873  : 		{	// construct allocators from _Al
; 874  : 		_Alloc_proxy();
; 875  : 		}
; 876  : 
; 877  : 	~_Deque_alloc() _NOEXCEPT
; 878  : 		{	// destroy proxy
; 879  : 		_Free_proxy();
; 880  : 		}
; 881  : 
; 882  : 	void _Change_alloc(const _Alty&)
; 883  : 		{	// replace old allocator
; 884  : 		}
; 885  : 
; 886  : 	void _Swap_alloc(_Myt& _Right)
; 887  : 		{	// swap allocators
; 888  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 889  : 		}
; 890  : 
; 891  : 	void _Alloc_proxy()
; 892  : 		{	// construct proxy from _Alval
; 893  : 		typename _Alty::template rebind<_Container_proxy>::other
; 894  : 			_Alproxy;
; 895  : 		this->_Myproxy = _Alproxy.allocate(1);
; 896  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 897  : 		this->_Myproxy->_Mycont = this;
; 898  : 		}
; 899  : 
; 900  : 	void _Free_proxy()
; 901  : 		{	// destroy proxy
; 902  : 		typename _Alty::template rebind<_Container_proxy>::other
; 903  : 			_Alproxy;
; 904  : 		this->_Orphan_all();
; 905  : 		_Alproxy.destroy(this->_Myproxy);
; 906  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 907  : 		this->_Myproxy = 0;
; 908  : 		}
; 909  : 
; 910  : 	_Alty _Getal() const
; 911  : 		{	// get reference to allocator
; 912  : 		return (_Alty());
; 913  : 		}
; 914  : 	};
; 915  : 
; 916  : 		// TEMPLATE CLASS deque
; 917  : template<class _Ty,
; 918  : 	class _Alloc = allocator<_Ty> >
; 919  : 	class deque
; 920  : 		: public _Deque_alloc<!is_empty<_Alloc>::value,
; 921  : 			_Deque_base_types<_Ty, _Alloc> >
; 922  : 	{	// circular queue of pointers to blocks
; 923  : public:
; 924  : 	typedef deque<_Ty, _Alloc> _Myt;
; 925  : 	typedef _Deque_alloc<!is_empty<_Alloc>::value,
; 926  : 		_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 927  : 	typedef _Alloc allocator_type;
; 928  : 
; 929  : 	typedef typename _Mybase::_Alty _Alty;
; 930  : 	typedef typename _Mybase::_Alpty _Alpty;
; 931  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 932  : 
; 933  : 	typedef typename _Mybase::value_type value_type;
; 934  : 	typedef typename _Mybase::size_type size_type;
; 935  : 	typedef typename _Mybase::difference_type difference_type;
; 936  : 	typedef typename _Mybase::pointer pointer;
; 937  : 	typedef typename _Mybase::const_pointer const_pointer;
; 938  : 	typedef typename _Mybase::reference reference;
; 939  : 	typedef typename _Mybase::const_reference const_reference;
; 940  : 
; 941  : 	typedef typename _Mybase::iterator iterator;
; 942  : 	typedef typename _Mybase::const_iterator const_iterator;
; 943  : 
; 944  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 945  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 946  : 
; 947  : 	static const int _EEM_DS = _DEQUESIZ;
; 948  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 949  : 	deque()
; 950  : 		: _Mybase()
; 951  : 		{	// construct empty deque
; 952  : 		}
; 953  : 
; 954  : 	explicit deque(const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct empty deque with allocator
; 957  : 		}
; 958  : 
; 959  : 	explicit deque(size_type _Count)
; 960  : 		: _Mybase()
; 961  : 		{	// construct from _Count * value_type()
; 962  : 		resize(_Count);
; 963  : 		}
; 964  : 
; 965  : 	deque(size_type _Count, const value_type& _Val)
; 966  : 		: _Mybase()
; 967  : 		{	// construct from _Count * _Val
; 968  : 		_Construct_n(_Count, _Val);
; 969  : 		}
; 970  : 
; 971  : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 972  : 		: _Mybase(_Al)
; 973  : 		{	// construct from _Count * _Val with allocator
; 974  : 		_Construct_n(_Count, _Val);
; 975  : 		}
; 976  : 
; 977  : 	deque(const _Myt& _Right)
; 978  : 
; 979  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 980  : 
; 981  : 
; 982  : 		{	// construct by copying _Right
; 983  : 		_Construct(_Right.begin(), _Right.end());
; 984  : 		}
; 985  : 
; 986  : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 987  : 		: _Mybase(_Al)
; 988  : 		{	// construct by copying _Right
; 989  : 		_Construct(_Right.begin(), _Right.end());
; 990  : 		}
; 991  : 
; 992  : 	template<class _Iter,
; 993  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 994  : 			void>::type>
; 995  : 		deque(_Iter _First, _Iter _Last)
; 996  : 		: _Mybase()
; 997  : 		{	// construct from [_First, _Last)
; 998  : 		_Construct(_First, _Last);
; 999  : 		}
; 1000 : 
; 1001 : 	template<class _Iter,
; 1002 : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 1003 : 			void>::type>
; 1004 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 1005 : 		: _Mybase(_Al)
; 1006 : 		{	// construct from [_First, _Last) with allocator
; 1007 : 		_Construct(_First, _Last);
; 1008 : 		}
; 1009 : 
; 1010 : 	template<class _Iter>
; 1011 : 		void _Construct(_Iter _First, _Iter _Last)
; 1012 : 		{	// initialize from [_First, _Last), input iterators
; 1013 : 		_TRY_BEGIN
; 1014 : 
; 1015 : 		for (; _First != _Last; ++_First)
; 1016 : 			emplace_back(*_First);
; 1017 : 
; 1018 : 		_CATCH_ALL
; 1019 : 		_Tidy();
; 1020 : 		_RERAISE;
; 1021 : 		_CATCH_END
; 1022 : 		}
; 1023 : 
; 1024 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1025 : 		{	// construct from _Count * _Val
; 1026 : 		_TRY_BEGIN
; 1027 : 		for (; 0 < _Count; --_Count)
; 1028 : 			push_back(_Val);
; 1029 : 		_CATCH_ALL
; 1030 : 		_Tidy();
; 1031 : 		_RERAISE;
; 1032 : 		_CATCH_END
; 1033 : 		}
; 1034 : 
; 1035 : #define _PUSH_FRONT_BEGIN \
; 1036 : 	if (this->_Myoff % _DEQUESIZ == 0 \
; 1037 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1038 : 		_Growmap(1); \
; 1039 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1040 : 	size_type _Newoff = this->_Myoff != 0 ? this->_Myoff \
; 1041 : 		: this->_Mapsize * _DEQUESIZ; \
; 1042 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1043 : 	if (this->_Map[_Block] == pointer()) \
; 1044 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1045 : 
; 1046 : #define _PUSH_FRONT_END \
; 1047 : 	this->_Myoff = _Newoff; \
; 1048 : 	++this->_Mysize
; 1049 : 
; 1050 : #define _PUSH_BACK_BEGIN \
; 1051 : 	if ((this->_Myoff + this->_Mysize) % _DEQUESIZ == 0 \
; 1052 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1053 : 		_Growmap(1); \
; 1054 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1055 : 	size_type _Newoff = this->_Myoff + this->_Mysize; \
; 1056 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1057 : 	if (this->_Map[_Block] == pointer()) \
; 1058 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1059 : 
; 1060 : #define _PUSH_BACK_END \
; 1061 : 	++this->_Mysize
; 1062 : 
; 1063 : 	deque(_Myt&& _Right)
; 1064 : 		: _Mybase(_Right._Getal())
; 1065 : 		{	// construct by moving _Right
; 1066 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1067 : 		}
; 1068 : 
; 1069 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1070 : 		: _Mybase(_Al)
; 1071 : 		{	// construct by moving _Right
; 1072 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1073 : 		}
; 1074 : 
; 1075 : 	_Myt& operator=(_Myt&& _Right)
; 1076 : 		{	// assign by moving _Right
; 1077 : 		if (this != &_Right)
; 1078 : 			{	// different, assign it
; 1079 : 			_Tidy();
; 1080 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1081 : 				&& this->_Getal() != _Right._Getal())
; 1082 : 				this->_Change_alloc(_Right._Getal());
; 1083 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1084 : 			}
; 1085 : 		return (*this);
; 1086 : 		}
; 1087 : 
; 1088 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1089 : 		{	// move from _Right, stealing its contents
; 1090 : 		this->_Swap_all((_Myt&)_Right);
; 1091 : 		this->_Map = _Right._Map;
; 1092 : 		this->_Mapsize = _Right._Mapsize;
; 1093 : 		this->_Myoff = _Right._Myoff;
; 1094 : 		this->_Mysize = _Right._Mysize;
; 1095 : 
; 1096 : 		_Right._Map = _Mapptr();
; 1097 : 		_Right._Mapsize = 0;
; 1098 : 		_Right._Myoff = 0;
; 1099 : 		_Right._Mysize = 0;
; 1100 : 		}
; 1101 : 
; 1102 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1103 : 		{	// move from _Right, possibly moving its contents
; 1104 : 		if (get_allocator() == _Right.get_allocator())
; 1105 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1106 : 		else
; 1107 : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 1108 : 				_STD make_move_iterator(_Right.end()));
; 1109 : 		}
; 1110 : 
; 1111 : 	void _Assign_rv(_Myt&& _Right)
; 1112 : 		{	// assign by moving _Right
; 1113 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1114 : 			typename _Alty::propagate_on_container_move_assignment());
; 1115 : 		}
; 1116 : 
; 1117 : 
; 1118 : 	void push_front(value_type&& _Val)
; 1119 : 		{	// insert element at beginning
; 1120 : 		this->_Orphan_all();
; 1121 : 		_PUSH_FRONT_BEGIN;
; 1122 : 		this->_Getal().construct(
; 1123 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1124 : 			_STD forward<value_type>(_Val));
; 1125 : 		_PUSH_FRONT_END;
; 1126 : 		}
; 1127 : 
; 1128 : 	void push_back(value_type&& _Val)
; 1129 : 		{	// insert element at end
; 1130 : 		this->_Orphan_all();
; 1131 : 		_PUSH_BACK_BEGIN;
; 1132 : 		this->_Getal().construct(
; 1133 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 			_STD forward<value_type>(_Val));
; 1135 : 		_PUSH_BACK_END;
; 1136 : 		}
; 1137 : 
; 1138 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1139 : 		{	// insert _Val at _Where
; 1140 : 		return (emplace(_Where, _STD move(_Val)));
; 1141 : 		}
; 1142 : 
; 1143 : 	template<class... _Valty>
; 1144 : 		void emplace_front(_Valty&&... _Val)
; 1145 : 		{	// insert element at beginning
; 1146 : 		this->_Orphan_all();
; 1147 : 		_PUSH_FRONT_BEGIN;
; 1148 : 		this->_Getal().construct(
; 1149 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1150 : 			_STD forward<_Valty>(_Val)...);
; 1151 : 		_PUSH_FRONT_END;
; 1152 : 		}
; 1153 : 
; 1154 : 	template<class... _Valty>
; 1155 : 		void emplace_back(_Valty&&... _Val)
; 1156 : 		{	// insert element at end
; 1157 : 		this->_Orphan_all();
; 1158 : 		_PUSH_BACK_BEGIN;
; 1159 : 		this->_Getal().construct(
; 1160 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1161 : 			_STD forward<_Valty>(_Val)...);
; 1162 : 		_PUSH_BACK_END;
; 1163 : 		}
; 1164 : 
; 1165 : 	template<class... _Valty>
; 1166 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1167 : 		{	// insert element at _Where
; 1168 : 		size_type _Off = _Where - begin();
; 1169 : 
; 1170 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1171 : 		if (this->_Mysize < _Off)
; 1172 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1173 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1174 : 
; 1175 : 		if (_Off <= this->_Mysize / 2)
; 1176 : 			{	// closer to front, push to front then rotate
; 1177 : 			emplace_front(_STD forward<_Valty>(_Val)...);
; 1178 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off);
; 1179 : 			}
; 1180 : 		else
; 1181 : 			{	// closer to back, push to back then rotate
; 1182 : 			emplace_back(_STD forward<_Valty>(_Val)...);
; 1183 : 			_STD rotate(begin() + _Off, end() - 1, end());
; 1184 : 			}
; 1185 : 		return (begin() + _Off);
; 1186 : 		}
; 1187 : 
; 1188 : 
; 1189 : 	deque(_XSTD initializer_list<value_type> _Ilist,
; 1190 : 		const _Alloc& _Al = allocator_type())
; 1191 : 		: _Mybase(_Al)
; 1192 : 		{	// construct from initializer_list
; 1193 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1194 : 		}
; 1195 : 
; 1196 : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 1197 : 		{	// assign initializer_list
; 1198 : 		assign(_Ilist.begin(), _Ilist.end());
; 1199 : 		return (*this);
; 1200 : 		}
; 1201 : 
; 1202 : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 1203 : 		{	// assign initializer_list
; 1204 : 		assign(_Ilist.begin(), _Ilist.end());
; 1205 : 		}
; 1206 : 
; 1207 : 	iterator insert(const_iterator _Where,
; 1208 : 		_XSTD initializer_list<value_type> _Ilist)
; 1209 : 		{	// insert initializer_list
; 1210 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1211 : 		}
; 1212 : 
; 1213 : 	~deque() _NOEXCEPT
; 1214 : 		{	// destroy the deque
; 1215 : 		_Tidy();
; 1216 : 		}
; 1217 : 
; 1218 : 	_Myt& operator=(const _Myt& _Right)
; 1219 : 		{	// assign _Right
; 1220 : 		if (this != &_Right)
; 1221 : 			{	// different, assign it
; 1222 : 			if (this->_Getal() != _Right._Getal()
; 1223 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1224 : 				{	// change allocator before copying
; 1225 : 				_Tidy();
; 1226 : 				this->_Change_alloc(_Right._Getal());
; 1227 : 				}
; 1228 : 
; 1229 : 			this->_Orphan_all();
; 1230 : 
; 1231 : 			if (_Right._Mysize == 0)
; 1232 : 				clear();
; 1233 : 			else if (_Right._Mysize <= this->_Mysize)
; 1234 : 				{	// enough elements, copy new and destroy old
; 1235 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1236 : 					begin());
; 1237 : 				erase(_Mid, end());
; 1238 : 				}
; 1239 : 			else
; 1240 : 				{	// new sequence longer, copy and construct new
; 1241 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;
; 1242 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1243 : 				insert(end(), _Mid, _Right.end());
; 1244 : 				}
; 1245 : 			}
; 1246 : 		return (*this);
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator begin() _NOEXCEPT
; 1250 : 		{	// return iterator for beginning of mutable sequence
; 1251 : 		return (iterator(this->_Myoff, this));
; 1252 : 		}
; 1253 : 
; 1254 : 	const_iterator begin() const _NOEXCEPT
; 1255 : 		{	// return iterator for beginning of nonmutable sequence
; 1256 : 		return (const_iterator(this->_Myoff, this));
; 1257 : 		}
; 1258 : 
; 1259 : 	iterator end() _NOEXCEPT
; 1260 : 		{	// return iterator for end of mutable sequence
; 1261 : 		return (iterator(this->_Myoff + this->_Mysize, this));
; 1262 : 		}
; 1263 : 
; 1264 : 	const_iterator end() const _NOEXCEPT
; 1265 : 		{	// return iterator for end of nonmutable sequence
; 1266 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));
; 1267 : 		}
; 1268 : 
; 1269 : 	iterator _Make_iter(const_iterator _Where) const
; 1270 : 		{	// make iterator from const_iterator
; 1271 : 		return (iterator(_Where._Myoff, this));
; 1272 : 		}
; 1273 : 
; 1274 : 	reverse_iterator rbegin() _NOEXCEPT
; 1275 : 		{	// return iterator for beginning of reversed mutable sequence
; 1276 : 		return (reverse_iterator(end()));
; 1277 : 		}
; 1278 : 
; 1279 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1280 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1281 : 		return (const_reverse_iterator(end()));
; 1282 : 		}
; 1283 : 
; 1284 : 	reverse_iterator rend() _NOEXCEPT
; 1285 : 		{	// return iterator for end of reversed mutable sequence
; 1286 : 		return (reverse_iterator(begin()));
; 1287 : 		}
; 1288 : 
; 1289 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1290 : 		{	// return iterator for end of reversed nonmutable sequence
; 1291 : 		return (const_reverse_iterator(begin()));
; 1292 : 		}
; 1293 : 
; 1294 : 	const_iterator cbegin() const _NOEXCEPT
; 1295 : 		{	// return iterator for beginning of nonmutable sequence
; 1296 : 		return (((const _Myt *)this)->begin());
; 1297 : 		}
; 1298 : 
; 1299 : 	const_iterator cend() const _NOEXCEPT
; 1300 : 		{	// return iterator for end of nonmutable sequence
; 1301 : 		return (((const _Myt *)this)->end());
; 1302 : 		}
; 1303 : 
; 1304 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1306 : 		return (((const _Myt *)this)->rbegin());
; 1307 : 		}
; 1308 : 
; 1309 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1310 : 		{	// return iterator for end of reversed nonmutable sequence
; 1311 : 		return (((const _Myt *)this)->rend());
; 1312 : 		}
; 1313 : 
; 1314 : 	void shrink_to_fit()
; 1315 : 		{	// reduce capacity
; 1316 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize;
; 1317 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1318 : 
; 1319 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1320 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1321 : 
; 1322 : 		if ((empty() && 0 < this->_Mapsize)
; 1323 : 			|| (!empty()
; 1324 : 				&& size() <= _Newcapacity
; 1325 : 				&& _Newcapacity < _Oldcapacity))
; 1326 : 			{	// worth shrinking, do it
; 1327 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1328 : 				_STD make_move_iterator(end()));
; 1329 : 			swap(_Tmp);
; 1330 : 			}
; 1331 : 		}
; 1332 : 
; 1333 : 	void resize(size_type _Newsize)
; 1334 : 		{	// determine new length, padding as needed
; 1335 : 		while (this->_Mysize < _Newsize)
; 1336 : 			emplace_back();
; 1337 : 
; 1338 : 		while (_Newsize < this->_Mysize)
; 1339 : 			pop_back();
; 1340 : 		}
; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rcx+32], rsi

; 1828 : 		_Alpty _Almap(this->_Getal());
; 1829 : 		while (!empty())

	je	SHORT $LN5@Tidy
	npad	6
$LL6@Tidy:

; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	rdx, QWORD PTR [rbx+24]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rax, QWORD PTR [rbx+16]

; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	dec	rdx

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	dec	rax

; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	add	rdx, QWORD PTR [rbx+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	and	rdx, rax

; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	rax, QWORD PTR [rbx+8]
	mov	rdi, QWORD PTR [rax+rdx*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rdi+48], 16
	jb	SHORT $LN51@Tidy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdi+24]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN51@Tidy:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+40], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi+24], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1491 : 		if (--this->_Mysize == 0)

	dec	QWORD PTR [rbx+32]
	jne	SHORT $LN13@Tidy

; 1492 : 			this->_Myoff = 0;

	mov	QWORD PTR [rbx+24], rsi
$LN13@Tidy:

; 783  : 		}
; 784  : 
; 785  : 	_Mapptr _Map;		// pointer to array of pointers to blocks
; 786  : 	size_type _Mapsize;	// size of map array, zero or 2^N
; 787  : 	size_type _Myoff;	// offset of initial element
; 788  : 	size_type _Mysize;	// current length of sequence
; 789  : 	};
; 790  : 
; 791  : 		// TEMPLATE CLASS _Deque_alloc
; 792  : template<bool _Al_has_storage,
; 793  : 	class _Alloc_types>
; 794  : 	class _Deque_alloc
; 795  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 796  : 	{	// base class for deque to hold allocator with storage
; 797  : public:
; 798  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 799  : 
; 800  : 	typedef _Deque_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 801  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 802  : 	typedef typename _Alloc_types::_Alty _Alty;
; 803  : 
; 804  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 805  : 
; 806  : 	_Deque_alloc(const _Alloc& _Al = _Alloc())
; 807  : 		: _Alval(_Al)
; 808  : 		{	// construct allocators from _Al
; 809  : 		_Alloc_proxy();
; 810  : 		}
; 811  : 
; 812  : 	~_Deque_alloc() _NOEXCEPT
; 813  : 		{	// destroy proxy
; 814  : 		_Free_proxy();
; 815  : 		}
; 816  : 
; 817  : 	void _Change_alloc(const _Alty& _Al)
; 818  : 		{	// replace old allocator
; 819  : 		_Free_proxy();
; 820  : 		this->_Alval = _Al;
; 821  : 		_Alloc_proxy();
; 822  : 		}
; 823  : 
; 824  : 	void _Swap_alloc(_Myt& _Right)
; 825  : 		{	// swap allocators
; 826  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 827  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 828  : 		}
; 829  : 
; 830  : 	void _Alloc_proxy()
; 831  : 		{	// construct proxy from _Alval
; 832  : 		typename _Alty::template rebind<_Container_proxy>::other
; 833  : 			_Alproxy(this->_Alval);
; 834  : 		this->_Myproxy = _Alproxy.allocate(1);
; 835  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 836  : 		this->_Myproxy->_Mycont = this;
; 837  : 		}
; 838  : 
; 839  : 	void _Free_proxy()
; 840  : 		{	// destroy proxy
; 841  : 		typename _Alty::template rebind<_Container_proxy>::other
; 842  : 			_Alproxy(this->_Alval);
; 843  : 		this->_Orphan_all();
; 844  : 		_Alproxy.destroy(this->_Myproxy);
; 845  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 846  : 		this->_Myproxy = 0;
; 847  : 		}
; 848  : 
; 849  : 	_Alty& _Getal()
; 850  : 		{	// get reference to allocator
; 851  : 		return (this->_Alval);
; 852  : 		}
; 853  : 
; 854  : 	const _Alty& _Getal() const
; 855  : 		{	// get reference to allocator
; 856  : 		return (this->_Alval);
; 857  : 		}
; 858  : 	};
; 859  : 
; 860  : template<class _Alloc_types>
; 861  : 	class _Deque_alloc<false, _Alloc_types>
; 862  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 863  : 	{	// base class for deque to hold allocator with no storage
; 864  : public:
; 865  : 	typedef _Deque_alloc<false, _Alloc_types> _Myt;
; 866  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 867  : 
; 868  : 	typedef typename _Alloc_types::_Alty _Alty;
; 869  : 
; 870  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 871  : 
; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())
; 873  : 		{	// construct allocators from _Al
; 874  : 		_Alloc_proxy();
; 875  : 		}
; 876  : 
; 877  : 	~_Deque_alloc() _NOEXCEPT
; 878  : 		{	// destroy proxy
; 879  : 		_Free_proxy();
; 880  : 		}
; 881  : 
; 882  : 	void _Change_alloc(const _Alty&)
; 883  : 		{	// replace old allocator
; 884  : 		}
; 885  : 
; 886  : 	void _Swap_alloc(_Myt& _Right)
; 887  : 		{	// swap allocators
; 888  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 889  : 		}
; 890  : 
; 891  : 	void _Alloc_proxy()
; 892  : 		{	// construct proxy from _Alval
; 893  : 		typename _Alty::template rebind<_Container_proxy>::other
; 894  : 			_Alproxy;
; 895  : 		this->_Myproxy = _Alproxy.allocate(1);
; 896  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 897  : 		this->_Myproxy->_Mycont = this;
; 898  : 		}
; 899  : 
; 900  : 	void _Free_proxy()
; 901  : 		{	// destroy proxy
; 902  : 		typename _Alty::template rebind<_Container_proxy>::other
; 903  : 			_Alproxy;
; 904  : 		this->_Orphan_all();
; 905  : 		_Alproxy.destroy(this->_Myproxy);
; 906  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 907  : 		this->_Myproxy = 0;
; 908  : 		}
; 909  : 
; 910  : 	_Alty _Getal() const
; 911  : 		{	// get reference to allocator
; 912  : 		return (_Alty());
; 913  : 		}
; 914  : 	};
; 915  : 
; 916  : 		// TEMPLATE CLASS deque
; 917  : template<class _Ty,
; 918  : 	class _Alloc = allocator<_Ty> >
; 919  : 	class deque
; 920  : 		: public _Deque_alloc<!is_empty<_Alloc>::value,
; 921  : 			_Deque_base_types<_Ty, _Alloc> >
; 922  : 	{	// circular queue of pointers to blocks
; 923  : public:
; 924  : 	typedef deque<_Ty, _Alloc> _Myt;
; 925  : 	typedef _Deque_alloc<!is_empty<_Alloc>::value,
; 926  : 		_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 927  : 	typedef _Alloc allocator_type;
; 928  : 
; 929  : 	typedef typename _Mybase::_Alty _Alty;
; 930  : 	typedef typename _Mybase::_Alpty _Alpty;
; 931  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 932  : 
; 933  : 	typedef typename _Mybase::value_type value_type;
; 934  : 	typedef typename _Mybase::size_type size_type;
; 935  : 	typedef typename _Mybase::difference_type difference_type;
; 936  : 	typedef typename _Mybase::pointer pointer;
; 937  : 	typedef typename _Mybase::const_pointer const_pointer;
; 938  : 	typedef typename _Mybase::reference reference;
; 939  : 	typedef typename _Mybase::const_reference const_reference;
; 940  : 
; 941  : 	typedef typename _Mybase::iterator iterator;
; 942  : 	typedef typename _Mybase::const_iterator const_iterator;
; 943  : 
; 944  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 945  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 946  : 
; 947  : 	static const int _EEM_DS = _DEQUESIZ;
; 948  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 949  : 	deque()
; 950  : 		: _Mybase()
; 951  : 		{	// construct empty deque
; 952  : 		}
; 953  : 
; 954  : 	explicit deque(const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct empty deque with allocator
; 957  : 		}
; 958  : 
; 959  : 	explicit deque(size_type _Count)
; 960  : 		: _Mybase()
; 961  : 		{	// construct from _Count * value_type()
; 962  : 		resize(_Count);
; 963  : 		}
; 964  : 
; 965  : 	deque(size_type _Count, const value_type& _Val)
; 966  : 		: _Mybase()
; 967  : 		{	// construct from _Count * _Val
; 968  : 		_Construct_n(_Count, _Val);
; 969  : 		}
; 970  : 
; 971  : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 972  : 		: _Mybase(_Al)
; 973  : 		{	// construct from _Count * _Val with allocator
; 974  : 		_Construct_n(_Count, _Val);
; 975  : 		}
; 976  : 
; 977  : 	deque(const _Myt& _Right)
; 978  : 
; 979  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 980  : 
; 981  : 
; 982  : 		{	// construct by copying _Right
; 983  : 		_Construct(_Right.begin(), _Right.end());
; 984  : 		}
; 985  : 
; 986  : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 987  : 		: _Mybase(_Al)
; 988  : 		{	// construct by copying _Right
; 989  : 		_Construct(_Right.begin(), _Right.end());
; 990  : 		}
; 991  : 
; 992  : 	template<class _Iter,
; 993  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 994  : 			void>::type>
; 995  : 		deque(_Iter _First, _Iter _Last)
; 996  : 		: _Mybase()
; 997  : 		{	// construct from [_First, _Last)
; 998  : 		_Construct(_First, _Last);
; 999  : 		}
; 1000 : 
; 1001 : 	template<class _Iter,
; 1002 : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 1003 : 			void>::type>
; 1004 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 1005 : 		: _Mybase(_Al)
; 1006 : 		{	// construct from [_First, _Last) with allocator
; 1007 : 		_Construct(_First, _Last);
; 1008 : 		}
; 1009 : 
; 1010 : 	template<class _Iter>
; 1011 : 		void _Construct(_Iter _First, _Iter _Last)
; 1012 : 		{	// initialize from [_First, _Last), input iterators
; 1013 : 		_TRY_BEGIN
; 1014 : 
; 1015 : 		for (; _First != _Last; ++_First)
; 1016 : 			emplace_back(*_First);
; 1017 : 
; 1018 : 		_CATCH_ALL
; 1019 : 		_Tidy();
; 1020 : 		_RERAISE;
; 1021 : 		_CATCH_END
; 1022 : 		}
; 1023 : 
; 1024 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1025 : 		{	// construct from _Count * _Val
; 1026 : 		_TRY_BEGIN
; 1027 : 		for (; 0 < _Count; --_Count)
; 1028 : 			push_back(_Val);
; 1029 : 		_CATCH_ALL
; 1030 : 		_Tidy();
; 1031 : 		_RERAISE;
; 1032 : 		_CATCH_END
; 1033 : 		}
; 1034 : 
; 1035 : #define _PUSH_FRONT_BEGIN \
; 1036 : 	if (this->_Myoff % _DEQUESIZ == 0 \
; 1037 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1038 : 		_Growmap(1); \
; 1039 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1040 : 	size_type _Newoff = this->_Myoff != 0 ? this->_Myoff \
; 1041 : 		: this->_Mapsize * _DEQUESIZ; \
; 1042 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1043 : 	if (this->_Map[_Block] == pointer()) \
; 1044 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1045 : 
; 1046 : #define _PUSH_FRONT_END \
; 1047 : 	this->_Myoff = _Newoff; \
; 1048 : 	++this->_Mysize
; 1049 : 
; 1050 : #define _PUSH_BACK_BEGIN \
; 1051 : 	if ((this->_Myoff + this->_Mysize) % _DEQUESIZ == 0 \
; 1052 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1053 : 		_Growmap(1); \
; 1054 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1055 : 	size_type _Newoff = this->_Myoff + this->_Mysize; \
; 1056 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1057 : 	if (this->_Map[_Block] == pointer()) \
; 1058 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1059 : 
; 1060 : #define _PUSH_BACK_END \
; 1061 : 	++this->_Mysize
; 1062 : 
; 1063 : 	deque(_Myt&& _Right)
; 1064 : 		: _Mybase(_Right._Getal())
; 1065 : 		{	// construct by moving _Right
; 1066 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1067 : 		}
; 1068 : 
; 1069 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1070 : 		: _Mybase(_Al)
; 1071 : 		{	// construct by moving _Right
; 1072 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1073 : 		}
; 1074 : 
; 1075 : 	_Myt& operator=(_Myt&& _Right)
; 1076 : 		{	// assign by moving _Right
; 1077 : 		if (this != &_Right)
; 1078 : 			{	// different, assign it
; 1079 : 			_Tidy();
; 1080 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1081 : 				&& this->_Getal() != _Right._Getal())
; 1082 : 				this->_Change_alloc(_Right._Getal());
; 1083 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1084 : 			}
; 1085 : 		return (*this);
; 1086 : 		}
; 1087 : 
; 1088 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1089 : 		{	// move from _Right, stealing its contents
; 1090 : 		this->_Swap_all((_Myt&)_Right);
; 1091 : 		this->_Map = _Right._Map;
; 1092 : 		this->_Mapsize = _Right._Mapsize;
; 1093 : 		this->_Myoff = _Right._Myoff;
; 1094 : 		this->_Mysize = _Right._Mysize;
; 1095 : 
; 1096 : 		_Right._Map = _Mapptr();
; 1097 : 		_Right._Mapsize = 0;
; 1098 : 		_Right._Myoff = 0;
; 1099 : 		_Right._Mysize = 0;
; 1100 : 		}
; 1101 : 
; 1102 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1103 : 		{	// move from _Right, possibly moving its contents
; 1104 : 		if (get_allocator() == _Right.get_allocator())
; 1105 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1106 : 		else
; 1107 : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 1108 : 				_STD make_move_iterator(_Right.end()));
; 1109 : 		}
; 1110 : 
; 1111 : 	void _Assign_rv(_Myt&& _Right)
; 1112 : 		{	// assign by moving _Right
; 1113 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1114 : 			typename _Alty::propagate_on_container_move_assignment());
; 1115 : 		}
; 1116 : 
; 1117 : 
; 1118 : 	void push_front(value_type&& _Val)
; 1119 : 		{	// insert element at beginning
; 1120 : 		this->_Orphan_all();
; 1121 : 		_PUSH_FRONT_BEGIN;
; 1122 : 		this->_Getal().construct(
; 1123 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1124 : 			_STD forward<value_type>(_Val));
; 1125 : 		_PUSH_FRONT_END;
; 1126 : 		}
; 1127 : 
; 1128 : 	void push_back(value_type&& _Val)
; 1129 : 		{	// insert element at end
; 1130 : 		this->_Orphan_all();
; 1131 : 		_PUSH_BACK_BEGIN;
; 1132 : 		this->_Getal().construct(
; 1133 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 			_STD forward<value_type>(_Val));
; 1135 : 		_PUSH_BACK_END;
; 1136 : 		}
; 1137 : 
; 1138 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1139 : 		{	// insert _Val at _Where
; 1140 : 		return (emplace(_Where, _STD move(_Val)));
; 1141 : 		}
; 1142 : 
; 1143 : 	template<class... _Valty>
; 1144 : 		void emplace_front(_Valty&&... _Val)
; 1145 : 		{	// insert element at beginning
; 1146 : 		this->_Orphan_all();
; 1147 : 		_PUSH_FRONT_BEGIN;
; 1148 : 		this->_Getal().construct(
; 1149 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1150 : 			_STD forward<_Valty>(_Val)...);
; 1151 : 		_PUSH_FRONT_END;
; 1152 : 		}
; 1153 : 
; 1154 : 	template<class... _Valty>
; 1155 : 		void emplace_back(_Valty&&... _Val)
; 1156 : 		{	// insert element at end
; 1157 : 		this->_Orphan_all();
; 1158 : 		_PUSH_BACK_BEGIN;
; 1159 : 		this->_Getal().construct(
; 1160 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1161 : 			_STD forward<_Valty>(_Val)...);
; 1162 : 		_PUSH_BACK_END;
; 1163 : 		}
; 1164 : 
; 1165 : 	template<class... _Valty>
; 1166 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1167 : 		{	// insert element at _Where
; 1168 : 		size_type _Off = _Where - begin();
; 1169 : 
; 1170 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1171 : 		if (this->_Mysize < _Off)
; 1172 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1173 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1174 : 
; 1175 : 		if (_Off <= this->_Mysize / 2)
; 1176 : 			{	// closer to front, push to front then rotate
; 1177 : 			emplace_front(_STD forward<_Valty>(_Val)...);
; 1178 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off);
; 1179 : 			}
; 1180 : 		else
; 1181 : 			{	// closer to back, push to back then rotate
; 1182 : 			emplace_back(_STD forward<_Valty>(_Val)...);
; 1183 : 			_STD rotate(begin() + _Off, end() - 1, end());
; 1184 : 			}
; 1185 : 		return (begin() + _Off);
; 1186 : 		}
; 1187 : 
; 1188 : 
; 1189 : 	deque(_XSTD initializer_list<value_type> _Ilist,
; 1190 : 		const _Alloc& _Al = allocator_type())
; 1191 : 		: _Mybase(_Al)
; 1192 : 		{	// construct from initializer_list
; 1193 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1194 : 		}
; 1195 : 
; 1196 : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 1197 : 		{	// assign initializer_list
; 1198 : 		assign(_Ilist.begin(), _Ilist.end());
; 1199 : 		return (*this);
; 1200 : 		}
; 1201 : 
; 1202 : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 1203 : 		{	// assign initializer_list
; 1204 : 		assign(_Ilist.begin(), _Ilist.end());
; 1205 : 		}
; 1206 : 
; 1207 : 	iterator insert(const_iterator _Where,
; 1208 : 		_XSTD initializer_list<value_type> _Ilist)
; 1209 : 		{	// insert initializer_list
; 1210 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1211 : 		}
; 1212 : 
; 1213 : 	~deque() _NOEXCEPT
; 1214 : 		{	// destroy the deque
; 1215 : 		_Tidy();
; 1216 : 		}
; 1217 : 
; 1218 : 	_Myt& operator=(const _Myt& _Right)
; 1219 : 		{	// assign _Right
; 1220 : 		if (this != &_Right)
; 1221 : 			{	// different, assign it
; 1222 : 			if (this->_Getal() != _Right._Getal()
; 1223 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1224 : 				{	// change allocator before copying
; 1225 : 				_Tidy();
; 1226 : 				this->_Change_alloc(_Right._Getal());
; 1227 : 				}
; 1228 : 
; 1229 : 			this->_Orphan_all();
; 1230 : 
; 1231 : 			if (_Right._Mysize == 0)
; 1232 : 				clear();
; 1233 : 			else if (_Right._Mysize <= this->_Mysize)
; 1234 : 				{	// enough elements, copy new and destroy old
; 1235 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1236 : 					begin());
; 1237 : 				erase(_Mid, end());
; 1238 : 				}
; 1239 : 			else
; 1240 : 				{	// new sequence longer, copy and construct new
; 1241 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;
; 1242 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1243 : 				insert(end(), _Mid, _Right.end());
; 1244 : 				}
; 1245 : 			}
; 1246 : 		return (*this);
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator begin() _NOEXCEPT
; 1250 : 		{	// return iterator for beginning of mutable sequence
; 1251 : 		return (iterator(this->_Myoff, this));
; 1252 : 		}
; 1253 : 
; 1254 : 	const_iterator begin() const _NOEXCEPT
; 1255 : 		{	// return iterator for beginning of nonmutable sequence
; 1256 : 		return (const_iterator(this->_Myoff, this));
; 1257 : 		}
; 1258 : 
; 1259 : 	iterator end() _NOEXCEPT
; 1260 : 		{	// return iterator for end of mutable sequence
; 1261 : 		return (iterator(this->_Myoff + this->_Mysize, this));
; 1262 : 		}
; 1263 : 
; 1264 : 	const_iterator end() const _NOEXCEPT
; 1265 : 		{	// return iterator for end of nonmutable sequence
; 1266 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));
; 1267 : 		}
; 1268 : 
; 1269 : 	iterator _Make_iter(const_iterator _Where) const
; 1270 : 		{	// make iterator from const_iterator
; 1271 : 		return (iterator(_Where._Myoff, this));
; 1272 : 		}
; 1273 : 
; 1274 : 	reverse_iterator rbegin() _NOEXCEPT
; 1275 : 		{	// return iterator for beginning of reversed mutable sequence
; 1276 : 		return (reverse_iterator(end()));
; 1277 : 		}
; 1278 : 
; 1279 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1280 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1281 : 		return (const_reverse_iterator(end()));
; 1282 : 		}
; 1283 : 
; 1284 : 	reverse_iterator rend() _NOEXCEPT
; 1285 : 		{	// return iterator for end of reversed mutable sequence
; 1286 : 		return (reverse_iterator(begin()));
; 1287 : 		}
; 1288 : 
; 1289 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1290 : 		{	// return iterator for end of reversed nonmutable sequence
; 1291 : 		return (const_reverse_iterator(begin()));
; 1292 : 		}
; 1293 : 
; 1294 : 	const_iterator cbegin() const _NOEXCEPT
; 1295 : 		{	// return iterator for beginning of nonmutable sequence
; 1296 : 		return (((const _Myt *)this)->begin());
; 1297 : 		}
; 1298 : 
; 1299 : 	const_iterator cend() const _NOEXCEPT
; 1300 : 		{	// return iterator for end of nonmutable sequence
; 1301 : 		return (((const _Myt *)this)->end());
; 1302 : 		}
; 1303 : 
; 1304 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1306 : 		return (((const _Myt *)this)->rbegin());
; 1307 : 		}
; 1308 : 
; 1309 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1310 : 		{	// return iterator for end of reversed nonmutable sequence
; 1311 : 		return (((const _Myt *)this)->rend());
; 1312 : 		}
; 1313 : 
; 1314 : 	void shrink_to_fit()
; 1315 : 		{	// reduce capacity
; 1316 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize;
; 1317 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1318 : 
; 1319 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1320 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1321 : 
; 1322 : 		if ((empty() && 0 < this->_Mapsize)
; 1323 : 			|| (!empty()
; 1324 : 				&& size() <= _Newcapacity
; 1325 : 				&& _Newcapacity < _Oldcapacity))
; 1326 : 			{	// worth shrinking, do it
; 1327 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1328 : 				_STD make_move_iterator(end()));
; 1329 : 			swap(_Tmp);
; 1330 : 			}
; 1331 : 		}
; 1332 : 
; 1333 : 	void resize(size_type _Newsize)
; 1334 : 		{	// determine new length, padding as needed
; 1335 : 		while (this->_Mysize < _Newsize)
; 1336 : 			emplace_back();
; 1337 : 
; 1338 : 		while (_Newsize < this->_Mysize)
; 1339 : 			pop_back();
; 1340 : 		}
; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+32], rsi

; 1828 : 		_Alpty _Almap(this->_Getal());
; 1829 : 		while (!empty())

	jne	SHORT $LL6@Tidy
$LN5@Tidy:

; 1831 : 		for (size_type _Block = this->_Mapsize; 0 < _Block; )

	mov	rdi, QWORD PTR [rbx+16]
	test	rdi, rdi
	je	SHORT $LN3@Tidy
	npad	9
$LL4@Tidy:

; 1832 : 			{	// free storage for a block and destroy pointer
; 1833 : 			if (this->_Map[--_Block] != pointer())

	mov	rax, QWORD PTR [rbx+8]
	dec	rdi
	mov	rcx, QWORD PTR [rax+rdi*8]
	test	rcx, rcx
	je	SHORT $LN2@Tidy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN2@Tidy:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1831 : 		for (size_type _Block = this->_Mapsize; 0 < _Block; )

	test	rdi, rdi
	jne	SHORT $LL4@Tidy
$LN3@Tidy:

; 1834 : 				{	// free block and destroy its pointer
; 1835 : 				this->_Getal().deallocate(this->_Map[_Block], _DEQUESIZ);
; 1836 : 				this->_Getal().destroy(&this->_Map[_Block]);
; 1837 : 				}
; 1838 : 			}
; 1839 : 
; 1840 : 		if (this->_Map != _Mapptr())

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN81@Tidy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN81@Tidy:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1844 : 		this->_Map = _Mapptr();

	mov	QWORD PTR [rbx+8], rsi
	mov	QWORD PTR [rbx+16], rsi

; 1845 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Tidy@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAXXZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAA@XZ PROC ; std::allocator<Json::OurReader::ErrorInfo>::allocator<Json::OurReader::ErrorInfo>, COMDAT

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAA@XZ ENDP ; std::allocator<Json::OurReader::ErrorInfo>::allocator<Json::OurReader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@OurReader@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@OurReader@Json@@@1@@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >, COMDAT

; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())

$LN43:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	eax, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())

	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rax

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rax

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rax

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	lea	ecx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN14@Deque_allo

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN14@Deque_allo:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx

; 873  : 		{	// construct allocators from _Al
; 874  : 		_Alloc_proxy();
; 875  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN42@Deque_allo:
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VErrorInfo@OurReader@Json@@@1@@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >, COMDAT

; 878  : 		{	// destroy proxy

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 907  : 		this->_Myproxy = 0;

	mov	QWORD PTR [rbx], 0

; 879  : 		_Free_proxy();
; 880  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::~_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Getal, COMDAT

; 912  : 		return (_Alty());

	mov	rax, rdx

; 913  : 		}

	ret	0
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::allocate, COMDAT

; 846  : 		{	// allocate array of _Count elements

$LN16:
	sub	rsp, 40					; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN1@allocate

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN1@allocate:

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN15@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_K_K@Z PROC ; std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >::_Getblock, COMDAT

; 781  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rax, QWORD PTR [rcx+16]
	dec	rax
	and	rax, rdx

; 783  : 		}

	ret	0
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_K_K@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
_Pdeque$ = 24
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 114  : 		{	// construct orphaned iterator

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 115  : 		}
; 116  : 
; 117  : 	_Iterator_base12(const _Iterator_base12& _Right)
; 118  : 		: _Myproxy(0), _Mynextiter(0)
; 119  : 		{	// copy an iterator
; 120  : 		*this = _Right;
; 121  : 		}
; 122  : 
; 123  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 124  : 		{	// assign an iterator
; 125  : 		if (_Myproxy == _Right._Myproxy)
; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);
; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

	test	r8, r8
	je	SHORT $LN11@Deque_cons

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
$LN11@Deque_cons:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 306  : 		}

	mov	rax, rcx
	mov	QWORD PTR [rcx+16], rdx
	ret	0
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator==, COMDAT

; 464  : 		_Compat(_Right);
; 465  : 		return (this->_Myoff == _Right._Myoff);

	mov	rdx, QWORD PTR [rdx+16]
	cmp	QWORD PTR [rcx+16], rdx
	sete	al

; 466  : 		}

	ret	0
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >, COMDAT
	ret	0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >::~_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >, COMDAT
	ret	0
??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >::~_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >, COMDAT
	ret	0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)

$LN40:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], 0

; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)

	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 768  : 		assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 769  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [rcx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1261 : 		return (iterator(this->_Myoff + this->_Mysize, this));

	mov	r8, QWORD PTR [rcx+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 114  : 		{	// construct orphaned iterator

	mov	QWORD PTR [rdx+8], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1261 : 		return (iterator(this->_Myoff + this->_Mysize, this));

	add	r8, QWORD PTR [rcx+24]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 171  : 			_Myproxy = _Parent_proxy;

	mov	QWORD PTR [rdx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1261 : 		return (iterator(this->_Myoff + this->_Mysize, this));

	mov	rax, rdx

; 305  : 		_Myoff = _Off;

	mov	QWORD PTR [rdx+16], r8

; 1262 : 		}

	ret	0
?end@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Count$dead$ = 72
?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z PROC ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Growmap, COMDAT

; 1772 : 		{	// grow map by at least _Count pointers, _Mapsize a power of 2

$LN169:
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H

; 1773 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1774 : 			"The _Xlen() test should always be performed.");
; 1775 : 
; 1776 : 		typedef typename _Alpty::pointer _Blockptr;
; 1777 : 		_Alpty _Almap(this->_Getal());
; 1778 : 		size_type _Newsize = 0 < this->_Mapsize ? this->_Mapsize : 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	ebx, 1
	mov	rbp, rcx
	test	rdx, rdx
	mov	rcx, 1152921504606846975		; 0fffffffffffffffH
	cmovne	rbx, rdx
$LL7@Growmap:

; 1779 : 		while (_Newsize - this->_Mapsize < _Count || _Newsize < _DEQUEMAPSIZ)

	mov	rax, rbx
	sub	rax, rdx
	cmp	rax, 1
	jb	SHORT $LN5@Growmap
	cmp	rbx, 8
	jae	SHORT $LN6@Growmap
$LN5@Growmap:

; 1780 : 			{	// scale _Newsize to 2^N >= _Mapsize + _Count
; 1781 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

	mov	rax, rcx
	sub	rax, rbx
	cmp	rax, rbx
	jb	$LN151@Growmap

; 1782 : 				_Xlen();	// result too long
; 1783 : 			_Newsize *= 2;

	add	rbx, rbx

; 1784 : 			}

	jmp	SHORT $LL7@Growmap
$LN6@Growmap:
	mov	QWORD PTR [rsp+88], r14

; 1787 : 		size_type _Myboff = this->_Myoff / _DEQUESIZ;

	mov	r14, QWORD PTR [rbp+24]
	sub	rbx, rdx

; 1788 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize + _Count);

	lea	rcx, QWORD PTR [rdx+rbx]
	mov	QWORD PTR [rsp+32], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

	xor	r15d, r15d
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1787 : 		size_type _Myboff = this->_Myoff / _DEQUESIZ;

	shr	r14, 1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

	test	rcx, rcx
	je	SHORT $LN32@Growmap

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN31@Growmap
	lea	rcx, QWORD PTR [rcx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	r15, rax
	test	rax, rax
	jne	SHORT $LN32@Growmap
$LN31@Growmap:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN32@Growmap:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1793 : 			_Myptr, _Almap);	// copy initial to end

	mov	rax, QWORD PTR [rbp+8]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, QWORD PTR [rbp+16]
	lea	rsi, QWORD PTR [r14*8]
	shl	rdi, 3
	lea	rdx, QWORD PTR [rsi+rax]
	lea	rcx, QWORD PTR [rsi+r15]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdi, rdx
	add	rdi, rax
	sar	rdi, 3

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rdi, QWORD PTR [rdi*8]
	mov	r8, rdi
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1798 : 				_Myptr, _Almap);	// copy rest of old

	mov	rdx, QWORD PTR [rbp+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	add	rax, rdi
	mov	rcx, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1794 : 		if (_Myboff <= _Count)

	cmp	r14, rbx
	ja	SHORT $LN3@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sar	rsi, 3
	mov	QWORD PTR [rsp+80], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1800 : 				_Almap);	// clear suffix of new

	mov	r12, rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rsi, QWORD PTR [rsi*8]
	mov	r8, rsi
	call	QWORD PTR __imp_memmove
	add	rax, rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1800 : 				_Almap);	// clear suffix of new

	sub	r12, r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	je	SHORT $LN81@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1798 : 				_Myptr, _Almap);	// copy rest of old

	mov	rdi, rax
	mov	rcx, r12
	xor	eax, eax
	rep stosq
$LN81@Growmap:
	mov	r12, QWORD PTR [rsp+80]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	r14, r14
	je	SHORT $LN139@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	mov	rdi, r15
	mov	rcx, r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1804 : 		else

	jmp	SHORT $LN167@Growmap
$LN3@Growmap:

; 1808 : 				_Myptr, _Almap);	// copy more old

	lea	rdi, QWORD PTR [rbx*8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	r8, rdi
	and	r8, -8
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1811 : 				_Newmap, _Almap);	// copy rest of old

	mov	rax, QWORD PTR [rbp+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	rcx, r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1811 : 				_Newmap, _Almap);	// copy rest of old

	lea	rdx, QWORD PTR [rdi+rax]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rsi, rdx
	add	rsi, rax
	sar	rsi, 3

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rsi, QWORD PTR [rsi*8]
	mov	r8, rsi
	call	QWORD PTR __imp_memmove
	add	rax, rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rbx, rbx
	je	SHORT $LN139@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1808 : 				_Myptr, _Almap);	// copy more old

	mov	rdi, rax
	mov	rcx, rbx
$LN167@Growmap:
	xor	eax, eax
	rep stosq
$LN139@Growmap:

; 1812 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1813 : 				_Almap);	// clear rest to initial block
; 1814 : 			}
; 1815 : 
; 1816 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1817 : 			_Almap);
; 1818 : 		if (this->_Map != _Mapptr())

	mov	rcx, QWORD PTR [rbp+8]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	test	rcx, rcx
	je	SHORT $LN144@Growmap
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN144@Growmap:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1823 : 		this->_Mapsize += _Count;

	add	QWORD PTR [rbp+16], rbx
	mov	r14, QWORD PTR [rsp+88]
	mov	QWORD PTR [rbp+8], r15
	mov	r15, QWORD PTR [rsp+32]

; 1824 : 		}

	add	rsp, 40					; 00000028H
	pop	rbp
	pop	rbx
	ret	0
$LN151@Growmap:

; 1763 : 		_Xlength_error("deque<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN168@Growmap:
?_Growmap@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEAAX_K@Z ENDP ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@PEAVValue@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@PEAVValue@Json@@@1@@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >, COMDAT

; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())

$LN43:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	eax, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())

	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rax

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rax

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rax

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	lea	ecx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN14@Deque_allo

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN14@Deque_allo:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx

; 873  : 		{	// construct allocators from _Al
; 874  : 		_Alloc_proxy();
; 875  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN42@Deque_allo:
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV?$allocator@PEAVValue@Json@@@1@@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::_Deque_alloc<0,std::_Deque_base_types<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAPEAPEAVValue@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAPEAPEAVValue@Json@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64> >::allocate, COMDAT

; 846  : 		{	// allocate array of _Count elements

$LN16:
	sub	rsp, 40					; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN1@allocate

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN1@allocate:

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN15@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAPEAPEAVValue@Json@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT

; 1357 : 		return (this->_Getal().max_size());

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1358 : 		}

	ret	0
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEBAXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen, COMDAT

; 1762 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1763 : 		_Xlength_error("deque<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEBAXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::allocate, COMDAT

; 577  : 		{	// allocate array of _Count elements

$LN13:
	sub	rsp, 40					; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN1@allocate

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN1@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN12@allocate:
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAPEAVErrorInfo@Reader@Json@@_K@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy, COMDAT

; 892  : 		{	// construct proxy from _Alval

$LN36:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN8@Alloc_prox

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN8@Alloc_prox:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx

; 898  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN35@Alloc_prox:
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> >::allocate, COMDAT

; 846  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;

	xor	eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

	test	rdx, rdx
	je	SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN5@allocate
	lea	rcx, QWORD PTR [rdx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN6@allocate
$LN5@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN14@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rax

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rax

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rax

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rax

; 777  : 		}

	mov	rax, rcx
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?max_size@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::max_size, COMDAT

; 1357 : 		return (this->_Getal().max_size());

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1358 : 		}

	ret	0
?max_size@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?empty@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_NXZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::empty, COMDAT

; 1362 : 		return (this->_Mysize == 0);

	xor	eax, eax
	cmp	QWORD PTR [rcx+32], rax
	sete	al

; 1363 : 		}

	ret	0
?empty@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_NXZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEBAXXZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Xlen, COMDAT

; 1762 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1763 : 		_Xlength_error("deque<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEBAXXZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z PROC ; std::allocator<Json::OurReader::ErrorInfo>::allocate, COMDAT

; 577  : 		{	// allocate array of _Count elements

$LN13:
	sub	rsp, 40					; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN1@allocate

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN1@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN12@allocate:
?allocate@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAPEAVErrorInfo@OurReader@Json@@_K@Z ENDP ; std::allocator<Json::OurReader::ErrorInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Alloc_proxy, COMDAT

; 892  : 		{	// construct proxy from _Alval

$LN36:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN8@Alloc_prox

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN8@Alloc_prox:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx

; 898  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN35@Alloc_prox:
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Free_proxy, COMDAT

; 901  : 		{	// destroy proxy

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 907  : 		this->_Myproxy = 0;

	mov	QWORD PTR [rbx], 0

; 908  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >, COMDAT

; 802  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::deallocate, COMDAT

; 573  : 		::operator delete(_Ptr);

	mov	rcx, rdx
	rex_jmp	QWORD PTR __imp_??3@YAXPEAX@Z
?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> >::allocate, COMDAT

; 846  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;

	xor	eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

	test	rdx, rdx
	je	SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN5@allocate
	lea	rcx, QWORD PTR [rdx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN6@allocate
$LN5@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN14@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> >::deallocate, COMDAT

; 573  : 		::operator delete(_Ptr);

	mov	rcx, rdx
	rex_jmp	QWORD PTR __imp_??3@YAXPEAX@Z
?deallocate@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rax

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rax

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rax

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rax

; 777  : 		}

	mov	rax, rcx
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::_Compat, COMDAT

; 527  : 		}

	ret	0
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Pdeque$ = 16
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::_Setcont, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 149  : 		if (_Parent == 0)

	test	rdx, rdx
	je	SHORT $LN3@Setcont

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN3@Setcont:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 532  : 		}

	ret	0
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@OurReader@Json@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::OurReader::ErrorInfo> > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBAAEAPEAVValue@Json@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBAAEAPEAVValue@Json@@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator*, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	jne	SHORT $LN7@operator
	xor	r8d, r8d
	jmp	SHORT $LN8@operator
$LN7@operator:
	mov	r8, QWORD PTR [rax]
$LN8@operator:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [r8+16]
	dec	rax
	mov	rcx, rdx

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	shr	rcx, 1
	and	rcx, rax

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rax, QWORD PTR [rax+rcx*8]
	lea	rax, QWORD PTR [rax+rdx*8]

; 603  : 		return ((reference)**(_Mybase *)this);
; 604  : 		}

	ret	0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBAAEAPEAVValue@Json@@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$dead$ = 24
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	r8, QWORD PTR [rcx]

; 119  : 		{	// copy an iterator

	xor	r9d, r9d
	mov	eax, r9d

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	r8, r8
	je	SHORT $LN15@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	r8, QWORD PTR [r8]

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

	test	r8, r8
	je	SHORT $LN15@operator

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [r8]
$LN15@operator:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 639  : 		this->_Myoff += _Off;

	mov	rcx, QWORD PTR [rcx+16]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 119  : 		{	// copy an iterator

	mov	QWORD PTR [rdx], r9
	mov	QWORD PTR [rdx+8], r9
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 639  : 		this->_Myoff += _Off;

	dec	rcx
	mov	QWORD PTR [rdx+16], rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	rax, rax
	je	SHORT $LN43@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	rax, QWORD PTR [rax]

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

	test	rax, rax
	je	SHORT $LN43@operator

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rdx], rax
$LN43@operator:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 657  : 		return (_Tmp -= _Off);

	mov	rax, rdx

; 658  : 		}

	ret	0
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >, COMDAT

; 119  : 		{	// copy an iterator

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 120  : 		*this = _Right;
; 121  : 		}
; 122  : 
; 123  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 124  : 		{	// assign an iterator
; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN13@Deque_iter

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	rax, QWORD PTR [rax]

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

	test	rax, rax
	je	SHORT $LN13@Deque_iter

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
$LN13@Deque_iter:
	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >, COMDAT

; 119  : 		{	// copy an iterator

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 120  : 		*this = _Right;
; 121  : 		}
; 122  : 
; 123  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 124  : 		{	// assign an iterator
; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN11@Deque_cons

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	rax, QWORD PTR [rax]

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

	test	rax, rax
	je	SHORT $LN11@Deque_cons

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
$LN11@Deque_cons:
	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?max_size@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ PROC ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::max_size, COMDAT

; 1357 : 		return (this->_Getal().max_size());

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1358 : 		}

	ret	0
?max_size@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ ENDP ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEBAXXZ PROC ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Xlen, COMDAT

; 1762 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1763 : 		_Xlength_error("deque<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$deque@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@IEBAXXZ ENDP ; std::deque<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PEAVValue@Json@@@std@@QEAAPEAPEAVValue@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@PEAVValue@Json@@@std@@QEAAPEAPEAVValue@Json@@_K@Z PROC ; std::allocator<Json::Value * __ptr64>::allocate, COMDAT

; 577  : 		{	// allocate array of _Count elements

$LN13:
	sub	rsp, 40					; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN1@allocate

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN1@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN12@allocate:
?allocate@?$allocator@PEAVValue@Json@@@std@@QEAAPEAPEAVValue@Json@@_K@Z ENDP ; std::allocator<Json::Value * __ptr64>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::_Alloc_proxy, COMDAT

; 892  : 		{	// construct proxy from _Alval

$LN36:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN8@Alloc_prox

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN8@Alloc_prox:
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rbx

; 898  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN35@Alloc_prox:
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PEAVValue@Json@@V?$allocator@PEAVValue@Json@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<Json::Value * __ptr64,std::allocator<Json::Value * __ptr64> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> >::allocate, COMDAT

; 846  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;

	xor	eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

	test	rdx, rdx
	je	SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN5@allocate
	lea	rcx, QWORD PTR [rdx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN6@allocate
$LN5@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN14@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> >::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> >, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

	mov	QWORD PTR [rcx+8], rax

; 774  : 		_Mapsize = 0;

	mov	QWORD PTR [rcx+16], rax

; 775  : 		_Myoff = 0;

	mov	QWORD PTR [rcx+24], rax

; 776  : 		_Mysize = 0;

	mov	QWORD PTR [rcx+32], rax

; 777  : 		}

	mov	rax, rcx
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> >::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT

; 884  : 		return (_Mytraits::max_size(*this));

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PEAVErrorInfo@Reader@Json@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAVErrorInfo@Reader@Json@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z PROC ; std::allocator<Json::Reader::ErrorInfo * __ptr64>::allocate, COMDAT

; 577  : 		{	// allocate array of _Count elements

$LN12:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;

	xor	eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

	test	rdx, rdx
	je	SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN3@allocate
	lea	rcx, QWORD PTR [rdx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN4@allocate
$LN3@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN11@allocate:
?allocate@?$allocator@PEAVErrorInfo@Reader@Json@@@std@@QEAAPEAPEAVErrorInfo@Reader@Json@@_K@Z ENDP ; std::allocator<Json::Reader::ErrorInfo * __ptr64>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@_K@Z PROC ; std::allocator<Json::OurReader::ErrorInfo>::deallocate, COMDAT

; 573  : 		::operator delete(_Ptr);

	mov	rcx, rdx
	rex_jmp	QWORD PTR __imp_??3@YAXPEAX@Z
?deallocate@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@_K@Z ENDP ; std::allocator<Json::OurReader::ErrorInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::max_size, COMDAT

; 884  : 		return (_Mytraits::max_size(*this));

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@_K@Z PROC ; std::allocator<Json::OurReader::ErrorInfo * __ptr64>::deallocate, COMDAT

; 573  : 		::operator delete(_Ptr);

	mov	rcx, rdx
	rex_jmp	QWORD PTR __imp_??3@YAXPEAX@Z
?deallocate@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@_K@Z ENDP ; std::allocator<Json::OurReader::ErrorInfo * __ptr64>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z PROC ; std::allocator<Json::OurReader::ErrorInfo * __ptr64>::allocate, COMDAT

; 577  : 		{	// allocate array of _Count elements

$LN12:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;

	xor	eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

	test	rdx, rdx
	je	SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN3@allocate
	lea	rcx, QWORD PTR [rdx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN4@allocate
$LN3@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN11@allocate:
?allocate@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAAPEAPEAVErrorInfo@OurReader@Json@@_K@Z ENDP ; std::allocator<Json::OurReader::ErrorInfo * __ptr64>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
_Pdeque$ = 24
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 114  : 		{	// construct orphaned iterator

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 115  : 		}
; 116  : 
; 117  : 	_Iterator_base12(const _Iterator_base12& _Right)
; 118  : 		: _Myproxy(0), _Mynextiter(0)
; 119  : 		{	// copy an iterator
; 120  : 		*this = _Right;
; 121  : 		}
; 122  : 
; 123  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 124  : 		{	// assign an iterator
; 125  : 		if (_Myproxy == _Right._Myproxy)
; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);
; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

	test	r8, r8
	je	SHORT $LN13@Deque_iter

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
$LN13@Deque_iter:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 586  : 		}

	mov	rax, rcx

; 305  : 		_Myoff = _Off;

	mov	QWORD PTR [rcx+16], rdx

; 586  : 		}

	ret	0
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-=, COMDAT

; 639  : 		this->_Myoff += _Off;

	dec	QWORD PTR [rcx+16]

; 651  : 		return (*this += -_Off);

	mov	rax, rcx

; 652  : 		}

	ret	0
??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBAAEBQEAVValue@Json@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBAAEBQEAVValue@Json@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator*, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	jne	SHORT $LN5@operator
	xor	r8d, r8d
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	r8, QWORD PTR [rax]
$LN6@operator:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [r8+16]
	dec	rax
	mov	rcx, rdx

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 331  : 		_SCL_SECURE_OUT_OF_RANGE;
; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 1

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	shr	rcx, 1
	and	rcx, rax

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	rax, QWORD PTR [r8+8]
	mov	rax, QWORD PTR [rax+rcx*8]
	lea	rax, QWORD PTR [rax+rdx*8]

; 345  : 		}

	ret	0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEBAAEBQEAVValue@Json@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT

; 846  : 		{	// allocate array of _Count elements

$LN16:
	sub	rsp, 40					; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN1@allocate

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN1@allocate:

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN15@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64> >::max_size, COMDAT

; 884  : 		return (_Mytraits::max_size(*this));

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PEAPEAVValue@Json@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAPEAVValue@Json@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z PROC ; std::allocator<Json::Value * __ptr64 * __ptr64>::allocate, COMDAT

; 577  : 		{	// allocate array of _Count elements

$LN12:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;

	xor	eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

	test	rdx, rdx
	je	SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN3@allocate
	lea	rcx, QWORD PTR [rdx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN4@allocate
$LN3@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN11@allocate:
?allocate@?$allocator@PEAPEAVValue@Json@@@std@@QEAAPEAPEAPEAVValue@Json@@_K@Z ENDP ; std::allocator<Json::Value * __ptr64 * __ptr64>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA_KAEBV?$allocator@VErrorInfo@Reader@Json@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA_KAEBV?$allocator@VErrorInfo@Reader@Json@@@2@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 736  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA_KAEBV?$allocator@VErrorInfo@Reader@Json@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SA_KAEBV?$allocator@VErrorInfo@OurReader@Json@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SA_KAEBV?$allocator@VErrorInfo@OurReader@Json@@@2@@Z PROC ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 736  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SA_KAEBV?$allocator@VErrorInfo@OurReader@Json@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator+=, COMDAT

; 639  : 		this->_Myoff += _Off;

	dec	QWORD PTR [rcx+16]

; 640  : 		return (*this);

	mov	rax, rcx

; 641  : 		}

	ret	0
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
_Pdeque$ = 24
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 114  : 		{	// construct orphaned iterator

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 115  : 		}
; 116  : 
; 117  : 	_Iterator_base12(const _Iterator_base12& _Right)
; 118  : 		: _Myproxy(0), _Mynextiter(0)
; 119  : 		{	// copy an iterator
; 120  : 		*this = _Right;
; 121  : 		}
; 122  : 
; 123  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 124  : 		{	// assign an iterator
; 125  : 		if (_Myproxy == _Right._Myproxy)
; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);
; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

	test	r8, r8
	je	SHORT $LN11@Deque_cons

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
$LN11@Deque_cons:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 306  : 		}

	mov	rax, rcx
	mov	QWORD PTR [rcx+16], rdx
	ret	0
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT

; 577  : 		{	// allocate array of _Count elements

$LN13:
	sub	rsp, 40					; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 16
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN1@allocate

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN1@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN12@allocate:
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PEAVValue@Json@@@std@@@std@@SA_KAEBV?$allocator@PEAVValue@Json@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@PEAVValue@Json@@@std@@@std@@SA_KAEBV?$allocator@PEAVValue@Json@@@2@@Z PROC ; std::allocator_traits<std::allocator<Json::Value * __ptr64> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 736  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@PEAVValue@Json@@@std@@@std@@SA_KAEBV?$allocator@PEAVValue@Json@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value * __ptr64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QEBA_KXZ PROC ; std::allocator<Json::Reader::ErrorInfo>::max_size, COMDAT

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 613  : 		}

	ret	0
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QEBA_KXZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEBA_KXZ PROC ; std::allocator<Json::OurReader::ErrorInfo>::max_size, COMDAT

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 613  : 		}

	ret	0
?max_size@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEBA_KXZ ENDP ; std::allocator<Json::OurReader::ErrorInfo>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Pdeque$ = 16
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Setcont, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 149  : 		if (_Parent == 0)

	test	rdx, rdx
	je	SHORT $LN3@Setcont

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN3@Setcont:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 532  : 		}

	ret	0
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@PEAVValue@Json@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value * __ptr64> > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PEAVValue@Json@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@PEAVValue@Json@@@std@@QEBA_KXZ PROC ; std::allocator<Json::Value * __ptr64>::max_size, COMDAT

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 613  : 		}

	ret	0
?max_size@?$allocator@PEAVValue@Json@@@std@@QEBA_KXZ ENDP ; std::allocator<Json::Value * __ptr64>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AEAPEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z PROC ; std::move<Json::Value * __ptr64 & __ptr64>, COMDAT

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	rax, rcx

; 1521 : 	}

	ret	0
??$move@AEAPEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z ENDP ; std::move<Json::Value * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>, COMDAT

; 1155 : 		void emplace_back(_Valty&&... _Val)

$LN78:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1158 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rcx+32]
	mov	rbx, rcx
	inc	rax
	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN2@emplace_ba
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@emplace_ba:
	mov	r8, QWORD PTR [rbx+16]
	mov	rax, QWORD PTR [rbx+8]
	dec	r8
	and	QWORD PTR [rbx+24], r8
	mov	rdx, QWORD PTR [rbx+24]
	add	rdx, QWORD PTR [rbx+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	and	rdx, r8

; 1158 : 		_PUSH_BACK_BEGIN;

	lea	rdi, QWORD PTR [rdx*8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN1@emplace_ba
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	rcx, rax
	test	rax, rax
	jne	SHORT $LN16@emplace_ba

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN16@emplace_ba:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1158 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rax], rcx
$LN1@emplace_ba:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 588  : 		::new ((void *)_Ptr) _Ty();

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rdi+rax]
	test	rcx, rcx
	je	SHORT $LN32@emplace_ba
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx+24], 0
$LN32@emplace_ba:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1162 : 		_PUSH_BACK_END;

	inc	QWORD PTR [rbx+32]

; 1163 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN77@emplace_ba:
??$emplace_back@$$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@AEBV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV234@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VErrorInfo@Reader@Json@@AEBV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV234@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const & __ptr64>, COMDAT

; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	jmp	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct
??$construct@VErrorInfo@Reader@Json@@AEBV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV234@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??$emplace_back@$$$V@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??$emplace_back@$$$V@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ PROC ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::emplace_back<>, COMDAT

; 1155 : 		void emplace_back(_Valty&&... _Val)

$LN78:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1158 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rcx+32]
	mov	rbx, rcx
	inc	rax
	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN2@emplace_ba
	call	?_Growmap@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@IEAAX_K@Z ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::_Growmap
$LN2@emplace_ba:
	mov	r8, QWORD PTR [rbx+16]
	mov	rax, QWORD PTR [rbx+8]
	dec	r8
	and	QWORD PTR [rbx+24], r8
	mov	rdx, QWORD PTR [rbx+24]
	add	rdx, QWORD PTR [rbx+32]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

	and	rdx, r8

; 1158 : 		_PUSH_BACK_BEGIN;

	lea	rdi, QWORD PTR [rdx*8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN1@emplace_ba
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	rcx, rax
	test	rax, rax
	jne	SHORT $LN16@emplace_ba

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN16@emplace_ba:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1158 : 		_PUSH_BACK_BEGIN;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rax], rcx
$LN1@emplace_ba:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 588  : 		::new ((void *)_Ptr) _Ty();

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rdi+rax]
	test	rcx, rcx
	je	SHORT $LN32@emplace_ba
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx+24], 0
$LN32@emplace_ba:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1162 : 		_PUSH_BACK_END;

	inc	QWORD PTR [rbx+32]

; 1163 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN77@emplace_ba:
??$emplace_back@$$$V@?$deque@VErrorInfo@OurReader@Json@@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXXZ ENDP ; std::deque<Json::OurReader::ErrorInfo,std::allocator<Json::OurReader::ErrorInfo> >::emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@OurReader@Json@@AEBV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV234@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VErrorInfo@OurReader@Json@@AEBV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV234@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::construct<Json::OurReader::ErrorInfo,Json::OurReader::ErrorInfo const & __ptr64>, COMDAT

; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	jmp	?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z ; std::allocator<Json::OurReader::ErrorInfo>::construct
??$construct@VErrorInfo@OurReader@Json@@AEBV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV234@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::construct<Json::OurReader::ErrorInfo,Json::OurReader::ErrorInfo const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Value * __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVValue@Json@@PEAV12@@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAXPEAPEAVValue@Json@@$$QEAPEAV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVValue@Json@@PEAV12@@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAXPEAPEAVValue@Json@@$$QEAPEAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64> >::construct<Json::Value * __ptr64,Json::Value * __ptr64>, COMDAT

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN11@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@PEAVValue@Json@@PEAV12@@?$_Wrap_alloc@V?$allocator@PEAVValue@Json@@@std@@@std@@QEAAXPEAPEAVValue@Json@@$$QEAPEAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * __ptr64> >::construct<Json::Value * __ptr64,Json::Value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * __ptr64 * __ptr64,Json::Reader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdx, rcx

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	mov	rax, r8

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sar	rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rax
	mov	r8, rbx
	call	QWORD PTR __imp_memmove
	add	rax, rbx

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * __ptr64 * __ptr64,Json::Reader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
_Al$dead$ = 32
??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >, COMDAT

; 690  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

$LN19:
	sub	rsp, 8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rdx, rdx
	je	SHORT $LN11@Uninitiali
	mov	QWORD PTR [rsp], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	mov	rdi, rcx
	xor	eax, eax
	mov	rcx, rdx
	rep stosq
	mov	rdi, QWORD PTR [rsp]
$LN11@Uninitiali:

; 691  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 693  : 	}

	add	rsp, 8
	ret	0
??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@Reader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@OurReader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@VErrorInfo@OurReader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo>, COMDAT

; 877  : 		void destroy(_Ty *_Ptr)

$LN45:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rdx+48], 16
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 877  : 		void destroy(_Ty *_Ptr)

	mov	rbx, rdx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN32@destroy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdx+24]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN32@destroy:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+24], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 880  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$destroy@VErrorInfo@OurReader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$dead$ = 16
??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> >::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> ><std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> > >, COMDAT

; 818  : 		}

	mov	rax, rcx
	ret	0
??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> >::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> ><std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,Json::OurReader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdx, rcx

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	mov	rax, r8

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sar	rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rax
	mov	r8, rbx
	call	QWORD PTR __imp_memmove
	add	rax, rbx

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,Json::OurReader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
_Al$dead$ = 32
??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >, COMDAT

; 690  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

$LN19:
	sub	rsp, 8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rdx, rdx
	je	SHORT $LN11@Uninitiali
	mov	QWORD PTR [rsp], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	mov	rdi, rcx
	xor	eax, eax
	mov	rcx, rdx
	rep stosq
	mov	rdi, QWORD PTR [rsp]
$LN11@Uninitiali:

; 691  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 693  : 	}

	add	rsp, 8
	ret	0
??$_Uninitialized_default_fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAVErrorInfo@OurReader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAVErrorInfo@OurReader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo * __ptr64>, COMDAT

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

	ret	0
??$destroy@PEAVErrorInfo@OurReader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<Json::Value * __ptr64 * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdx, rcx

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	mov	rax, r8

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sar	rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rax
	mov	r8, rbx
	call	QWORD PTR __imp_memmove
	add	rax, rbx

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Value * __ptr64 * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
_Al$dead$ = 32
??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::Value * __ptr64 * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >, COMDAT

; 690  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

$LN19:
	sub	rsp, 8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rdx, rdx
	je	SHORT $LN11@Uninitiali
	mov	QWORD PTR [rsp], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	mov	rdi, rcx
	xor	eax, eax
	mov	rcx, rdx
	rep stosq
	mov	rdi, QWORD PTR [rsp]
$LN11@Uninitiali:

; 691  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 693  : 	}

	add	rsp, 8
	ret	0
??$_Uninitialized_default_fill_n@PEAPEAPEAVValue@Json@@_KU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::Value * __ptr64 * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPEAVErrorInfo@Reader@Json@@_KPEAV123@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPEAVErrorInfo@Reader@Json@@_KPEAV123@@Z PROC ; std::_Allocate<Json::Reader::ErrorInfo>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN13:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN1@Allocate
	shl	rcx, 6
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Allocate:
??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPEAVErrorInfo@Reader@Json@@_KPEAV123@@Z ENDP ; std::_Allocate<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN11@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@VErrorInfo@OurReader@Json@@@std@@YAPEAVErrorInfo@OurReader@Json@@_KPEAV123@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@VErrorInfo@OurReader@Json@@@std@@YAPEAVErrorInfo@OurReader@Json@@_KPEAV123@@Z PROC ; std::_Allocate<Json::OurReader::ErrorInfo>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN13:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN1@Allocate
	shl	rcx, 6
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Allocate:
??$_Allocate@VErrorInfo@OurReader@Json@@@std@@YAPEAVErrorInfo@OurReader@Json@@_KPEAV123@@Z ENDP ; std::_Allocate<Json::OurReader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PEAVValue@Json@@@std@@YAPEAPEAVValue@Json@@_KPEAPEAV12@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@PEAVValue@Json@@@std@@YAPEAPEAVValue@Json@@_KPEAPEAV12@@Z PROC ; std::_Allocate<Json::Value * __ptr64>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN13:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN1@Allocate
	lea	rcx, QWORD PTR [rcx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Allocate:
??$_Allocate@PEAVValue@Json@@@std@@YAPEAPEAVValue@Json@@_KPEAPEAV12@@Z ENDP ; std::_Allocate<Json::Value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@_KPEAPEAV123@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@PEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@_KPEAPEAV123@@Z PROC ; std::_Allocate<Json::Reader::ErrorInfo * __ptr64>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN13:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN1@Allocate
	lea	rcx, QWORD PTR [rcx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Allocate:
??$_Allocate@PEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@_KPEAPEAV123@@Z ENDP ; std::_Allocate<Json::Reader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@_KPEAPEAV123@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@PEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@_KPEAPEAV123@@Z PROC ; std::_Allocate<Json::OurReader::ErrorInfo * __ptr64>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN13:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN1@Allocate
	lea	rcx, QWORD PTR [rcx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Allocate:
??$_Allocate@PEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@_KPEAPEAV123@@Z ENDP ; std::_Allocate<Json::OurReader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@_KPEAPEAPEAV12@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@PEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@_KPEAPEAPEAV12@@Z PROC ; std::_Allocate<Json::Value * __ptr64 * __ptr64>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN13:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN1@Allocate
	lea	rcx, QWORD PTR [rcx*8]
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Allocate:
??$_Allocate@PEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@_KPEAPEAPEAV12@@Z ENDP ; std::_Allocate<Json::Value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN13:
	sub	rsp, 40					; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN1@Allocate
	shl	rcx, 4
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	test	rax, rax
	jne	SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Allocate:
??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct, COMDAT

; 588  : 		::new ((void *)_Ptr) _Ty();

	test	rdx, rdx
	je	SHORT $LN7@construct
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdx+24], 0
$LN7@construct:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 864  : 		}

	ret	0
?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::construct, COMDAT

; 588  : 		::new ((void *)_Ptr) _Ty();

	test	rdx, rdx
	je	SHORT $LN7@construct
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdx+24], 0
$LN7@construct:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 864  : 		}

	ret	0
?construct@?$_Wrap_alloc@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEBVErrorInfo@Reader@Json@@@std@@YAAEBVErrorInfo@Reader@Json@@AEBV123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBVErrorInfo@Reader@Json@@@std@@YAAEBVErrorInfo@Reader@Json@@AEBV123@@Z PROC ; std::forward<Json::Reader::ErrorInfo const & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEBVErrorInfo@Reader@Json@@@std@@YAAEBVErrorInfo@Reader@Json@@AEBV123@@Z ENDP ; std::forward<Json::Reader::ErrorInfo const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@AEBV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@Reader@Json@@@1@PEAVErrorInfo@Reader@Json@@AEBV345@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VErrorInfo@Reader@Json@@AEBV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@Reader@Json@@@1@PEAVErrorInfo@Reader@Json@@AEBV345@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const & __ptr64>, COMDAT

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	jmp	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct
??$construct@VErrorInfo@Reader@Json@@AEBV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@Reader@Json@@@1@PEAVErrorInfo@Reader@Json@@AEBV345@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEBVErrorInfo@OurReader@Json@@@std@@YAAEBVErrorInfo@OurReader@Json@@AEBV123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBVErrorInfo@OurReader@Json@@@std@@YAAEBVErrorInfo@OurReader@Json@@AEBV123@@Z PROC ; std::forward<Json::OurReader::ErrorInfo const & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEBVErrorInfo@OurReader@Json@@@std@@YAAEBVErrorInfo@OurReader@Json@@AEBV123@@Z ENDP ; std::forward<Json::OurReader::ErrorInfo const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@OurReader@Json@@AEBV123@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@AEBV345@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VErrorInfo@OurReader@Json@@AEBV123@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@AEBV345@@Z PROC ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::construct<Json::OurReader::ErrorInfo,Json::OurReader::ErrorInfo const & __ptr64>, COMDAT

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	jmp	?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z ; std::allocator<Json::OurReader::ErrorInfo>::construct
??$construct@VErrorInfo@OurReader@Json@@AEBV123@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@AEBV345@@Z ENDP ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::construct<Json::OurReader::ErrorInfo,Json::OurReader::ErrorInfo const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVValue@Json@@PEAV12@@?$allocator_traits@V?$allocator@PEAVValue@Json@@@std@@@std@@SAXAEAV?$allocator@PEAVValue@Json@@@1@PEAPEAVValue@Json@@$$QEAPEAV34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVValue@Json@@PEAV12@@?$allocator_traits@V?$allocator@PEAVValue@Json@@@std@@@std@@SAXAEAV?$allocator@PEAVValue@Json@@@1@PEAPEAVValue@Json@@$$QEAPEAV34@@Z PROC ; std::allocator_traits<std::allocator<Json::Value * __ptr64> >::construct<Json::Value * __ptr64,Json::Value * __ptr64>, COMDAT

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

	ret	0
??$construct@PEAVValue@Json@@PEAV12@@?$allocator_traits@V?$allocator@PEAVValue@Json@@@std@@@std@@SAXAEAV?$allocator@PEAVValue@Json@@@1@PEAPEAVValue@Json@@$$QEAPEAV34@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value * __ptr64> >::construct<Json::Value * __ptr64,Json::Value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAPEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAPEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@Z PROC ; std::_Unchecked<Json::Reader::ErrorInfo * __ptr64 * __ptr64>, COMDAT

; 281  : 	return (_Src);

	mov	rax, rcx

; 282  : 	}

	ret	0
??$_Unchecked@PEAPEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@Z ENDP ; std::_Unchecked<Json::Reader::ErrorInfo * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninit_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninit_copy<Json::Reader::ErrorInfo * __ptr64 * __ptr64,Json::Reader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdx, rcx

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	mov	rax, r8

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sar	rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rax
	mov	r8, rbx
	call	QWORD PTR __imp_memmove
	add	rax, rbx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninit_copy@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninit_copy<Json::Reader::ErrorInfo * __ptr64 * __ptr64,Json::Reader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@std@@YAAEAPEAPEAVErrorInfo@Reader@Json@@AEAPEAPEAV123@PEAPEAV123@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@std@@YAAEAPEAPEAVErrorInfo@Reader@Json@@AEAPEAPEAV123@PEAPEAV123@@Z PROC ; std::_Rechecked<Json::Reader::ErrorInfo * __ptr64 * __ptr64,Json::Reader::ErrorInfo * __ptr64 * __ptr64>, COMDAT

; 289  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 290  : 	return (_Dest);

	mov	rax, rcx

; 291  : 	}

	ret	0
??$_Rechecked@PEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@std@@YAAEAPEAPEAVErrorInfo@Reader@Json@@AEAPEAPEAV123@PEAPEAV123@@Z ENDP ; std::_Rechecked<Json::Reader::ErrorInfo * __ptr64 * __ptr64,Json::Reader::ErrorInfo * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAPEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAPEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@Z PROC ; std::_Val_type<Json::Reader::ErrorInfo * __ptr64 * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAPEAVErrorInfo@Reader@Json@@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@@Z ENDP ; std::_Val_type<Json::Reader::ErrorInfo * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PEAVErrorInfo@Reader@Json@@PEAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@PEAVErrorInfo@Reader@Json@@PEAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVErrorInfo@Reader@Json@@0@Z PROC ; std::_Ptr_cat<Json::Reader::ErrorInfo * __ptr64,Json::Reader::ErrorInfo * __ptr64>, COMDAT

; 444  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 447  : 	}

	ret	0
??$_Ptr_cat@PEAVErrorInfo@Reader@Json@@PEAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVErrorInfo@Reader@Json@@0@Z ENDP ; std::_Ptr_cat<Json::Reader::ErrorInfo * __ptr64,Json::Reader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
__formal$dead$ = 32
__formal$dead$ = 40
__formal$dead$ = 48
??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo * __ptr64,unsigned __int64,Json::Reader::ErrorInfo * __ptr64>, COMDAT

; 681  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

$LN13:
	sub	rsp, 8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rdx, rdx
	je	SHORT $LN5@Uninit_def
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	mov	QWORD PTR [rsp], rdi
	mov	rdi, rcx
	xor	eax, eax
	mov	rcx, rdx
	rep stosq
	mov	rdi, QWORD PTR [rsp]
$LN5@Uninit_def:

; 683  : 	}

	add	rsp, 8
	ret	0
??$_Uninit_def_fill_n@PEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo * __ptr64,unsigned __int64,Json::Reader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >, COMDAT

; 90   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@Reader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@OurReader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$destroy@VErrorInfo@OurReader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

$LN43:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rdx+48], 16
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	mov	rbx, rdx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN30@destroy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdx+24]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN30@destroy:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+24], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 731  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$destroy@VErrorInfo@OurReader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?0VErrorInfo@OurReader@Json@@@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAA@AEBV?$allocator@VErrorInfo@OurReader@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0VErrorInfo@OurReader@Json@@@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAA@AEBV?$allocator@VErrorInfo@OurReader@Json@@@1@@Z PROC ; std::allocator<Json::OurReader::ErrorInfo * __ptr64>::allocator<Json::OurReader::ErrorInfo * __ptr64><Json::OurReader::ErrorInfo>, COMDAT

; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}

	mov	rax, rcx
	ret	0
??$?0VErrorInfo@OurReader@Json@@@?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@QEAA@AEBV?$allocator@VErrorInfo@OurReader@Json@@@1@@Z ENDP ; std::allocator<Json::OurReader::ErrorInfo * __ptr64>::allocator<Json::OurReader::ErrorInfo * __ptr64><Json::OurReader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAPEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAPEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@Z PROC ; std::_Unchecked<Json::OurReader::ErrorInfo * __ptr64 * __ptr64>, COMDAT

; 281  : 	return (_Src);

	mov	rax, rcx

; 282  : 	}

	ret	0
??$_Unchecked@PEAPEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@Z ENDP ; std::_Unchecked<Json::OurReader::ErrorInfo * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninit_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z PROC ; std::_Uninit_copy<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,Json::OurReader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdx, rcx

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	mov	rax, r8

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sar	rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rax
	mov	r8, rbx
	call	QWORD PTR __imp_memmove
	add	rax, rbx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninit_copy@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@@Z ENDP ; std::_Uninit_copy<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,Json::OurReader::ErrorInfo * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@std@@YAAEAPEAPEAVErrorInfo@OurReader@Json@@AEAPEAPEAV123@PEAPEAV123@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@std@@YAAEAPEAPEAVErrorInfo@OurReader@Json@@AEAPEAPEAV123@PEAPEAV123@@Z PROC ; std::_Rechecked<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,Json::OurReader::ErrorInfo * __ptr64 * __ptr64>, COMDAT

; 289  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 290  : 	return (_Dest);

	mov	rax, rcx

; 291  : 	}

	ret	0
??$_Rechecked@PEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@std@@YAAEAPEAPEAVErrorInfo@OurReader@Json@@AEAPEAPEAV123@PEAPEAV123@@Z ENDP ; std::_Rechecked<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,Json::OurReader::ErrorInfo * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAPEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAPEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@Z PROC ; std::_Val_type<Json::OurReader::ErrorInfo * __ptr64 * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAPEAVErrorInfo@OurReader@Json@@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@@Z ENDP ; std::_Val_type<Json::OurReader::ErrorInfo * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PEAVErrorInfo@OurReader@Json@@PEAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVErrorInfo@OurReader@Json@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@PEAVErrorInfo@OurReader@Json@@PEAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVErrorInfo@OurReader@Json@@0@Z PROC ; std::_Ptr_cat<Json::OurReader::ErrorInfo * __ptr64,Json::OurReader::ErrorInfo * __ptr64>, COMDAT

; 444  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 447  : 	}

	ret	0
??$_Ptr_cat@PEAVErrorInfo@OurReader@Json@@PEAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVErrorInfo@OurReader@Json@@0@Z ENDP ; std::_Ptr_cat<Json::OurReader::ErrorInfo * __ptr64,Json::OurReader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
__formal$dead$ = 32
__formal$dead$ = 40
__formal$dead$ = 48
??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<Json::OurReader::ErrorInfo * __ptr64,unsigned __int64,Json::OurReader::ErrorInfo * __ptr64>, COMDAT

; 681  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

$LN13:
	sub	rsp, 8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rdx, rdx
	je	SHORT $LN5@Uninit_def
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	mov	QWORD PTR [rsp], rdi
	mov	rdi, rcx
	xor	eax, eax
	mov	rcx, rdx
	rep stosq
	mov	rdi, QWORD PTR [rsp]
$LN5@Uninit_def:

; 683  : 	}

	add	rsp, 8
	ret	0
??$_Uninit_def_fill_n@PEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<Json::OurReader::ErrorInfo * __ptr64,unsigned __int64,Json::OurReader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >, COMDAT

; 90   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@std@@@std@@YAXPEAPEAVErrorInfo@OurReader@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::OurReader::ErrorInfo * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAVErrorInfo@OurReader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAPEAVErrorInfo@OurReader@Json@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAVErrorInfo@OurReader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAPEAVErrorInfo@OurReader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo * __ptr64>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

	ret	0
??$destroy@PEAVErrorInfo@OurReader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAPEAVErrorInfo@OurReader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::destroy<Json::OurReader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAPEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAPEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@@Z PROC ; std::_Unchecked<Json::Value * __ptr64 * __ptr64 * __ptr64>, COMDAT

; 281  : 	return (_Src);

	mov	rax, rcx

; 282  : 	}

	ret	0
??$_Unchecked@PEAPEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@@Z ENDP ; std::_Unchecked<Json::Value * __ptr64 * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninit_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninit_copy<Json::Value * __ptr64 * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdx, rcx

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	mov	rax, r8

; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sar	rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rax
	mov	r8, rbx
	call	QWORD PTR __imp_memmove
	add	rax, rbx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninit_copy@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninit_copy<Json::Value * __ptr64 * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@@std@@YAAEAPEAPEAPEAVValue@Json@@AEAPEAPEAPEAV12@PEAPEAPEAV12@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@@std@@YAAEAPEAPEAPEAVValue@Json@@AEAPEAPEAPEAV12@PEAPEAPEAV12@@Z PROC ; std::_Rechecked<Json::Value * __ptr64 * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64 * __ptr64>, COMDAT

; 289  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 290  : 	return (_Dest);

	mov	rax, rcx

; 291  : 	}

	ret	0
??$_Rechecked@PEAPEAPEAVValue@Json@@PEAPEAPEAV12@@std@@YAAEAPEAPEAPEAVValue@Json@@AEAPEAPEAPEAV12@PEAPEAPEAV12@@Z ENDP ; std::_Rechecked<Json::Value * __ptr64 * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAPEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAPEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@@Z PROC ; std::_Val_type<Json::Value * __ptr64 * __ptr64 * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAPEAPEAVValue@Json@@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@@Z ENDP ; std::_Val_type<Json::Value * __ptr64 * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PEAPEAVValue@Json@@PEAPEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAPEAVValue@Json@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@PEAPEAVValue@Json@@PEAPEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAPEAVValue@Json@@0@Z PROC ; std::_Ptr_cat<Json::Value * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64>, COMDAT

; 444  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 447  : 	}

	ret	0
??$_Ptr_cat@PEAPEAVValue@Json@@PEAPEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAPEAVValue@Json@@0@Z ENDP ; std::_Ptr_cat<Json::Value * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
__formal$dead$ = 32
__formal$dead$ = 40
__formal$dead$ = 48
??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<Json::Value * __ptr64 * __ptr64,unsigned __int64,Json::Value * __ptr64 * __ptr64>, COMDAT

; 681  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

$LN13:
	sub	rsp, 8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rdx, rdx
	je	SHORT $LN5@Uninit_def
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

	mov	QWORD PTR [rsp], rdi
	mov	rdi, rcx
	xor	eax, eax
	mov	rcx, rdx
	rep stosq
	mov	rdi, QWORD PTR [rsp]
$LN5@Uninit_def:

; 683  : 	}

	add	rsp, 8
	ret	0
??$_Uninit_def_fill_n@PEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAXPEAPEAPEAVValue@Json@@_KAEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<Json::Value * __ptr64 * __ptr64,unsigned __int64,Json::Value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >, COMDAT

; 90   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@std@@@std@@YAXPEAPEAPEAVValue@Json@@0AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Json::Value * __ptr64 * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QEAU_Container_proxy@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Container_proxy@std@@@std@@YA$$QEAU_Container_proxy@0@AEAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QEAU_Container_proxy@0@AEAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@$$QEAU31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@$$QEAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

	ret	0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@$$QEAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@Reader@Json@@@1@PEAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$construct@VErrorInfo@Reader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@Reader@Json@@@1@PEAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>, COMDAT

; 588  : 		::new ((void *)_Ptr) _Ty();

	test	rdx, rdx
	je	SHORT $LN5@construct
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdx+24], 0
$LN5@construct:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 724  : 		}

	ret	0
??$construct@VErrorInfo@Reader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@Reader@Json@@@1@PEAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@OurReader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$construct@VErrorInfo@OurReader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::construct<Json::OurReader::ErrorInfo>, COMDAT

; 588  : 		::new ((void *)_Ptr) _Ty();

	test	rdx, rdx
	je	SHORT $LN5@construct
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdx+24], 0
$LN5@construct:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 724  : 		}

	ret	0
??$construct@VErrorInfo@OurReader@Json@@$$$V@?$allocator_traits@V?$allocator@VErrorInfo@OurReader@Json@@@std@@@std@@SAXAEAV?$allocator@VErrorInfo@OurReader@Json@@@1@PEAVErrorInfo@OurReader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::OurReader::ErrorInfo> >::construct<Json::OurReader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::construct, COMDAT

; 588  : 		::new ((void *)_Ptr) _Ty();

	test	rdx, rdx
	je	SHORT $LN3@construct
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdx+24], 0
$LN3@construct:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 589  : 		}

	ret	0
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z
_TEXT	SEGMENT
$T1 = 32
this$dead$ = 64
$T2 = 64
_Ptr$ = 72
_Val$ = 80
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::construct, COMDAT

; 592  : 		{	// construct object at _Ptr with value _Val

$LN54:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+80], rbx
	mov	rdi, r8
	mov	rbx, rdx

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	QWORD PTR $T2[rsp], rdx
	test	rdx, rdx
	je	SHORT $LN53@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rdx+16], xmm1
	lea	rcx, QWORD PTR [rdx+24]
	mov	QWORD PTR [rcx+24], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
	lea	rdx, QWORD PTR [r8+24]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rbx+56], rax
$LN53@construct:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 594  : 		}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$dead$ = 64
$T2 = 64
_Ptr$ = 72
_Val$ = 80
?dtor$0@?0??construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z@4HA PROC ; `std::allocator<Json::Reader::ErrorInfo>::construct'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QEAAXPEAVErrorInfo@Reader@Json@@AEBV345@@Z@4HA ENDP ; `std::allocator<Json::Reader::ErrorInfo>::construct'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z PROC ; std::allocator<Json::OurReader::ErrorInfo>::construct, COMDAT

; 588  : 		::new ((void *)_Ptr) _Ty();

	test	rdx, rdx
	je	SHORT $LN3@construct
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdx+24], 0
$LN3@construct:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 589  : 		}

	ret	0
?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z ENDP ; std::allocator<Json::OurReader::ErrorInfo>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z
_TEXT	SEGMENT
$T1 = 32
this$dead$ = 64
$T2 = 64
_Ptr$ = 72
_Val$ = 80
?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z PROC ; std::allocator<Json::OurReader::ErrorInfo>::construct, COMDAT

; 592  : 		{	// construct object at _Ptr with value _Val

$LN54:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+80], rbx
	mov	rdi, r8
	mov	rbx, rdx

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	QWORD PTR $T2[rsp], rdx
	test	rdx, rdx
	je	SHORT $LN53@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rdx+16], xmm1
	lea	rcx, QWORD PTR [rdx+24]
	mov	QWORD PTR [rcx+24], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
	lea	rdx, QWORD PTR [r8+24]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rbx+56], rax
$LN53@construct:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 594  : 		}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z ENDP ; std::allocator<Json::OurReader::ErrorInfo>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$dead$ = 64
$T2 = 64
_Ptr$ = 72
_Val$ = 80
?dtor$0@?0??construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z@4HA PROC ; `std::allocator<Json::OurReader::ErrorInfo>::construct'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??construct@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@AEBV345@@Z@4HA ENDP ; `std::allocator<Json::OurReader::ErrorInfo>::construct'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0ErrorInfo@Reader@Json@@QEAA@AEBV012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ErrorInfo@Reader@Json@@QEAA@AEBV012@@Z PROC		; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
$LN47:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movups	xmm0, XMMWORD PTR [rdx]
	mov	rdi, rcx
	add	rcx, 24
	mov	rbx, rdx

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	add	rdx, 24
	movups	XMMWORD PTR [rcx-24], xmm0
	movsdx	xmm1, QWORD PTR [rdx-8]
	movsdx	QWORD PTR [rcx-8], xmm1
	mov	QWORD PTR [rcx+24], 15

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	rax, QWORD PTR [rbx+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+56], rax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0ErrorInfo@Reader@Json@@QEAA@AEBV012@@Z ENDP		; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0ErrorInfo@OurReader@Json@@QEAA@AEBV012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ErrorInfo@OurReader@Json@@QEAA@AEBV012@@Z PROC	; Json::OurReader::ErrorInfo::ErrorInfo, COMDAT
$LN47:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movups	xmm0, XMMWORD PTR [rdx]
	mov	rdi, rcx
	add	rcx, 24
	mov	rbx, rdx

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	add	rdx, 24
	movups	XMMWORD PTR [rcx-24], xmm0
	movsdx	xmm1, QWORD PTR [rdx-8]
	movsdx	QWORD PTR [rcx-8], xmm1
	mov	QWORD PTR [rcx+24], 15

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	rax, QWORD PTR [rbx+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+56], rax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0ErrorInfo@OurReader@Json@@QEAA@AEBV012@@Z ENDP	; Json::OurReader::ErrorInfo::ErrorInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVValue@Json@@PEAV12@@?$allocator@PEAVValue@Json@@@std@@QEAAXPEAPEAVValue@Json@@$$QEAPEAV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVValue@Json@@PEAV12@@?$allocator@PEAVValue@Json@@@std@@QEAAXPEAPEAVValue@Json@@$$QEAPEAV23@@Z PROC ; std::allocator<Json::Value * __ptr64>::construct<Json::Value * __ptr64,Json::Value * __ptr64>, COMDAT

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN3@construct:

; 601  : 		}

	ret	0
??$construct@PEAVValue@Json@@PEAV12@@?$allocator@PEAVValue@Json@@@std@@QEAAXPEAPEAVValue@Json@@$$QEAPEAV23@@Z ENDP ; std::allocator<Json::Value * __ptr64>::construct<Json::Value * __ptr64,Json::Value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAVErrorInfo@Reader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
??$_Uninit_copy@PEAVErrorInfo@Reader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::Reader::ErrorInfo * __ptr64,Json::Reader::ErrorInfo * __ptr64>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdx, rcx
	mov	rax, r8
	sar	rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rax
	mov	r8, rbx
	call	QWORD PTR __imp_memmove
	add	rax, rbx

; 407  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninit_copy@PEAVErrorInfo@Reader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@Reader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::Reader::ErrorInfo * __ptr64,Json::Reader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PEAPEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@_KAEBQEAV123@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Count$ = 16
_Val$ = 24
??$_Fill_n@PEAPEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@_KAEBQEAV123@@Z PROC ; std::_Fill_n<Json::Reader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,Json::Reader::ErrorInfo * __ptr64>, COMDAT

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rdx, rdx
	je	SHORT $LN10@Fill_n
	npad	11
$LL3@Fill_n:

; 2633 : 		*_Dest = _Val;

	mov	rax, QWORD PTR [r8]
	add	rcx, 8
	mov	QWORD PTR [rcx-8], rax
	dec	rdx
	jne	SHORT $LL3@Fill_n
$LN10@Fill_n:

; 2634 : 	return (_Dest);

	mov	rax, rcx

; 2635 : 	}

	ret	0
??$_Fill_n@PEAPEAVErrorInfo@Reader@Json@@_KPEAV123@@std@@YAPEAPEAVErrorInfo@Reader@Json@@PEAPEAV123@_KAEBQEAV123@@Z ENDP ; std::_Fill_n<Json::Reader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,Json::Reader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@OurReader@Json@@@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@VErrorInfo@OurReader@Json@@@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z PROC ; std::allocator<Json::OurReader::ErrorInfo>::destroy<Json::OurReader::ErrorInfo>, COMDAT

; 605  : 		void destroy(_Uty *_Ptr)

$LN41:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rdx+48], 16
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 605  : 		void destroy(_Uty *_Ptr)

	mov	rbx, rdx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN28@destroy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdx+24]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN28@destroy:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+40], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+24], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 608  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$destroy@VErrorInfo@OurReader@Json@@@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAVErrorInfo@OurReader@Json@@@Z ENDP ; std::allocator<Json::OurReader::ErrorInfo>::destroy<Json::OurReader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAVErrorInfo@OurReader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
??$_Uninit_copy@PEAVErrorInfo@OurReader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::OurReader::ErrorInfo * __ptr64,Json::OurReader::ErrorInfo * __ptr64>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdx, rcx
	mov	rax, r8
	sar	rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rax
	mov	r8, rbx
	call	QWORD PTR __imp_memmove
	add	rax, rbx

; 407  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninit_copy@PEAVErrorInfo@OurReader@Json@@PEAV123@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@00AEAU?$_Wrap_alloc@V?$allocator@PEAVErrorInfo@OurReader@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::OurReader::ErrorInfo * __ptr64,Json::OurReader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@_KAEBQEAV123@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Count$ = 16
_Val$ = 24
??$_Fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@_KAEBQEAV123@@Z PROC ; std::_Fill_n<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,Json::OurReader::ErrorInfo * __ptr64>, COMDAT

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rdx, rdx
	je	SHORT $LN10@Fill_n
	npad	11
$LL3@Fill_n:

; 2633 : 		*_Dest = _Val;

	mov	rax, QWORD PTR [r8]
	add	rcx, 8
	mov	QWORD PTR [rcx-8], rax
	dec	rdx
	jne	SHORT $LL3@Fill_n
$LN10@Fill_n:

; 2634 : 	return (_Dest);

	mov	rax, rcx

; 2635 : 	}

	ret	0
??$_Fill_n@PEAPEAVErrorInfo@OurReader@Json@@_KPEAV123@@std@@YAPEAPEAVErrorInfo@OurReader@Json@@PEAPEAV123@_KAEBQEAV123@@Z ENDP ; std::_Fill_n<Json::OurReader::ErrorInfo * __ptr64 * __ptr64,unsigned __int64,Json::OurReader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAVErrorInfo@OurReader@Json@@@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAVErrorInfo@OurReader@Json@@@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@@Z PROC ; std::allocator<Json::OurReader::ErrorInfo>::destroy<Json::OurReader::ErrorInfo * __ptr64>, COMDAT

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	ret	0
??$destroy@PEAVErrorInfo@OurReader@Json@@@?$allocator@VErrorInfo@OurReader@Json@@@std@@QEAAXPEAPEAVErrorInfo@OurReader@Json@@@Z ENDP ; std::allocator<Json::OurReader::ErrorInfo>::destroy<Json::OurReader::ErrorInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAPEAVValue@Json@@PEAPEAV12@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
??$_Uninit_copy@PEAPEAVValue@Json@@PEAPEAV12@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::Value * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

	sub	rdx, rcx
	mov	rax, r8
	sar	rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rax
	mov	r8, rbx
	call	QWORD PTR __imp_memmove
	add	rax, rbx

; 407  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninit_copy@PEAPEAVValue@Json@@PEAPEAV12@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@00AEAU?$_Wrap_alloc@V?$allocator@PEAPEAVValue@Json@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::Value * __ptr64 * __ptr64,Json::Value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PEAPEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@_KAEBQEAPEAV12@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Count$ = 16
_Val$ = 24
??$_Fill_n@PEAPEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@_KAEBQEAPEAV12@@Z PROC ; std::_Fill_n<Json::Value * __ptr64 * __ptr64 * __ptr64,unsigned __int64,Json::Value * __ptr64 * __ptr64>, COMDAT

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

	test	rdx, rdx
	je	SHORT $LN10@Fill_n
	npad	11
$LL3@Fill_n:

; 2633 : 		*_Dest = _Val;

	mov	rax, QWORD PTR [r8]
	add	rcx, 8
	mov	QWORD PTR [rcx-8], rax
	dec	rdx
	jne	SHORT $LL3@Fill_n
$LN10@Fill_n:

; 2634 : 	return (_Dest);

	mov	rax, rcx

; 2635 : 	}

	ret	0
??$_Fill_n@PEAPEAPEAVValue@Json@@_KPEAPEAV12@@std@@YAPEAPEAPEAVValue@Json@@PEAPEAPEAV12@_KAEBQEAPEAV12@@Z ENDP ; std::_Fill_n<Json::Value * __ptr64 * __ptr64 * __ptr64,unsigned __int64,Json::Value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
$LN3@construct:

; 601  : 		}

	ret	0
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??_GErrorInfo@OurReader@Json@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GErrorInfo@OurReader@Json@@QEAAPEAXI@Z PROC		; Json::OurReader::ErrorInfo::`scalar deleting destructor', COMDAT
$LN39:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rcx+48], 16
	mov	rbx, rcx
	jb	SHORT $LN26@scalar
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN26@scalar:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+48], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+40], 0
	mov	rax, rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+24], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GErrorInfo@OurReader@Json@@QEAAPEAXI@Z ENDP		; Json::OurReader::ErrorInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
	movsxd	rax, DWORD PTR [rcx-4]
	sub	rcx, rax
	jmp	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
END
