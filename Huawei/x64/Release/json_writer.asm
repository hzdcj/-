; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc


PUBLIC	??_7Writer@Json@@6B@				; Json::Writer::`vftable'
PUBLIC	??_R4Writer@Json@@6B@				; Json::Writer::`RTTI Complete Object Locator'
PUBLIC	??_R3StreamWriterBuilder@Json@@8		; Json::StreamWriterBuilder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7FastWriter@Json@@6B@			; Json::FastWriter::`vftable'
PUBLIC	??_R1A@?0A@EA@FastWriter@Json@@8		; Json::FastWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVStreamWriterBuilder@Json@@@8		; Json::StreamWriterBuilder `RTTI Type Descriptor'
PUBLIC	??_R0?AVFastWriter@Json@@@8			; Json::FastWriter `RTTI Type Descriptor'
PUBLIC	??_7StreamWriterBuilder@Json@@6B@		; Json::StreamWriterBuilder::`vftable'
PUBLIC	??_R1A@?0A@EA@StreamWriter@Json@@8		; Json::StreamWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Factory@StreamWriter@Json@@6B@		; Json::StreamWriter::Factory::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVStreamWriter@Json@@@8			; Json::StreamWriter `RTTI Type Descriptor'
PUBLIC	??_R0?AVFactory@StreamWriter@Json@@@8		; Json::StreamWriter::Factory `RTTI Type Descriptor'
PUBLIC	??_R4FastWriter@Json@@6B@			; Json::FastWriter::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUBuiltStyledStreamWriter@Json@@@8	; Json::BuiltStyledStreamWriter `RTTI Type Descriptor'
PUBLIC	??_R3BuiltStyledStreamWriter@Json@@8		; Json::BuiltStyledStreamWriter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7Factory@StreamWriter@Json@@6B@		; Json::StreamWriter::Factory::`vftable'
PUBLIC	??_R2FastWriter@Json@@8				; Json::FastWriter::`RTTI Base Class Array'
PUBLIC	??_R4BuiltStyledStreamWriter@Json@@6B@		; Json::BuiltStyledStreamWriter::`RTTI Complete Object Locator'
PUBLIC	??_R2BuiltStyledStreamWriter@Json@@8		; Json::BuiltStyledStreamWriter::`RTTI Base Class Array'
PUBLIC	??_R3Factory@StreamWriter@Json@@8		; Json::StreamWriter::Factory::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2StreamWriter@Json@@8			; Json::StreamWriter::`RTTI Base Class Array'
PUBLIC	??_7BuiltStyledStreamWriter@Json@@6B@		; Json::BuiltStyledStreamWriter::`vftable'
PUBLIC	??_R4StreamWriter@Json@@6B@			; Json::StreamWriter::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@StreamWriterBuilder@Json@@8	; Json::StreamWriterBuilder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3StreamWriter@Json@@8			; Json::StreamWriter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3FastWriter@Json@@8				; Json::FastWriter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2StreamWriterBuilder@Json@@8		; Json::StreamWriterBuilder::`RTTI Base Class Array'
PUBLIC	??_R2Factory@StreamWriter@Json@@8		; Json::StreamWriter::Factory::`RTTI Base Class Array'
PUBLIC	??_R4StreamWriterBuilder@Json@@6B@		; Json::StreamWriterBuilder::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@Factory@StreamWriter@Json@@8	; Json::StreamWriter::Factory::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@BuiltStyledStreamWriter@Json@@8	; Json::BuiltStyledStreamWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7StreamWriter@Json@@6B@			; Json::StreamWriter::`vftable'
PUBLIC	??_C@_06CEAIPCMK@?$CF?$CF?4?$CFdg?$AA@		; `string'
PUBLIC	??_C@_02ONCLHLPE@?40?$AA@			; `string'
PUBLIC	??_C@_01KGKMHCOC@e?$AA@				; `string'
PUBLIC	??_C@_04MLLLIHIP@null?$AA@			; `string'
PUBLIC	??_C@_03ICJPMMHB@NaN?$AA@			; `string'
PUBLIC	??_C@_08JDOGHFII@?91e?$CL9999?$AA@		; `string'
PUBLIC	??_C@_09BLDCEMOH@?9Infinity?$AA@		; `string'
PUBLIC	??_C@_07GDHDNLLL@1e?$CL9999?$AA@		; `string'
PUBLIC	??_C@_08KEBCLIFP@Infinity?$AA@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@	; `string'
PUBLIC	??_C@_02HDBGODGB@?2?2?$AA@			; `string'
PUBLIC	??_C@_02MCKKLHBJ@?2?$CC?$AA@			; `string'
PUBLIC	??_C@_02FGLPDNBI@?2f?$AA@			; `string'
PUBLIC	??_C@_02DCNDPIBM@?2b?$AA@			; `string'
PUBLIC	??_C@_02HIBBOKEN@?2r?$AA@			; `string'
PUBLIC	??_C@_02JOGGLHBA@?2n?$AA@			; `string'
PUBLIC	??_C@_02DHFAHMIK@?2u?$AA@			; `string'
PUBLIC	??_C@_02COELENML@?2t?$AA@			; `string'
PUBLIC	??_C@_01HCONENDN@?$HL?$AA@			; `string'
PUBLIC	??_C@_02MCILKGOH@?$HL?$HN?$AA@			; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN?$AA@			; `string'
PUBLIC	??_C@_03MCPBMLDJ@?5?3?5?$AA@			; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_02GPECMEKF@?$FL?$FN?$AA@			; `string'
PUBLIC	??_C@_02PFNDMDBO@?$FL?5?$AA@			; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_02DHOGEDBE@?5?$FN?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_0N@KEKHFENH@commentStyle?$AA@		; `string'
PUBLIC	??_C@_0M@BBOMBMCK@indentation?$AA@		; `string'
PUBLIC	??_C@_0BF@JIKFMOIK@dropNullPlaceholders?$AA@	; `string'
PUBLIC	??_C@_0BI@GHONPDJP@enableYAMLCompatibility?$AA@	; `string'
PUBLIC	??_C@_09HJGOLHNF@precision?$AA@			; `string'
PUBLIC	??_C@_0BB@MPBFLDFF@useSpecialFloats?$AA@	; `string'
PUBLIC	??_C@_04OHJIHAFH@None?$AA@			; `string'
PUBLIC	??_C@_03HFJGAJFE@All?$AA@			; `string'
PUBLIC	??_C@_0CF@BGMIIABI@commentStyle?5must?5be?5?8All?8?5or?5?8N@ ; `string'
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAADD@Z:PROC
EXTRN	__imp_strpbrk:PROC
EXTRN	__imp__dtest:PROC
EXTRN	__imp_strstr:PROC
EXTRN	__imp_?setw@std@@YA?AU?$_Smanip@_J@1@_J@Z:PROC
EXTRN	__imp_sprintf:PROC
EXTRN	__imp_?setf@ios_base@std@@QEAAHH@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z:PROC
;	COMDAT ??_C@_0CF@BGMIIABI@commentStyle?5must?5be?5?8All?8?5or?5?8N@
CONST	SEGMENT
??_C@_0CF@BGMIIABI@commentStyle?5must?5be?5?8All?8?5or?5?8N@ DB 'commentS'
	DB	'tyle must be ''All'' or ''None''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03HFJGAJFE@All?$AA@
CONST	SEGMENT
??_C@_03HFJGAJFE@All?$AA@ DB 'All', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None?$AA@
CONST	SEGMENT
??_C@_04OHJIHAFH@None?$AA@ DB 'None', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MPBFLDFF@useSpecialFloats?$AA@
CONST	SEGMENT
??_C@_0BB@MPBFLDFF@useSpecialFloats?$AA@ DB 'useSpecialFloats', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJGOLHNF@precision?$AA@
CONST	SEGMENT
??_C@_09HJGOLHNF@precision?$AA@ DB 'precision', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GHONPDJP@enableYAMLCompatibility?$AA@
CONST	SEGMENT
??_C@_0BI@GHONPDJP@enableYAMLCompatibility?$AA@ DB 'enableYAMLCompatibili'
	DB	'ty', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JIKFMOIK@dropNullPlaceholders?$AA@
CONST	SEGMENT
??_C@_0BF@JIKFMOIK@dropNullPlaceholders?$AA@ DB 'dropNullPlaceholders', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BBOMBMCK@indentation?$AA@
CONST	SEGMENT
??_C@_0M@BBOMBMCK@indentation?$AA@ DB 'indentation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KEKHFENH@commentStyle?$AA@
CONST	SEGMENT
??_C@_0N@KEKHFENH@commentStyle?$AA@ DB 'commentStyle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHOGEDBE@?5?$FN?$AA@
CONST	SEGMENT
??_C@_02DHOGEDBE@?5?$FN?$AA@ DB ' ]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PFNDMDBO@?$FL?5?$AA@
CONST	SEGMENT
??_C@_02PFNDMDBO@?$FL?5?$AA@ DB '[ ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_02GPECMEKF@?$FL?$FN?$AA@ DB '[]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCPBMLDJ@?5?3?5?$AA@
CONST	SEGMENT
??_C@_03MCPBMLDJ@?5?3?5?$AA@ DB ' : ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN?$AA@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCILKGOH@?$HL?$HN?$AA@
CONST	SEGMENT
??_C@_02MCILKGOH@?$HL?$HN?$AA@ DB '{}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL?$AA@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL?$AA@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02COELENML@?2t?$AA@
CONST	SEGMENT
??_C@_02COELENML@?2t?$AA@ DB '\t', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHFAHMIK@?2u?$AA@
CONST	SEGMENT
??_C@_02DHFAHMIK@?2u?$AA@ DB '\u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JOGGLHBA@?2n?$AA@
CONST	SEGMENT
??_C@_02JOGGLHBA@?2n?$AA@ DB '\n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIBBOKEN@?2r?$AA@
CONST	SEGMENT
??_C@_02HIBBOKEN@?2r?$AA@ DB '\r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCNDPIBM@?2b?$AA@
CONST	SEGMENT
??_C@_02DCNDPIBM@?2b?$AA@ DB '\b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGLPDNBI@?2f?$AA@
CONST	SEGMENT
??_C@_02FGLPDNBI@?2f?$AA@ DB '\f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCKKLHBJ@?2?$CC?$AA@
CONST	SEGMENT
??_C@_02MCKKLHBJ@?2?$CC?$AA@ DB '\"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HDBGODGB@?2?2?$AA@
CONST	SEGMENT
??_C@_02HDBGODGB@?2?2?$AA@ DB '\\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@
CONST	SEGMENT
??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@ DB '"\', 08H, 0cH, 0aH, 0dH, 09H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEBCLIFP@Infinity?$AA@
CONST	SEGMENT
??_C@_08KEBCLIFP@Infinity?$AA@ DB 'Infinity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GDHDNLLL@1e?$CL9999?$AA@
CONST	SEGMENT
??_C@_07GDHDNLLL@1e?$CL9999?$AA@ DB '1e+9999', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BLDCEMOH@?9Infinity?$AA@
CONST	SEGMENT
??_C@_09BLDCEMOH@?9Infinity?$AA@ DB '-Infinity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JDOGHFII@?91e?$CL9999?$AA@
CONST	SEGMENT
??_C@_08JDOGHFII@?91e?$CL9999?$AA@ DB '-1e+9999', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICJPMMHB@NaN?$AA@
CONST	SEGMENT
??_C@_03ICJPMMHB@NaN?$AA@ DB 'NaN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null?$AA@
CONST	SEGMENT
??_C@_04MLLLIHIP@null?$AA@ DB 'null', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT
??_C@_01KGKMHCOC@e?$AA@ DB 'e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ONCLHLPE@?40?$AA@
CONST	SEGMENT
??_C@_02ONCLHLPE@?40?$AA@ DB '.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CEAIPCMK@?$CF?$CF?4?$CFdg?$AA@
CONST	SEGMENT
??_C@_06CEAIPCMK@?$CF?$CF?4?$CFdg?$AA@ DB '%%.%dg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7StreamWriter@Json@@6B@
CONST	SEGMENT
??_7StreamWriter@Json@@6B@ DQ FLAT:??_R4StreamWriter@Json@@6B@ ; Json::StreamWriter::`vftable'
	DQ	FLAT:??_EStreamWriter@Json@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@BuiltStyledStreamWriter@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BuiltStyledStreamWriter@Json@@8 DD imagerel ??_R0?AUBuiltStyledStreamWriter@Json@@@8 ; Json::BuiltStyledStreamWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3BuiltStyledStreamWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Factory@StreamWriter@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Factory@StreamWriter@Json@@8 DD imagerel ??_R0?AVFactory@StreamWriter@Json@@@8 ; Json::StreamWriter::Factory::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Factory@StreamWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R4StreamWriterBuilder@Json@@6B@
rdata$r	SEGMENT
??_R4StreamWriterBuilder@Json@@6B@ DD 01H		; Json::StreamWriterBuilder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVStreamWriterBuilder@Json@@@8
	DD	imagerel ??_R3StreamWriterBuilder@Json@@8
	DD	imagerel ??_R4StreamWriterBuilder@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R2Factory@StreamWriter@Json@@8
rdata$r	SEGMENT
??_R2Factory@StreamWriter@Json@@8 DD imagerel ??_R1A@?0A@EA@Factory@StreamWriter@Json@@8 ; Json::StreamWriter::Factory::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2StreamWriterBuilder@Json@@8
rdata$r	SEGMENT
??_R2StreamWriterBuilder@Json@@8 DD imagerel ??_R1A@?0A@EA@StreamWriterBuilder@Json@@8 ; Json::StreamWriterBuilder::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Factory@StreamWriter@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3FastWriter@Json@@8
rdata$r	SEGMENT
??_R3FastWriter@Json@@8 DD 00H				; Json::FastWriter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2FastWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3StreamWriter@Json@@8
rdata$r	SEGMENT
??_R3StreamWriter@Json@@8 DD 00H			; Json::StreamWriter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2StreamWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@StreamWriterBuilder@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@StreamWriterBuilder@Json@@8 DD imagerel ??_R0?AVStreamWriterBuilder@Json@@@8 ; Json::StreamWriterBuilder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3StreamWriterBuilder@Json@@8
rdata$r	ENDS
;	COMDAT ??_R4StreamWriter@Json@@6B@
rdata$r	SEGMENT
??_R4StreamWriter@Json@@6B@ DD 01H			; Json::StreamWriter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVStreamWriter@Json@@@8
	DD	imagerel ??_R3StreamWriter@Json@@8
	DD	imagerel ??_R4StreamWriter@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_7BuiltStyledStreamWriter@Json@@6B@
CONST	SEGMENT
??_7BuiltStyledStreamWriter@Json@@6B@ DQ FLAT:??_R4BuiltStyledStreamWriter@Json@@6B@ ; Json::BuiltStyledStreamWriter::`vftable'
	DQ	FLAT:??_EBuiltStyledStreamWriter@Json@@UEAAPEAXI@Z
	DQ	FLAT:?write@BuiltStyledStreamWriter@Json@@UEAAHAEBVValue@2@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z
CONST	ENDS
;	COMDAT ??_R2StreamWriter@Json@@8
rdata$r	SEGMENT
??_R2StreamWriter@Json@@8 DD imagerel ??_R1A@?0A@EA@StreamWriter@Json@@8 ; Json::StreamWriter::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3Factory@StreamWriter@Json@@8
rdata$r	SEGMENT
??_R3Factory@StreamWriter@Json@@8 DD 00H		; Json::StreamWriter::Factory::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2Factory@StreamWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2BuiltStyledStreamWriter@Json@@8
rdata$r	SEGMENT
??_R2BuiltStyledStreamWriter@Json@@8 DD imagerel ??_R1A@?0A@EA@BuiltStyledStreamWriter@Json@@8 ; Json::BuiltStyledStreamWriter::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@StreamWriter@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4BuiltStyledStreamWriter@Json@@6B@
rdata$r	SEGMENT
??_R4BuiltStyledStreamWriter@Json@@6B@ DD 01H		; Json::BuiltStyledStreamWriter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AUBuiltStyledStreamWriter@Json@@@8
	DD	imagerel ??_R3BuiltStyledStreamWriter@Json@@8
	DD	imagerel ??_R4BuiltStyledStreamWriter@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R2FastWriter@Json@@8
rdata$r	SEGMENT
??_R2FastWriter@Json@@8 DD imagerel ??_R1A@?0A@EA@FastWriter@Json@@8 ; Json::FastWriter::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Writer@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7Factory@StreamWriter@Json@@6B@
CONST	SEGMENT
??_7Factory@StreamWriter@Json@@6B@ DQ FLAT:??_R4Factory@StreamWriter@Json@@6B@ ; Json::StreamWriter::Factory::`vftable'
	DQ	FLAT:??_EFactory@StreamWriter@Json@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT ??_R3BuiltStyledStreamWriter@Json@@8
rdata$r	SEGMENT
??_R3BuiltStyledStreamWriter@Json@@8 DD 00H		; Json::BuiltStyledStreamWriter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2BuiltStyledStreamWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUBuiltStyledStreamWriter@Json@@@8
data$r	SEGMENT
??_R0?AUBuiltStyledStreamWriter@Json@@@8 DQ FLAT:??_7type_info@@6B@ ; Json::BuiltStyledStreamWriter `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUBuiltStyledStreamWriter@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R4FastWriter@Json@@6B@
rdata$r	SEGMENT
??_R4FastWriter@Json@@6B@ DD 01H			; Json::FastWriter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVFastWriter@Json@@@8
	DD	imagerel ??_R3FastWriter@Json@@8
	DD	imagerel ??_R4FastWriter@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVFactory@StreamWriter@Json@@@8
data$r	SEGMENT
??_R0?AVFactory@StreamWriter@Json@@@8 DQ FLAT:??_7type_info@@6B@ ; Json::StreamWriter::Factory `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVFactory@StreamWriter@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVStreamWriter@Json@@@8
data$r	SEGMENT
??_R0?AVStreamWriter@Json@@@8 DQ FLAT:??_7type_info@@6B@ ; Json::StreamWriter `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVStreamWriter@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R4Factory@StreamWriter@Json@@6B@
rdata$r	SEGMENT
??_R4Factory@StreamWriter@Json@@6B@ DD 01H		; Json::StreamWriter::Factory::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVFactory@StreamWriter@Json@@@8
	DD	imagerel ??_R3Factory@StreamWriter@Json@@8
	DD	imagerel ??_R4Factory@StreamWriter@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@StreamWriter@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@StreamWriter@Json@@8 DD imagerel ??_R0?AVStreamWriter@Json@@@8 ; Json::StreamWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3StreamWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_7StreamWriterBuilder@Json@@6B@
CONST	SEGMENT
??_7StreamWriterBuilder@Json@@6B@ DQ FLAT:??_R4StreamWriterBuilder@Json@@6B@ ; Json::StreamWriterBuilder::`vftable'
	DQ	FLAT:??_EStreamWriterBuilder@Json@@UEAAPEAXI@Z
	DQ	FLAT:?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ
CONST	ENDS
;	COMDAT ??_R0?AVFastWriter@Json@@@8
data$r	SEGMENT
??_R0?AVFastWriter@Json@@@8 DQ FLAT:??_7type_info@@6B@	; Json::FastWriter `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVFastWriter@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVStreamWriterBuilder@Json@@@8
data$r	SEGMENT
??_R0?AVStreamWriterBuilder@Json@@@8 DQ FLAT:??_7type_info@@6B@ ; Json::StreamWriterBuilder `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVStreamWriterBuilder@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@FastWriter@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FastWriter@Json@@8 DD imagerel ??_R0?AVFastWriter@Json@@@8 ; Json::FastWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3FastWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_7FastWriter@Json@@6B@
CONST	SEGMENT
??_7FastWriter@Json@@6B@ DQ FLAT:??_R4FastWriter@Json@@6B@ ; Json::FastWriter::`vftable'
	DQ	FLAT:??_EFastWriter@Json@@UEAAPEAXI@Z
	DQ	FLAT:?write@FastWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z
CONST	ENDS
;	COMDAT ??_R3StreamWriterBuilder@Json@@8
rdata$r	SEGMENT
??_R3StreamWriterBuilder@Json@@8 DD 00H			; Json::StreamWriterBuilder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2StreamWriterBuilder@Json@@8
rdata$r	ENDS
;	COMDAT ??_R4Writer@Json@@6B@
rdata$r	SEGMENT
??_R4Writer@Json@@6B@ DD 01H				; Json::Writer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVWriter@Json@@@8
	DD	imagerel ??_R3Writer@Json@@8
	DD	imagerel ??_R4Writer@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_7Writer@Json@@6B@
CONST	SEGMENT
??_7Writer@Json@@6B@ DQ FLAT:??_R4Writer@Json@@6B@	; Json::Writer::`vftable'
	DQ	FLAT:??_EWriter@Json@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
PUBLIC	??0?$_Fillobj@D@std@@QEAA@D@Z			; std::_Fillobj<char>::_Fillobj<char>
PUBLIC	??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z ; std::operator<<<char,std::char_traits<char>,__int64>
PUBLIC	??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z ; std::operator<<<char,std::char_traits<char>,char>
PUBLIC	??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z	; std::setfill<char>
PUBLIC	??$isfinite@N@@YA_NN@Z				; isfinite<double>
PUBLIC	??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator!=
PUBLIC	??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator+
PUBLIC	??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator++
PUBLIC	?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ ; Json::StreamWriterBuilder::newStreamWriter
PUBLIC	??1StreamWriterBuilder@Json@@UEAA@XZ		; Json::StreamWriterBuilder::~StreamWriterBuilder
PUBLIC	??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z	; Json::StreamWriterBuilder::`scalar deleting destructor'
PUBLIC	??_GFactory@StreamWriter@Json@@UEAAPEAXI@Z	; Json::StreamWriter::Factory::`scalar deleting destructor'
PUBLIC	??1Factory@StreamWriter@Json@@UEAA@XZ		; Json::StreamWriter::Factory::~Factory
PUBLIC	??1StreamWriter@Json@@UEAA@XZ			; Json::StreamWriter::~StreamWriter
PUBLIC	??_GStreamWriter@Json@@UEAAPEAXI@Z		; Json::StreamWriter::`scalar deleting destructor'
PUBLIC	??0StreamWriter@Json@@QEAA@XZ			; Json::StreamWriter::StreamWriter
PUBLIC	?hasCommentForValue@BuiltStyledStreamWriter@Json@@CA_NAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::hasCommentForValue
PUBLIC	?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine
PUBLIC	?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeCommentBeforeValue
PUBLIC	?unindent@BuiltStyledStreamWriter@Json@@AEAAXXZ	; Json::BuiltStyledStreamWriter::unindent
PUBLIC	?indent@BuiltStyledStreamWriter@Json@@AEAAXXZ	; Json::BuiltStyledStreamWriter::indent
PUBLIC	?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::BuiltStyledStreamWriter::writeWithIndent
PUBLIC	?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ ; Json::BuiltStyledStreamWriter::writeIndent
PUBLIC	?pushValue@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::BuiltStyledStreamWriter::pushValue
PUBLIC	?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::isMultineArray
PUBLIC	?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeArrayValue
PUBLIC	?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeValue
PUBLIC	?write@BuiltStyledStreamWriter@Json@@UEAAHAEBVValue@2@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z ; Json::BuiltStyledStreamWriter::write
PUBLIC	??1BuiltStyledStreamWriter@Json@@UEAA@XZ	; Json::BuiltStyledStreamWriter::~BuiltStyledStreamWriter
PUBLIC	??_GBuiltStyledStreamWriter@Json@@UEAAPEAXI@Z	; Json::BuiltStyledStreamWriter::`scalar deleting destructor'
PUBLIC	??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z ; Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter
PUBLIC	?hasCommentForValue@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z ; Json::StyledWriter::hasCommentForValue
PUBLIC	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
PUBLIC	?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
PUBLIC	?unindent@StyledWriter@Json@@AEAAXXZ		; Json::StyledWriter::unindent
PUBLIC	?indent@StyledWriter@Json@@AEAAXXZ		; Json::StyledWriter::indent
PUBLIC	?writeWithIndent@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
PUBLIC	?writeIndent@StyledWriter@Json@@AEAAXXZ		; Json::StyledWriter::writeIndent
PUBLIC	?pushValue@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
PUBLIC	?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z ; Json::StyledWriter::isMultineArray
PUBLIC	?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeArrayValue
PUBLIC	?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeValue
PUBLIC	?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::FastWriter::writeValue
PUBLIC	?write@FastWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z ; Json::FastWriter::write
PUBLIC	??0Writer@Json@@QEAA@XZ				; Json::Writer::Writer
PUBLIC	??_GWriter@Json@@UEAAPEAXI@Z			; Json::Writer::`scalar deleting destructor'
PUBLIC	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z ; Json::valueToQuotedString
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
PUBLIC	?valueToString@?A0xcff6a387@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N_NI@Z ; Json::`anonymous namespace'::valueToString
PUBLIC	??_GFastWriter@Json@@UEAAPEAXI@Z		; Json::FastWriter::`scalar deleting destructor'
PUBLIC	??1FastWriter@Json@@UEAA@XZ			; Json::FastWriter::~FastWriter
PUBLIC	?uppercase@std@@YAAEAVios_base@1@AEAV21@@Z	; std::uppercase
PUBLIC	?strstr@@YAPEADPEADPEBD@Z			; strstr
PUBLIC	?fpclassify@@YAHN@Z				; fpclassify
PUBLIC	??1Writer@Json@@UEAA@XZ				; Json::Writer::~Writer
PUBLIC	?write@StyledWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z ; Json::StyledWriter::write
PUBLIC	??0StyledWriter@Json@@QEAA@XZ			; Json::StyledWriter::StyledWriter
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z ; Json::valueToString
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::valueToString
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
EXTRN	??_EStreamWriterBuilder@Json@@UEAAPEAXI@Z:PROC	; Json::StreamWriterBuilder::`vector deleting destructor'
EXTRN	??_EWriter@Json@@UEAAPEAXI@Z:PROC		; Json::Writer::`vector deleting destructor'
EXTRN	??_EFastWriter@Json@@UEAAPEAXI@Z:PROC		; Json::FastWriter::`vector deleting destructor'
EXTRN	??_EFactory@StreamWriter@Json@@UEAAPEAXI@Z:PROC	; Json::StreamWriter::Factory::`vector deleting destructor'
EXTRN	??_EStreamWriter@Json@@UEAAPEAXI@Z:PROC		; Json::StreamWriter::`vector deleting destructor'
EXTRN	??_EBuiltStyledStreamWriter@Json@@UEAAPEAXI@Z:PROC ; Json::BuiltStyledStreamWriter::`vector deleting destructor'
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$isfinite@N@@YA_NN@Z DD imagerel $LN6
	DD	imagerel $LN6+32
	DD	imagerel $unwind$??$isfinite@N@@YA_NN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ DD imagerel $LN949
	DD	imagerel $LN949+1575
	DD	imagerel $unwind$?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD imagerel ?dtor$7@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	imagerel ?dtor$7@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$7@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$13@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD imagerel ?dtor$13@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	imagerel ?dtor$13@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$13@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$19@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD imagerel ?dtor$19@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	imagerel ?dtor$19@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$19@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$25@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD imagerel ?dtor$25@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	imagerel ?dtor$25@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$25@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$31@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD imagerel ?dtor$31@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	imagerel ?dtor$31@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$31@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$37@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD imagerel ?dtor$37@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	imagerel ?dtor$37@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA+22
	DD	imagerel $unwind$?dtor$37@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1StreamWriterBuilder@Json@@UEAA@XZ DD imagerel $LN7
	DD	imagerel $LN7+58
	DD	imagerel $unwind$??1StreamWriterBuilder@Json@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z DD imagerel $LN11
	DD	imagerel $LN11+87
	DD	imagerel $unwind$??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GFactory@StreamWriter@Json@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$??_GFactory@StreamWriter@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GStreamWriter@Json@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$??_GStreamWriter@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel $LN120
	DD	imagerel $LN120+314
	DD	imagerel $unwind$?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel $LN116
	DD	imagerel $LN116+313
	DD	imagerel $unwind$?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN10
	DD	imagerel $LN10+38
	DD	imagerel $unwind$?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN10+38
	DD	imagerel $LN10+65
	DD	imagerel $chain$0$?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN10+65
	DD	imagerel $LN10+95
	DD	imagerel $chain$1$?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+11
	DD	imagerel $unwind$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ DD imagerel $LN7+11
	DD	imagerel $LN7+51
	DD	imagerel $chain$0$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ DD imagerel $LN7+51
	DD	imagerel $LN7+56
	DD	imagerel $chain$1$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ DD imagerel $LN7+56
	DD	imagerel $LN7+61
	DD	imagerel $chain$2$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z DD imagerel $LN99
	DD	imagerel $LN99+225
	DD	imagerel $unwind$?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z DD imagerel $LN99+225
	DD	imagerel $LN99+336
	DD	imagerel $chain$0$?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z DD imagerel $LN99+336
	DD	imagerel $LN99+382
	DD	imagerel $chain$1$?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel $LN349
	DD	imagerel $LN349+957
	DD	imagerel $unwind$?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel $LN714
	DD	imagerel $LN714+1484
	DD	imagerel $unwind$?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?write@BuiltStyledStreamWriter@Json@@UEAAHAEBVValue@2@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z DD imagerel $LN22
	DD	imagerel $LN22+182
	DD	imagerel $unwind$?write@BuiltStyledStreamWriter@Json@@UEAAHAEBVValue@2@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1BuiltStyledStreamWriter@Json@@UEAA@XZ DD imagerel $LN168
	DD	imagerel $LN168+249
	DD	imagerel $unwind$??1BuiltStyledStreamWriter@Json@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GBuiltStyledStreamWriter@Json@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+48
	DD	imagerel $unwind$??_GBuiltStyledStreamWriter@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z DD imagerel $LN226
	DD	imagerel $LN226+300
	DD	imagerel $unwind$??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel $LN138
	DD	imagerel $LN138+333
	DD	imagerel $unwind$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel $LN173
	DD	imagerel $LN173+449
	DD	imagerel $unwind$?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?indent@StyledWriter@Json@@AEAAXXZ DD imagerel $LN78
	DD	imagerel $LN78+133
	DD	imagerel $unwind$?indent@StyledWriter@Json@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeWithIndent@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN31
	DD	imagerel $LN31+134
	DD	imagerel $unwind$?writeWithIndent@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeIndent@StyledWriter@Json@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+96
	DD	imagerel $unwind$?writeIndent@StyledWriter@Json@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z DD imagerel $LN99
	DD	imagerel $LN99+222
	DD	imagerel $unwind$?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z DD imagerel $LN99+222
	DD	imagerel $LN99+326
	DD	imagerel $chain$0$?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z DD imagerel $LN99+326
	DD	imagerel $LN99+369
	DD	imagerel $chain$1$?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel $LN414
	DD	imagerel $LN414+927
	DD	imagerel $unwind$?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel $LN807
	DD	imagerel $LN807+1448
	DD	imagerel $unwind$?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel $LN438
	DD	imagerel $LN438+1064
	DD	imagerel $unwind$?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?write@FastWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z DD imagerel $LN69
	DD	imagerel $LN69+150
	DD	imagerel $unwind$?write@FastWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GWriter@Json@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$??_GWriter@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z DD imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+1237
	DD	imagerel $unwind$?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z DD imagerel $LN580
	DD	imagerel $LN580+1213
	DD	imagerel $unwind$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD imagerel $LN51
	DD	imagerel $LN51+94
	DD	imagerel $unwind$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?valueToString@?A0xcff6a387@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N_NI@Z DD imagerel $LN81
	DD	imagerel $LN81+474
	DD	imagerel $unwind$?valueToString@?A0xcff6a387@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N_NI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GFastWriter@Json@@UEAAPEAXI@Z DD imagerel $LN42
	DD	imagerel $LN42+101
	DD	imagerel $unwind$??_GFastWriter@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1FastWriter@Json@@UEAA@XZ DD imagerel $LN38
	DD	imagerel $LN38+72
	DD	imagerel $unwind$??1FastWriter@Json@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fpclassify@@YAHN@Z DD imagerel $LN4
	DD	imagerel $LN4+27
	DD	imagerel $unwind$?fpclassify@@YAHN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?write@StyledWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z DD imagerel $LN80
	DD	imagerel $LN80+208
	DD	imagerel $unwind$?write@StyledWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z DD imagerel $LN79
	DD	imagerel $LN79+34
	DD	imagerel $unwind$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z DD imagerel $LN79+34
	DD	imagerel $LN79+280
	DD	imagerel $chain$0$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z DD imagerel $LN79+280
	DD	imagerel $LN79+334
	DD	imagerel $chain$1$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DD imagerel $LN59
	DD	imagerel $LN59+173
	DD	imagerel $unwind$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z DD imagerel $LN6
	DD	imagerel $LN6+40
	DD	imagerel $unwind$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+34
	DD	imagerel $unwind$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z DD 020521H
	DD	0d3405H
	DD	imagerel $LN79
	DD	imagerel $LN79+34
	DD	imagerel $unwind$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z DD 021519H
	DD	070029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?write@StyledWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0e016521aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fpclassify@@YAHN@Z DD 010a01H
	DD	0420aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1FastWriter@Json@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GFastWriter@Json@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?valueToString@?A0xcff6a387@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N_NI@Z DD 061f19H
	DD	076810H
	DD	07004f20bH
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z DD imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z
	DD	0ffffffffH
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+205
	DD	00H
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+222
	DD	01H
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+241
	DD	00H
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+274
	DD	0ffffffffH
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+339
	DD	02H
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+523
	DD	00H
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+525
	DD	02H
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+737
	DD	03H
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+859
	DD	04H
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+879
	DD	03H
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+912
	DD	02H
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+1053
	DD	0ffffffffH
	DD	imagerel ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z+1096
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$3@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA
	DD	02H
	DD	imagerel ?dtor$4@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA
	DD	03H
	DD	imagerel ?dtor$5@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z
	DD	00H
	DD	00H
	DD	0eH
	DD	imagerel $ip2state$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z DD 093919H
	DD	03a3428H
	DD	0320117H
	DD	0e006f008H
	DD	060037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z
	DD	0182H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z DD imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z
	DD	0ffffffffH
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+236
	DD	02H
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+423
	DD	00H
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+425
	DD	02H
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+657
	DD	03H
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+779
	DD	04H
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+799
	DD	03H
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+832
	DD	02H
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+957
	DD	0ffffffffH
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+998
	DD	00H
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+1015
	DD	01H
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+1034
	DD	00H
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+1067
	DD	0ffffffffH
	DD	imagerel ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z+1120
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$3@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA
	DD	02H
	DD	imagerel ?dtor$4@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA
	DD	03H
	DD	imagerel ?dtor$5@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z
	DD	00H
	DD	00H
	DD	0eH
	DD	imagerel $ip2state$?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z DD 093419H
	DD	032011aH
	DD	0e009f00bH
	DD	07005c007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z
	DD	0182H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GWriter@Json@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?write@FastWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	0ffffffffH
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+93
	DD	00H
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+95
	DD	0ffffffffH
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+153
	DD	00H
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+173
	DD	0ffffffffH
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+214
	DD	01H
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+234
	DD	0ffffffffH
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+276
	DD	02H
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+296
	DD	0ffffffffH
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+388
	DD	03H
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+408
	DD	0ffffffffH
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+449
	DD	04H
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+469
	DD	0ffffffffH
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+631
	DD	05H
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+729
	DD	06H
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+749
	DD	05H
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+914
	DD	0ffffffffH
	DD	imagerel ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z+1032
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$3@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$4@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$5@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	05H
	DD	imagerel ?dtor$6@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z DD 019930522H
	DD	07H
	DD	imagerel $stateUnwindMap$?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	00H
	DD	00H
	DD	012H
	DD	imagerel $ip2state$?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z DD 072f19H
	DD	02a3421H
	DD	0240110H
	DD	060037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	011aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	0ffffffffH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+99
	DD	00H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+101
	DD	0ffffffffH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+140
	DD	00H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+178
	DD	0ffffffffH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+219
	DD	01H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+256
	DD	0ffffffffH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+297
	DD	02H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+334
	DD	0ffffffffH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+378
	DD	03H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+415
	DD	0ffffffffH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+500
	DD	04H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+537
	DD	0ffffffffH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+595
	DD	05H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+633
	DD	0ffffffffH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+677
	DD	06H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+714
	DD	0ffffffffH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+770
	DD	07H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+825
	DD	08H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+864
	DD	07H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+946
	DD	09H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+959
	DD	07H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+1062
	DD	0aH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+1074
	DD	07H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+1250
	DD	0bH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+1264
	DD	07H
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+1299
	DD	0ffffffffH
	DD	imagerel ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+1416
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$3@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$4@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$5@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$6@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$7@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	07H
	DD	imagerel ?dtor$8@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	07H
	DD	imagerel ?dtor$9@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	07H
	DD	imagerel ?dtor$10@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	07H
	DD	imagerel ?dtor$11@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 019930522H
	DD	0cH
	DD	imagerel $stateUnwindMap$?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	00H
	DD	00H
	DD	01cH
	DD	imagerel $ip2state$?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 073519H
	DD	03e3424H
	DD	0380113H
	DD	060037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	01baH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel ?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	0ffffffffH
	DD	imagerel ?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+147
	DD	01H
	DD	imagerel ?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+248
	DD	0ffffffffH
	DD	imagerel ?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+575
	DD	02H
	DD	imagerel ?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+668
	DD	0ffffffffH
	DD	imagerel ?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+832
	DD	00H
	DD	imagerel ?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+871
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	00H
	DD	00H
	DD	07H
	DD	imagerel $ip2state$?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 0a3019H
	DD	0143421H
	DD	0f00c9210H
	DD	0d008e00aH
	DD	07004c006H
	DD	050026003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z DD 021H
	DD	imagerel $LN99
	DD	imagerel $LN99+222
	DD	imagerel $unwind$?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z DD 020521H
	DD	0af405H
	DD	imagerel $LN99
	DD	imagerel $LN99+222
	DD	imagerel $unwind$?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0e0123216H
	DD	0c00ed010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeIndent@StyledWriter@Json@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeWithIndent@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?indent@StyledWriter@Json@@AEAAXXZ DD imagerel ?indent@StyledWriter@Json@@AEAAXXZ
	DD	0ffffffffH
	DD	imagerel ?indent@StyledWriter@Json@@AEAAXXZ+73
	DD	00H
	DD	imagerel ?indent@StyledWriter@Json@@AEAAXXZ+95
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?indent@StyledWriter@Json@@AEAAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??indent@StyledWriter@Json@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?indent@StyledWriter@Json@@AEAAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?indent@StyledWriter@Json@@AEAAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?indent@StyledWriter@Json@@AEAAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?indent@StyledWriter@Json@@AEAAXXZ DD 021e19H
	DD	030029206H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?indent@StyledWriter@Json@@AEAAXXZ
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel ?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	0ffffffffH
	DD	imagerel ?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+184
	DD	00H
	DD	imagerel ?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+401
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 062819H
	DD	0f6419H
	DD	0e3414H
	DD	070029206H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	0ffffffffH
	DD	imagerel ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+84
	DD	00H
	DD	imagerel ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+105
	DD	01H
	DD	imagerel ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+125
	DD	00H
	DD	imagerel ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+167
	DD	0ffffffffH
	DD	imagerel ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+247
	DD	02H
	DD	imagerel ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z+266
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	00H
	DD	00H
	DD	07H
	DD	imagerel $ip2state$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z DD 042619H
	DD	0123417H
	DD	07002d206H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	06aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z DD imagerel ??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z
	DD	0ffffffffH
	DD	imagerel ??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z+49
	DD	00H
	DD	imagerel ??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z+71
	DD	01H
	DD	imagerel ??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z+87
	DD	02H
	DD	imagerel ??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z+126
	DD	03H
	DD	imagerel ??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z+164
	DD	04H
	DD	imagerel ??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z+204
	DD	05H
	DD	imagerel ??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z+276
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA
	DD	03H
	DD	imagerel ?dtor$4@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA
	DD	04H
	DD	imagerel ?dtor$5@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z
	DD	00H
	DD	00H
	DD	08H
	DD	imagerel $ip2state$??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z DD 082211H
	DD	0b6422H
	DD	0a541dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GBuiltStyledStreamWriter@Json@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1BuiltStyledStreamWriter@Json@@UEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?write@BuiltStyledStreamWriter@Json@@UEAAHAEBVValue@2@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	0ffffffffH
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+99
	DD	00H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+101
	DD	0ffffffffH
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+166
	DD	00H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+199
	DD	0ffffffffH
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+240
	DD	01H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+273
	DD	0ffffffffH
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+338
	DD	02H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+371
	DD	0ffffffffH
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+457
	DD	03H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+490
	DD	0ffffffffH
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+548
	DD	04H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+582
	DD	0ffffffffH
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+623
	DD	05H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+656
	DD	0ffffffffH
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+709
	DD	06H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+764
	DD	07H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+799
	DD	06H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+881
	DD	08H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+945
	DD	06H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+1066
	DD	09H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+1078
	DD	06H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+1244
	DD	0aH
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+1304
	DD	06H
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+1339
	DD	0ffffffffH
	DD	imagerel ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+1452
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$3@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$4@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$5@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$6@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	06H
	DD	imagerel ?dtor$7@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	06H
	DD	imagerel ?dtor$8@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	06H
	DD	imagerel ?dtor$9@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	06H
	DD	imagerel ?dtor$10@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 019930522H
	DD	0bH
	DD	imagerel $stateUnwindMap$?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	00H
	DD	00H
	DD	01aH
	DD	imagerel $ip2state$?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 073519H
	DD	03a3424H
	DD	0340113H
	DD	060037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	019aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel ?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	0ffffffffH
	DD	imagerel ?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+319
	DD	01H
	DD	imagerel ?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+381
	DD	0ffffffffH
	DD	imagerel ?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+761
	DD	02H
	DD	imagerel ?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+821
	DD	0ffffffffH
	DD	imagerel ?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+866
	DD	00H
	DD	imagerel ?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+901
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	00H
	DD	00H
	DD	07H
	DD	imagerel $ip2state$?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 0a3019H
	DD	0163421H
	DD	0f00cb210H
	DD	0d008e00aH
	DD	07004c006H
	DD	050026003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z DD 021H
	DD	imagerel $LN99
	DD	imagerel $LN99+225
	DD	imagerel $unwind$?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z DD 020521H
	DD	0ac405H
	DD	imagerel $LN99
	DD	imagerel $LN99+225
	DD	imagerel $unwind$?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0f0123216H
	DD	0d00ee010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ DD 021H
	DD	imagerel $LN7
	DD	imagerel $LN7+11
	DD	imagerel $unwind$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ DD 021H
	DD	imagerel $LN7
	DD	imagerel $LN7+11
	DD	imagerel $unwind$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ DD 020521H
	DD	043405H
	DD	imagerel $LN7
	DD	imagerel $LN7+11
	DD	imagerel $unwind$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+38
	DD	imagerel $unwind$?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN10
	DD	imagerel $LN10+38
	DD	imagerel $unwind$?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel ?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	0ffffffffH
	DD	imagerel ?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+135
	DD	00H
	DD	imagerel ?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+265
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 062819H
	DD	0f6419H
	DD	0e3414H
	DD	070029206H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD imagerel ?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	0ffffffffH
	DD	imagerel ?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+90
	DD	00H
	DD	imagerel ?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+111
	DD	01H
	DD	imagerel ?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+124
	DD	00H
	DD	imagerel ?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+166
	DD	0ffffffffH
	DD	imagerel ?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+251
	DD	02H
	DD	imagerel ?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z+264
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	00H
	DD	00H
	DD	07H
	DD	imagerel $ip2state$?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z DD 062719H
	DD	0136418H
	DD	0123414H
	DD	07004d208H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
	DD	06aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GStreamWriter@Json@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GFactory@StreamWriter@Json@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z DD imagerel ??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z
	DD	0ffffffffH
	DD	imagerel ??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z+39
	DD	00H
	DD	imagerel ??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z+49
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???_GStreamWriterBuilder@Json@@UEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1StreamWriterBuilder@Json@@UEAA@XZ DD imagerel ??1StreamWriterBuilder@Json@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1StreamWriterBuilder@Json@@UEAA@XZ+32
	DD	00H
	DD	imagerel ??1StreamWriterBuilder@Json@@UEAA@XZ+42
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1StreamWriterBuilder@Json@@UEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1StreamWriterBuilder@Json@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1StreamWriterBuilder@Json@@UEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1StreamWriterBuilder@Json@@UEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1StreamWriterBuilder@Json@@UEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1StreamWriterBuilder@Json@@UEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1StreamWriterBuilder@Json@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$37@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$31@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$25@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$19@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$13@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ DD imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ
	DD	0ffffffffH
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+117
	DD	00H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+165
	DD	0ffffffffH
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+181
	DD	02H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+227
	DD	03H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+275
	DD	02H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+291
	DD	05H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+337
	DD	06H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+385
	DD	05H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+447
	DD	08H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+494
	DD	05H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+556
	DD	0aH
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+603
	DD	05H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+665
	DD	0cH
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+712
	DD	05H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+949
	DD	0fH
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1039
	DD	010H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1092
	DD	011H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1111
	DD	012H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1124
	DD	013H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1146
	DD	014H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1158
	DD	015H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1197
	DD	016H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1233
	DD	017H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1268
	DD	018H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1330
	DD	012H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1339
	DD	010H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1356
	DD	0fH
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1389
	DD	05H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1422
	DD	02H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1455
	DD	0ffffffffH
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1477
	DD	05H
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1520
	DD	0eH
	DD	imagerel ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ+1530
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ DD 0ffffffffH
	DD	imagerel ?dtor$7@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	02H
	DD	imagerel ?dtor$13@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	03H
	DD	00H
	DD	02H
	DD	imagerel ?dtor$1@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	05H
	DD	imagerel ?dtor$19@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	06H
	DD	00H
	DD	05H
	DD	imagerel ?dtor$25@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	08H
	DD	00H
	DD	05H
	DD	imagerel ?dtor$31@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	0aH
	DD	00H
	DD	05H
	DD	imagerel ?dtor$37@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	0cH
	DD	00H
	DD	05H
	DD	imagerel ?dtor$2@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	05H
	DD	imagerel ?dtor$3@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	0fH
	DD	imagerel ?dtor$4@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	010H
	DD	imagerel ?dtor$5@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	011H
	DD	imagerel ?dtor$6@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	012H
	DD	imagerel ?dtor$43@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	013H
	DD	imagerel ?dtor$44@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	014H
	DD	imagerel ?dtor$45@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	015H
	DD	imagerel ?dtor$46@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	016H
	DD	imagerel ?dtor$47@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
	DD	017H
	DD	imagerel ?dtor$48@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ DD 019930522H
	DD	019H
	DD	imagerel $stateUnwindMap$?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ
	DD	00H
	DD	00H
	DD	022H
	DD	imagerel $ip2state$?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ DD 0d3a19H
	DD	025742cH
	DD	0246428H
	DD	0233424H
	DD	01c0117H
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ
	DD	0d2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$isfinite@N@@YA_NN@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
value$ = 72
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z PROC ; Json::valueToString, COMDAT

; 176  : JSONCPP_STRING valueToString(double value) { return valueToString(value, false, 17); }

$LN6:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	r9d, 17
	xor	r8d, r8d
	mov	rbx, rcx
	mov	DWORD PTR $T1[rsp], 0
	call	?valueToString@?A0xcff6a387@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N_NI@Z ; Json::`anonymous namespace'::valueToString
	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
_TEXT	SEGMENT
$T1 = 32
buffer$ = 40
__$ArrayPad$ = 72
__$ReturnUdt$ = 96
value$ = 104
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z PROC ; Json::valueToString, COMDAT

; 118  : JSONCPP_STRING valueToString(LargestUInt value) {

$LN59:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	xor	r8d, r8d
	mov	r9, rdx
	mov	rbx, rcx
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 82   :   *--current = 0;

	lea	r10, QWORD PTR buffer$[rsp+24]
	mov	r11, -3689348814741910323		; cccccccccccccccdH
	mov	DWORD PTR $T1[rsp], r8d
	mov	BYTE PTR buffer$[rsp+24], r8b
	npad	9
$LL7@valueToStr:

; 83   :   do {
; 84   :     *--current = static_cast<char>(value % 10U + static_cast<unsigned>('0'));

	dec	r10
	mov	rax, r11
	mul	r9
	shr	rdx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r9b, cl
	add	r9b, 48					; 00000030H
	mov	BYTE PTR [r10], r9b

; 85   :     value /= 10;

	mov	r9, rdx

; 86   :   } while (value != 0);

	test	rdx, rdx
	jne	SHORT $LL7@valueToStr
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], r8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], r8b

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [r10], r8b
	je	SHORT $LN53@valueToStr
	or	r8, -1
$LL57@valueToStr:
	inc	r8
	cmp	BYTE PTR [r10+r8], 0
	jne	SHORT $LL57@valueToStr
$LN53@valueToStr:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	rdx, r10
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 123  :   return current;

	mov	rax, rbx

; 124  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z
_TEXT	SEGMENT
$T1 = 32
buffer$ = 40
__$ArrayPad$ = 72
__$ReturnUdt$ = 96
value$ = 104
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z PROC ; Json::valueToString, COMDAT

; 102  : JSONCPP_STRING valueToString(LargestInt value) {

$LN79:
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	xor	r10d, r10d

; 105  :   if (value == Value::minLargestInt) {

	mov	r11, -9223372036854775808		; 8000000000000000H
	mov	QWORD PTR [rsp+104], rbx
	mov	rdi, rcx
	mov	r9, rdx
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 82   :   *--current = 0;

	mov	rbx, -3689348814741910323		; cccccccccccccccdH
	mov	DWORD PTR $T1[rsp], r10d
	mov	BYTE PTR buffer$[rsp+24], r10b
	lea	rcx, QWORD PTR buffer$[rsp+24]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 105  :   if (value == Value::minLargestInt) {

	cmp	rdx, r11
	jne	SHORT $LN4@valueToStr
	npad	5
$LL11@valueToStr:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 84   :     *--current = static_cast<char>(value % 10U + static_cast<unsigned>('0'));

	mov	rax, rbx
	dec	rcx
	mul	r11
	mov	r8, rdx
	shr	r8, 3
	movzx	eax, r8b
	shl	al, 2
	lea	edx, DWORD PTR [rax+r8]
	add	dl, dl
	sub	r11b, dl
	add	r11b, 48				; 00000030H
	mov	BYTE PTR [rcx], r11b

; 85   :     value /= 10;

	mov	r11, r8

; 86   :   } while (value != 0);

	test	r8, r8
	jne	SHORT $LL11@valueToStr
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 107  :     *--current = '-';

	dec	rcx
	mov	BYTE PTR [rcx], 45			; 0000002dH
	jmp	SHORT $LN19@valueToStr
$LN4@valueToStr:

; 108  :   } else if (value < 0) {

	test	rdx, rdx
	jns	SHORT $LL21@valueToStr

; 109  :     uintToString(LargestUInt(-value), current);

	neg	r9
	npad	1
$LL16@valueToStr:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 84   :     *--current = static_cast<char>(value % 10U + static_cast<unsigned>('0'));

	mov	rax, rbx
	dec	rcx
	mul	r9
	mov	r8, rdx
	shr	r8, 3
	movzx	eax, r8b
	shl	al, 2
	lea	edx, DWORD PTR [rax+r8]
	add	dl, dl
	sub	r9b, dl
	add	r9b, 48					; 00000030H
	mov	BYTE PTR [rcx], r9b

; 85   :     value /= 10;

	mov	r9, r8

; 86   :   } while (value != 0);

	test	r8, r8
	jne	SHORT $LL16@valueToStr
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 110  :     *--current = '-';

	dec	rcx
	mov	BYTE PTR [rcx], 45			; 0000002dH

; 111  :   } else {

	jmp	SHORT $LN19@valueToStr
	npad	9
$LL21@valueToStr:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 84   :     *--current = static_cast<char>(value % 10U + static_cast<unsigned>('0'));

	mov	rax, rbx
	dec	rcx
	mul	r9
	mov	r8, rdx
	shr	r8, 3
	movzx	eax, r8b
	shl	al, 2
	lea	edx, DWORD PTR [rax+r8]
	add	dl, dl
	sub	r9b, dl
	add	r9b, 48					; 00000030H
	mov	BYTE PTR [rcx], r9b

; 85   :     value /= 10;

	mov	r9, r8

; 86   :   } while (value != 0);

	test	r8, r8
	jne	SHORT $LL21@valueToStr
$LN19@valueToStr:
	mov	rbx, QWORD PTR [rsp+104]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], r10
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi], r10b

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [rcx], r10b
	je	SHORT $LN67@valueToStr
	or	r10, -1
	npad	4
$LL77@valueToStr:
	inc	r10
	cmp	BYTE PTR [rcx+r10], 0
	jne	SHORT $LL77@valueToStr
$LN67@valueToStr:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	rdx, rcx
	mov	r8, r10
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 115  :   return current;

	mov	rax, rdi

; 116  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??0StyledWriter@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0StyledWriter@Json@@QEAA@XZ PROC			; Json::StyledWriter::StyledWriter, COMDAT

; 403  :     : rightMargin_(74), indentSize_(3), addChildValues_() {}

	lea	rax, OFFSET FLAT:??_7StyledWriter@Json@@6B@
	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+16], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+24], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+48], rax

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+56], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx+32], al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+80], rax

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+88], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx+64], al
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 403  :     : rightMargin_(74), indentSize_(3), addChildValues_() {}

	mov	BYTE PTR [rcx+104], al
	mov	DWORD PTR [rcx+96], 74			; 0000004aH
	mov	DWORD PTR [rcx+100], 3
	mov	rax, rcx
	ret	0
??0StyledWriter@Json@@QEAA@XZ ENDP			; Json::StyledWriter::StyledWriter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?write@StyledWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
root$ = 80
?write@StyledWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z PROC ; Json::StyledWriter::write, COMDAT

; 405  : JSONCPP_STRING StyledWriter::write(const Value& root) {

$LN80:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H
	xor	r14d, r14d
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+56], 16
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 405  : JSONCPP_STRING StyledWriter::write(const Value& root) {

	mov	rbp, r8
	mov	rsi, rdx
	mov	rdi, rcx
	mov	DWORD PTR $T1[rsp], r14d
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+48], r14

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN11@write
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rcx+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN12@write
$LN11@write:
	lea	rax, QWORD PTR [rcx+32]
$LN12@write:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax], r14b
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 408  :   indentString_.clear();

	lea	rax, QWORD PTR [rcx+64]
	mov	BYTE PTR [rcx+104], r14b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rax+24], 16

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rax+16], r14

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN23@write
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rax]
$LN23@write:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 409  :   writeCommentBeforeValue(root);

	mov	rdx, r8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax], r14b
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 409  :   writeCommentBeforeValue(root);

	call	?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 410  :   writeValue(root);

	mov	rdx, rbp
	mov	rcx, rdi
	call	?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeValue

; 411  :   writeCommentAfterValueOnSameLine(root);

	mov	rdx, rbp
	mov	rcx, rdi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	lea	rcx, QWORD PTR [rdi+32]
	mov	r8d, 1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rsi+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rsi+16], r14

; 726  : 		assign(_Right, 0, npos);

	lea	rdx, QWORD PTR [rdi+32]
	or	r9, -1
	xor	r8d, r8d
	mov	rcx, rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rsi], r14b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 414  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?write@StyledWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z ENDP ; Json::StyledWriter::write
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??1Writer@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Writer@Json@@UEAA@XZ PROC				; Json::Writer::~Writer, COMDAT

; 322  : Writer::~Writer() {}

	lea	rax, OFFSET FLAT:??_7Writer@Json@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1Writer@Json@@UEAA@XZ ENDP				; Json::Writer::~Writer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT ?fpclassify@@YAHN@Z
_TEXT	SEGMENT
_X$ = 48
?fpclassify@@YAHN@Z PROC				; fpclassify, COMDAT

; 310  : {

$LN4:
	movsdx	QWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 311  :     return (_dtest(&_X));

	lea	rcx, QWORD PTR _X$[rsp]
	call	QWORD PTR __imp__dtest
	cwde

; 312  : }

	add	rsp, 40					; 00000028H
	ret	0
?fpclassify@@YAHN@Z ENDP				; fpclassify
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ?strstr@@YAPEADPEADPEBD@Z
_TEXT	SEGMENT
_Str$ = 8
_SubStr$ = 16
?strstr@@YAPEADPEADPEBD@Z PROC				; strstr, COMDAT

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	rex_jmp	QWORD PTR __imp_strstr
?strstr@@YAPEADPEADPEBD@Z ENDP				; strstr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
;	COMDAT ?uppercase@std@@YAAEAVios_base@1@AEAV21@@Z
_TEXT	SEGMENT
_Iosbase$ = 8
?uppercase@std@@YAAEAVios_base@1@AEAV21@@Z PROC		; std::uppercase, COMDAT
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 381  : 			| ((int)_Newfmtflags & (int)_Fmtmask));

	or	DWORD PTR [rcx+24], 4
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 354  : 	return (_Iosbase);

	mov	rax, rcx

; 355  : 	}

	ret	0
?uppercase@std@@YAAEAVios_base@1@AEAV21@@Z ENDP		; std::uppercase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\include\json\writer.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\include\json\writer.h
;	COMDAT ??1FastWriter@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1FastWriter@Json@@UEAA@XZ PROC			; Json::FastWriter::~FastWriter, COMDAT

; 163  :   ~FastWriter() JSONCPP_OVERRIDE {}

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7FastWriter@Json@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rcx+32], 16
	jb	SHORT $LN23@FastWriter
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN23@FastWriter:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+32], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+24], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 322  : Writer::~Writer() {}

	lea	rax, OFFSET FLAT:??_7Writer@Json@@6B@
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+8], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 322  : Writer::~Writer() {}

	mov	QWORD PTR [rbx], rax
; File e:\jsoncpp-master\include\json\writer.h

; 163  :   ~FastWriter() JSONCPP_OVERRIDE {}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1FastWriter@Json@@UEAA@XZ ENDP			; Json::FastWriter::~FastWriter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\include\json\writer.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??_GFastWriter@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GFastWriter@Json@@UEAAPEAXI@Z PROC			; Json::FastWriter::`scalar deleting destructor', COMDAT
$LN42:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File e:\jsoncpp-master\include\json\writer.h

; 163  :   ~FastWriter() JSONCPP_OVERRIDE {}

	lea	rax, OFFSET FLAT:??_7FastWriter@Json@@6B@
	mov	edi, edx
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rcx+32], 16
	jb	SHORT $LN26@scalar
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN26@scalar:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+32], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+24], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 322  : Writer::~Writer() {}

	lea	rax, OFFSET FLAT:??_7Writer@Json@@6B@
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+8], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 322  : Writer::~Writer() {}

	mov	QWORD PTR [rbx], rax
	test	dil, 1
	je	SHORT $LN40@scalar
	mov	rcx, rbx
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN40@scalar:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GFastWriter@Json@@UEAAPEAXI@Z ENDP			; Json::FastWriter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_tool.h
;	COMDAT ?isControlCharacter@Json@@YA_ND@Z
_TEXT	SEGMENT
ch$ = 8
?isControlCharacter@Json@@YA_ND@Z PROC			; Json::isControlCharacter, COMDAT

; 65   : static inline bool isControlCharacter(char ch) { return ch > 0 && ch <= 0x1F; }

	dec	cl
	cmp	cl, 30
	setbe	al
	ret	0
?isControlCharacter@Json@@YA_ND@Z ENDP			; Json::isControlCharacter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_tool.h
;	COMDAT ?uintToString@Json@@YAX_KAEAPEAD@Z
_TEXT	SEGMENT
value$ = 8
current$ = 16
?uintToString@Json@@YAX_KAEAPEAD@Z PROC			; Json::uintToString, COMDAT

; 82   :   *--current = 0;

	dec	QWORD PTR [rdx]
	mov	r9, QWORD PTR [rdx]
	mov	r10, rdx
	mov	BYTE PTR [r9], 0
	mov	r11, -3689348814741910323		; cccccccccccccccdH
	npad	9
$LL3@uintToStri:

; 83   :   do {
; 84   :     *--current = static_cast<char>(value % 10U + static_cast<unsigned>('0'));

	dec	r9
	mov	rax, r11
	mov	QWORD PTR [r10], r9
	mul	rcx
	shr	rdx, 3
	movzx	eax, dl
	shl	al, 2
	lea	r8d, DWORD PTR [rax+rdx]
	add	r8b, r8b
	sub	cl, r8b
	add	cl, 48					; 00000030H
	mov	BYTE PTR [r9], cl

; 85   :     value /= 10;

	mov	rcx, rdx

; 86   :   } while (value != 0);

	test	rdx, rdx
	jne	SHORT $LL3@uintToStri

; 87   : }

	ret	0
?uintToString@Json@@YAX_KAEAPEAD@Z ENDP			; Json::uintToString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_tool.h
;	COMDAT ?fixNumericLocale@Json@@YAXPEAD0@Z
_TEXT	SEGMENT
begin$ = 8
end$ = 16
?fixNumericLocale@Json@@YAXPEAD0@Z PROC			; Json::fixNumericLocale, COMDAT

; 94   : static inline void fixNumericLocale(char* begin, char* end) {

	xor	eax, eax
	mov	r8, rdx
	sub	r8, rcx
	cmp	rcx, rdx
	cmova	r8, rax

; 95   :   while (begin < end) {

	test	r8, r8
	je	SHORT $LN2@fixNumeric
$LL8@fixNumeric:

; 96   :     if (*begin == ',') {

	cmp	BYTE PTR [rcx], 44			; 0000002cH
	jne	SHORT $LN9@fixNumeric

; 97   :       *begin = '.';

	mov	BYTE PTR [rcx], 46			; 0000002eH
$LN9@fixNumeric:

; 98   :     }
; 99   :     ++begin;

	inc	rax
	inc	rcx
	cmp	rax, r8
	jb	SHORT $LL8@fixNumeric
$LN2@fixNumeric:

; 100  :   }
; 101  : }

	ret	0
?fixNumericLocale@Json@@YAXPEAD0@Z ENDP			; Json::fixNumericLocale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?containsControlCharacter@Json@@YA_NPEBD@Z
_TEXT	SEGMENT
str$ = 8
?containsControlCharacter@Json@@YA_NPEBD@Z PROC		; Json::containsControlCharacter, COMDAT

; 85   :   while (*str) {

	movzx	eax, BYTE PTR [rcx]
	test	al, al
	je	SHORT $LN2@containsCo
	npad	9
$LL3@containsCo:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 65   : static inline bool isControlCharacter(char ch) { return ch > 0 && ch <= 0x1F; }

	dec	al
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 86   :     if (isControlCharacter(*(str++)))

	lea	rcx, QWORD PTR [rcx+1]
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 65   : static inline bool isControlCharacter(char ch) { return ch > 0 && ch <= 0x1F; }

	cmp	al, 30
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 86   :     if (isControlCharacter(*(str++)))

	jbe	SHORT $LN11@containsCo

; 85   :   while (*str) {

	movzx	eax, BYTE PTR [rcx]
	test	al, al
	jne	SHORT $LL3@containsCo
$LN2@containsCo:

; 88   :   }
; 89   :   return false;

	xor	al, al

; 90   : }

	ret	0
$LN11@containsCo:

; 87   :       return true;

	mov	al, 1

; 90   : }

	ret	0
?containsControlCharacter@Json@@YA_NPEBD@Z ENDP		; Json::containsControlCharacter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?containsControlCharacter0@Json@@YA_NPEBDI@Z
_TEXT	SEGMENT
str$ = 8
len$ = 16
?containsControlCharacter0@Json@@YA_NPEBDI@Z PROC	; Json::containsControlCharacter0, COMDAT

; 93   :   char const* end = str + len;

	mov	r8d, edx
	add	r8, rcx
$LN20@containsCo:

; 94   :   while (end != str) {

	cmp	r8, rcx
	je	SHORT $LN3@containsCo

; 95   :     if (isControlCharacter(*str) || 0==*str)

	movzx	edx, BYTE PTR [rcx]
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 65   : static inline bool isControlCharacter(char ch) { return ch > 0 && ch <= 0x1F; }

	lea	eax, DWORD PTR [rdx-1]
	cmp	al, 30
	jbe	SHORT $LN12@containsCo
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 95   :     if (isControlCharacter(*str) || 0==*str)

	test	dl, dl
	je	SHORT $LN12@containsCo

; 97   :     ++str;

	inc	rcx

; 94   :   while (end != str) {

	jmp	SHORT $LN20@containsCo
$LN12@containsCo:

; 96   :       return true;

	mov	al, 1

; 100  : }

	ret	0
$LN3@containsCo:

; 98   :   }
; 99   :   return false;

	xor	al, al

; 100  : }

	ret	0
?containsControlCharacter0@Json@@YA_NPEBDI@Z ENDP	; Json::containsControlCharacter0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@?A0xcff6a387@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N_NI@Z
_TEXT	SEGMENT
$T1 = 32
_X$ = 40
buffer$ = 48
formatString$ = 88
__$ArrayPad$ = 96
__$ReturnUdt$ = 160
value$ = 168
useSpecialFloats$ = 176
precision$ = 184
?valueToString@?A0xcff6a387@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N_NI@Z PROC ; Json::`anonymous namespace'::valueToString, COMDAT

; 139  : JSONCPP_STRING valueToString(double value, bool useSpecialFloats, unsigned int precision) {

$LN81:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 128				; 00000080H
	movaps	XMMWORD PTR [rsp+112], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rcx
	movzx	esi, r8b

; 140  :   // Allocate a buffer that is more than large enough to store the 16 digits of
; 141  :   // precision requested below.
; 142  :   char buffer[36];
; 143  :   int len = -1;
; 144  : 
; 145  :   char formatString[6];
; 146  :   sprintf(formatString, "%%.%dg", precision);

	lea	rdx, OFFSET FLAT:??_C@_06CEAIPCMK@?$CF?$CF?4?$CFdg?$AA@
	lea	rcx, QWORD PTR formatString$[rsp]
	xor	ebx, ebx
	mov	r8d, r9d
	movaps	xmm6, xmm1
	mov	DWORD PTR $T1[rsp], ebx
	call	QWORD PTR __imp_sprintf
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 311  :     return (_dtest(&_X));

	lea	rcx, QWORD PTR _X$[rsp]

; 312  : }
; 313  : 
; 314  : inline __nothrow int fpclassify(long double _X)
; 315  : {
; 316  :     return (_ldtest(&_X));
; 317  : }
; 318  : 
; 319  : inline __nothrow bool signbit(float _X)
; 320  : {
; 321  :     return (_fdsign(_X) != 0);
; 322  : }
; 323  : 
; 324  : inline __nothrow bool signbit(double _X)
; 325  : {
; 326  :     return (_dsign(_X) != 0);
; 327  : }
; 328  : 
; 329  : inline __nothrow bool signbit(long double _X)
; 330  : {
; 331  :     return (_ldsign(_X) != 0);
; 332  : }
; 333  : 
; 334  : inline __nothrow int _fpcomp(float _X, float _Y)
; 335  : {
; 336  :     return (_fdpcomp(_X, _Y));
; 337  : }
; 338  : 
; 339  : inline __nothrow int _fpcomp(double _X, double _Y)
; 340  : {
; 341  :     return (_dpcomp(_X, _Y));
; 342  : }
; 343  : 
; 344  : inline __nothrow int _fpcomp(long double _X, long double _Y)
; 345  : {
; 346  :     return (_ldpcomp(_X, _Y));
; 347  : }
; 348  : 
; 349  : template<class _Trc, class _Tre> struct _Combined_type
; 350  : {	// determine combined type
; 351  :     typedef float _Type;	// (real, float) is float
; 352  : };
; 353  : 
; 354  : template<> struct _Combined_type<float, double>
; 355  : {	// determine combined type
; 356  :     typedef double _Type;
; 357  : };
; 358  : 
; 359  : template<> struct _Combined_type<float, long double>
; 360  : {	// determine combined type
; 361  :     typedef long double _Type;
; 362  : };
; 363  : 
; 364  : template<class _Ty, class _T2> struct _Real_widened
; 365  : {	// determine widened real type
; 366  :     typedef long double _Type;	// default is long double
; 367  : };
; 368  : 
; 369  : template<> struct _Real_widened<float, float>
; 370  : {	// determine widened real type
; 371  :     typedef float _Type;
; 372  : };
; 373  : 
; 374  : template<> struct _Real_widened<float, double>
; 375  : {	// determine widened real type
; 376  :     typedef double _Type;
; 377  : };
; 378  : 
; 379  : template<> struct _Real_widened<double, float>
; 380  : {	// determine widened real type
; 381  :     typedef double _Type;
; 382  : };
; 383  : 
; 384  : template<> struct _Real_widened<double, double>
; 385  : {	// determine widened real type
; 386  :     typedef double _Type;
; 387  : };
; 388  : 
; 389  : template<class _Ty> struct _Real_type
; 390  : {	// determine equivalent real type
; 391  :     typedef double _Type;	// default is double
; 392  : };
; 393  : 
; 394  : template<> struct _Real_type<float>
; 395  : {	// determine equivalent real type
; 396  :     typedef float _Type;
; 397  : };
; 398  : 
; 399  : template<> struct _Real_type<long double>
; 400  : {	// determine equivalent real type
; 401  :     typedef long double _Type;
; 402  : };
; 403  : 
; 404  : template<class _T1, class _T2> inline __nothrow int _fpcomp(_T1 _X, _T2 _Y)
; 405  : {	// compare _Left and _Right
; 406  :     typedef typename _Combined_type<float,
; 407  :         typename _Real_widened<
; 408  :         typename _Real_type<_T1>::_Type,
; 409  :         typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
; 410  :     return (_fpcomp((_Tw)_X, (_Tw)_Y));
; 411  : }
; 412  : 
; 413  : template<class _Ty> inline __nothrow bool isfinite(_Ty _X)
; 414  : {
; 415  :     return (fpclassify(_X) <= 0);

	movsdx	QWORD PTR _X$[rsp], xmm6

; 311  :     return (_dtest(&_X));

	call	QWORD PTR __imp__dtest

; 312  : }
; 313  : 
; 314  : inline __nothrow int fpclassify(long double _X)
; 315  : {
; 316  :     return (_ldtest(&_X));
; 317  : }
; 318  : 
; 319  : inline __nothrow bool signbit(float _X)
; 320  : {
; 321  :     return (_fdsign(_X) != 0);
; 322  : }
; 323  : 
; 324  : inline __nothrow bool signbit(double _X)
; 325  : {
; 326  :     return (_dsign(_X) != 0);
; 327  : }
; 328  : 
; 329  : inline __nothrow bool signbit(long double _X)
; 330  : {
; 331  :     return (_ldsign(_X) != 0);
; 332  : }
; 333  : 
; 334  : inline __nothrow int _fpcomp(float _X, float _Y)
; 335  : {
; 336  :     return (_fdpcomp(_X, _Y));
; 337  : }
; 338  : 
; 339  : inline __nothrow int _fpcomp(double _X, double _Y)
; 340  : {
; 341  :     return (_dpcomp(_X, _Y));
; 342  : }
; 343  : 
; 344  : inline __nothrow int _fpcomp(long double _X, long double _Y)
; 345  : {
; 346  :     return (_ldpcomp(_X, _Y));
; 347  : }
; 348  : 
; 349  : template<class _Trc, class _Tre> struct _Combined_type
; 350  : {	// determine combined type
; 351  :     typedef float _Type;	// (real, float) is float
; 352  : };
; 353  : 
; 354  : template<> struct _Combined_type<float, double>
; 355  : {	// determine combined type
; 356  :     typedef double _Type;
; 357  : };
; 358  : 
; 359  : template<> struct _Combined_type<float, long double>
; 360  : {	// determine combined type
; 361  :     typedef long double _Type;
; 362  : };
; 363  : 
; 364  : template<class _Ty, class _T2> struct _Real_widened
; 365  : {	// determine widened real type
; 366  :     typedef long double _Type;	// default is long double
; 367  : };
; 368  : 
; 369  : template<> struct _Real_widened<float, float>
; 370  : {	// determine widened real type
; 371  :     typedef float _Type;
; 372  : };
; 373  : 
; 374  : template<> struct _Real_widened<float, double>
; 375  : {	// determine widened real type
; 376  :     typedef double _Type;
; 377  : };
; 378  : 
; 379  : template<> struct _Real_widened<double, float>
; 380  : {	// determine widened real type
; 381  :     typedef double _Type;
; 382  : };
; 383  : 
; 384  : template<> struct _Real_widened<double, double>
; 385  : {	// determine widened real type
; 386  :     typedef double _Type;
; 387  : };
; 388  : 
; 389  : template<class _Ty> struct _Real_type
; 390  : {	// determine equivalent real type
; 391  :     typedef double _Type;	// default is double
; 392  : };
; 393  : 
; 394  : template<> struct _Real_type<float>
; 395  : {	// determine equivalent real type
; 396  :     typedef float _Type;
; 397  : };
; 398  : 
; 399  : template<> struct _Real_type<long double>
; 400  : {	// determine equivalent real type
; 401  :     typedef long double _Type;
; 402  : };
; 403  : 
; 404  : template<class _T1, class _T2> inline __nothrow int _fpcomp(_T1 _X, _T2 _Y)
; 405  : {	// compare _Left and _Right
; 406  :     typedef typename _Combined_type<float,
; 407  :         typename _Real_widened<
; 408  :         typename _Real_type<_T1>::_Type,
; 409  :         typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
; 410  :     return (_fpcomp((_Tw)_X, (_Tw)_Y));
; 411  : }
; 412  : 
; 413  : template<class _Ty> inline __nothrow bool isfinite(_Ty _X)
; 414  : {
; 415  :     return (fpclassify(_X) <= 0);

	test	ax, ax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 151  :   if (isfinite(value)) {

	jg	SHORT $LN7@valueToStr

; 152  :     len = snprintf(buffer, sizeof(buffer), formatString, value);

	movaps	xmm3, xmm6
	lea	r8, QWORD PTR formatString$[rsp]
	lea	edx, QWORD PTR [rbx+36]
	lea	rcx, QWORD PTR buffer$[rsp]
	movd	r9, xmm3
	call	QWORD PTR __imp_sprintf_s
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_01LFCBOECM@?4?$AA@
	lea	rcx, QWORD PTR buffer$[rsp]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 152  :     len = snprintf(buffer, sizeof(buffer), formatString, value);

	mov	esi, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	call	QWORD PTR __imp_strstr
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 155  :     if (!strstr(buffer, ".") && !strstr(buffer, "e")) {

	test	rax, rax
	jne	$LN1@valueToStr
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_01KGKMHCOC@e?$AA@
	lea	rcx, QWORD PTR buffer$[rsp]
	call	QWORD PTR __imp_strstr
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 155  :     if (!strstr(buffer, ".") && !strstr(buffer, "e")) {

	test	rax, rax
	jne	$LN1@valueToStr

; 156  :       strcat(buffer, ".0");

	lea	rcx, QWORD PTR buffer$[rsp]
	dec	rcx
$LL78@valueToStr:
	cmp	BYTE PTR [rcx+1], bl
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL78@valueToStr
	movzx	eax, WORD PTR ??_C@_02ONCLHLPE@?40?$AA@
	mov	WORD PTR [rcx], ax
	movzx	eax, BYTE PTR ??_C@_02ONCLHLPE@?40?$AA@+2
	mov	BYTE PTR [rcx+2], al

; 157  :     }
; 158  : 
; 159  :   } else {

	jmp	SHORT $LN1@valueToStr
$LN7@valueToStr:

; 160  :     // IEEE standard states that NaN values will not compare to themselves
; 161  :     if (value != value) {

	ucomisd	xmm6, xmm6
	jp	SHORT $LN77@valueToStr
	jne	SHORT $LN77@valueToStr

; 163  :     } else if (value < 0) {
; 164  :       len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "-Infinity" : "-1e+9999");

	xorps	xmm0, xmm0
	mov	edx, 36					; 00000024H
	lea	rcx, QWORD PTR buffer$[rsp]
	comisd	xmm0, xmm6
	jbe	SHORT $LN2@valueToStr
	lea	rax, OFFSET FLAT:??_C@_09BLDCEMOH@?9Infinity?$AA@
	lea	r8, OFFSET FLAT:??_C@_08JDOGHFII@?91e?$CL9999?$AA@

; 165  :     } else {

	jmp	SHORT $LN79@valueToStr
$LN2@valueToStr:

; 166  :       len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "Infinity" : "1e+9999");

	lea	rax, OFFSET FLAT:??_C@_08KEBCLIFP@Infinity?$AA@
	lea	r8, OFFSET FLAT:??_C@_07GDHDNLLL@1e?$CL9999?$AA@
	jmp	SHORT $LN79@valueToStr
$LN77@valueToStr:

; 162  :       len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "NaN" : "null");

	lea	rax, OFFSET FLAT:??_C@_03ICJPMMHB@NaN?$AA@
	lea	r8, OFFSET FLAT:??_C@_04MLLLIHIP@null?$AA@
	mov	edx, 36					; 00000024H
	lea	rcx, QWORD PTR buffer$[rsp]
$LN79@valueToStr:
	test	sil, sil
	cmovne	r8, rax
	call	QWORD PTR __imp_sprintf_s
	mov	esi, eax
$LN1@valueToStr:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 95   :   while (begin < end) {

	movsxd	rax, esi
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 171  :   fixNumericLocale(buffer, buffer + len);

	lea	rcx, QWORD PTR buffer$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	add	rcx, rax
	lea	rax, QWORD PTR buffer$[rsp]
	mov	r8, rcx
	sub	r8, rax
	lea	rax, QWORD PTR buffer$[rsp]
	cmp	rax, rcx
	cmova	r8, rbx
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 95   :   while (begin < end) {

	test	r8, r8
	je	SHORT $LN21@valueToStr
	lea	rcx, QWORD PTR buffer$[rsp]
	neg	rcx
	npad	6
$LL71@valueToStr:

; 96   :     if (*begin == ',') {

	cmp	BYTE PTR [rdx], 44			; 0000002cH
	jne	SHORT $LN72@valueToStr

; 97   :       *begin = '.';

	mov	BYTE PTR [rdx], 46			; 0000002eH
$LN72@valueToStr:
	inc	rdx

; 95   :   while (begin < end) {

	lea	rax, QWORD PTR [rcx+rdx]
	cmp	rax, r8
	jb	SHORT $LL71@valueToStr
$LN21@valueToStr:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi], bl

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR buffer$[rsp], bl
	je	SHORT $LN68@valueToStr
	lea	rax, QWORD PTR buffer$[rsp]
	or	rbx, -1
$LL76@valueToStr:
	inc	rbx
	cmp	BYTE PTR [rax+rbx], 0
	jne	SHORT $LL76@valueToStr
$LN68@valueToStr:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	r8, rbx
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 172  :   return buffer;

	mov	rax, rdi

; 173  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm6, XMMWORD PTR [rsp+112]
	add	rsp, 128				; 00000080H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?valueToString@?A0xcff6a387@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N_NI@Z ENDP ; Json::`anonymous namespace'::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
value$ = 72
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; Json::valueToString, COMDAT

; 178  : JSONCPP_STRING valueToString(bool value) { return value ? "true" : "false"; }

$LN51:
	push	rbx
	sub	rsp, 48					; 00000030H
	xor	r8d, r8d
	mov	rbx, rcx
	test	dl, dl
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], r8
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 178  : JSONCPP_STRING valueToString(bool value) { return value ? "true" : "false"; }

	lea	rcx, OFFSET FLAT:??_C@_04LOAJBDKD@true?$AA@
	lea	rax, OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], r8b
	mov	DWORD PTR $T1[rsp], r8d
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 178  : JSONCPP_STRING valueToString(bool value) { return value ? "true" : "false"; }

	cmovne	rax, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [rax], r8b
	je	SHORT $LN48@valueToStr
	or	r8, -1
	npad	3
$LL49@valueToStr:
	inc	r8
	cmp	BYTE PTR [rax+r8], 0
	jne	SHORT $LL49@valueToStr
$LN48@valueToStr:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	rdx, rax
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 178  : JSONCPP_STRING valueToString(bool value) { return value ? "true" : "false"; }

	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 448
value$ = 456
?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z PROC ; Json::valueToQuotedString, COMDAT

; 180  : JSONCPP_STRING valueToQuotedString(const char* value) {

$LN580:
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-144]
	sub	rsp, 400				; 00000190H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rsp+464], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rbx, rdx
	mov	rsi, rcx
	xor	r14d, r14d
	mov	DWORD PTR $T1[rsp], r14d

; 181  :   if (value == NULL)

	test	rdx, rdx
	jne	SHORT $LN17@valueToQuo
	mov	QWORD PTR [rcx+24], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], r14b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 182  :     return "";

	jmp	$LN576@valueToQuo
$LN17@valueToQuo:

; 183  :   // Not sure how to handle unicode...
; 184  :   if (strpbrk(value, "\"\\\b\f\n\r\t") == NULL &&
; 185  :       !containsControlCharacter(value))

	lea	rdx, OFFSET FLAT:??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@
	mov	rcx, rbx
	call	QWORD PTR __imp_strpbrk
	test	rax, rax
	jne	$LN16@valueToQuo
	mov	rdx, rbx

; 85   :   while (*str) {

	cmp	BYTE PTR [rbx], r14b
	je	SHORT $LN72@valueToQuo
$LL73@valueToQuo:

; 86   :     if (isControlCharacter(*(str++)))

	movzx	eax, BYTE PTR [rdx]
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 65   : static inline bool isControlCharacter(char ch) { return ch > 0 && ch <= 0x1F; }

	dec	al
	cmp	al, 30
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 86   :     if (isControlCharacter(*(str++)))

	lea	rdx, QWORD PTR [rdx+1]
	jbe	$LN16@valueToQuo

; 85   :   while (*str) {

	cmp	BYTE PTR [rdx], r14b
	jne	SHORT $LL73@valueToQuo
$LN72@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T7[rbp-240], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T7[rbp-256], r14b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	lea	rcx, QWORD PTR $T7[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 186  :     return JSONCPP_STRING("\"") + value + "\"";

	mov	r8, rbx
	lea	rdx, QWORD PTR $T7[rbp-256]
	lea	rcx, QWORD PTR $T5[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@PEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	mov	rdx, rax
	mov	rcx, rsi
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@PEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T5[rbp-232], 16
	jb	SHORT $LN144@valueToQuo
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T5[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN144@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-240], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T7[rbp-232], 16
	jb	$LN576@valueToQuo
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T7[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 186  :     return JSONCPP_STRING("\"") + value + "\"";

	jmp	$LN576@valueToQuo
$LN16@valueToQuo:

; 187  :   // We have to walk value and escape any special characters.
; 188  :   // Appending to JSONCPP_STRING is not efficient, but this should be rare.
; 189  :   // (Note: forward slashes are *not* rare, but I am not escaping them.)
; 190  :   JSONCPP_STRING::size_type maxsize =
; 191  :       strlen(value) * 2 + 3; // allescaped+quotes+NULL

	or	rax, -1
$LL574@valueToQuo:
	lea	rax, QWORD PTR [rax+1]
	cmp	BYTE PTR [rbx+rax], r14b
	jne	SHORT $LL574@valueToQuo
	lea	rdi, QWORD PTR [rax*2+3]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, 15
	mov	QWORD PTR result$[rbp-232], rcx

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR result$[rbp-240], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR result$[rbp-256], r14b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)

	cmp	rdi, rcx
	je	SHORT $LN313@valueToQuo

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)

	cmp	rdi, -2
	jbe	SHORT $LN235@valueToQuo

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN235@valueToQuo:

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	cmp	rdi, 15
	jbe	SHORT $LN234@valueToQuo

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	xor	r8d, r8d
	mov	rdx, rdi
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	rcx, QWORD PTR result$[rbp-232]
	jmp	SHORT $LN293@valueToQuo
$LN234@valueToQuo:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	cmp	rdi, 16
	jae	SHORT $LN232@valueToQuo

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, 15
	mov	QWORD PTR result$[rbp-232], rcx

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)

	jmp	SHORT $LN577@valueToQuo
$LN232@valueToQuo:
	test	rdi, rdi
	jne	SHORT $LN579@valueToQuo
$LN577@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR result$[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR result$[rbp-240], r14
$LN293@valueToQuo:

; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	test	rdi, rdi

; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))

	je	SHORT $LN313@valueToQuo
$LN579@valueToQuo:

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR result$[rbp-240], r14

; 513  : 			: this->_Bx._Buf);

	lea	rax, QWORD PTR result$[rbp-256]
	cmp	rcx, 16
	cmovae	rax, QWORD PTR result$[rbp-256]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax], 0
$LN313@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 195  :   for (const char* c = value; *c != 0; ++c) {

	cmp	BYTE PTR [rbx], 0
	je	$LN433@valueToQuo
	lea	r15, OFFSET FLAT:__ImageBase
$LL15@valueToQuo:

; 196  :     switch (*c) {

	movsx	r8d, BYTE PTR [rbx]
	lea	eax, DWORD PTR [r8-8]
	cmp	eax, 84					; 00000054H
	ja	$LN3@valueToQuo
	cdqe
	movzx	eax, BYTE PTR $LN572@valueToQuo[r15+rax]
	mov	ecx, DWORD PTR $LN573@valueToQuo[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN10@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02MCKKLHBJ@?2?$CC?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 199  :       break;

	jmp	$LN14@valueToQuo
$LN9@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02HDBGODGB@?2?2?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 202  :       break;

	jmp	$LN14@valueToQuo
$LN8@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02DCNDPIBM@?2b?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 205  :       break;

	jmp	$LN14@valueToQuo
$LN7@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02FGLPDNBI@?2f?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 208  :       break;

	jmp	$LN14@valueToQuo
$LN6@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02JOGGLHBA@?2n?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 211  :       break;

	jmp	$LN14@valueToQuo
$LN5@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02HIBBOKEN@?2r?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 214  :       break;

	jmp	$LN14@valueToQuo
$LN369@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02COELENML@?2t?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 217  :       break;

	jmp	$LN14@valueToQuo
$LN3@valueToQuo:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 65   : static inline bool isControlCharacter(char ch) { return ch > 0 && ch <= 0x1F; }

	lea	eax, DWORD PTR [r8-1]
	cmp	al, 30
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 227  :       if (isControlCharacter(*c)) {

	ja	$LN2@valueToQuo

; 228  :         JSONCPP_OSTRINGSTREAM oss;

	lea	rcx, QWORD PTR oss$3[rsp]
	call	??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 230  :             << std::setw(4) << static_cast<int>(*c);

	lea	rdx, OFFSET FLAT:??_C@_02DHFAHMIK@?2u?$AA@
	lea	rcx, QWORD PTR oss$3[rsp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:?hex@std@@YAAEAVios_base@1@AEAV21@@Z ; std::hex
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:?uppercase@std@@YAAEAVios_base@1@AEAV21@@Z ; std::uppercase
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z
	mov	rdi, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip

; 62   : 	_Ostr.fill(_Manip._Fill);

	mov	rcx, QWORD PTR [rax]
	movsxd	rdx, DWORD PTR [rcx+4]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 115  : 		_Fillch = _Newfill;

	mov	BYTE PTR [rdx+rax+88], 48		; 00000030H
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 230  :             << std::setw(4) << static_cast<int>(*c);

	mov	edx, 4
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	QWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@_J@1@_J@Z
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip

; 277  : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	mov	rcx, QWORD PTR [rdi]
	movsxd	rcx, DWORD PTR [rcx+4]
	add	rcx, rdi
	mov	rdx, QWORD PTR [rax+8]
	call	QWORD PTR [rax]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 230  :             << std::setw(4) << static_cast<int>(*c);

	movsx	edx, BYTE PTR [rbx]
	mov	rcx, rdi
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z

; 231  :         result += oss.str();

	lea	rdx, QWORD PTR $T4[rbp-256]
	lea	rcx, QWORD PTR oss$3[rsp]
	call	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-232], 16
	jb	SHORT $LN411@valueToQuo
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN411@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-240], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rbp-256], 0
	lea	rcx, QWORD PTR oss$3[rbp-120]
	call	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, QWORD PTR oss$3[rbp-120]
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 232  :       } else {

	jmp	SHORT $LN14@valueToQuo
$LN2@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	edx, 1
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN14@valueToQuo:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 195  :   for (const char* c = value; *c != 0; ++c) {

	inc	rbx
	cmp	BYTE PTR [rbx], 0
	jne	$LL15@valueToQuo
$LN433@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	QWORD PTR [rsi+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rsi+16], r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rsi], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	mov	rcx, QWORD PTR result$[rbp-232]
	cmp	rcx, 16
	jae	SHORT $LN476@valueToQuo

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	r8, QWORD PTR result$[rbp-240]
	inc	r8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN475@valueToQuo
	lea	rdx, QWORD PTR result$[rbp-256]
	mov	rcx, rsi
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

	mov	rcx, QWORD PTR result$[rbp-232]
	jmp	SHORT $LN475@valueToQuo
$LN476@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR result$[rbp-256]
	mov	QWORD PTR [rsi], rax
$LN475@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 944  : 		this->_Mysize = _Right._Mysize;

	mov	rax, QWORD PTR result$[rbp-240]
	mov	QWORD PTR [rsi+16], rax

; 945  : 		this->_Myres = _Right._Myres;

	mov	QWORD PTR [rsi+24], rcx
$LN576@valueToQuo:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 239  :   return result;

	mov	rax, rsi

; 240  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+464]
	add	rsp, 400				; 00000190H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN575@valueToQuo:
	npad	2
$LN573@valueToQuo:
	DD	$LN8@valueToQuo
	DD	$LN369@valueToQuo
	DD	$LN6@valueToQuo
	DD	$LN7@valueToQuo
	DD	$LN5@valueToQuo
	DD	$LN10@valueToQuo
	DD	$LN9@valueToQuo
	DD	$LN3@valueToQuo
$LN572@valueToQuo:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	3
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z ENDP ; Json::valueToQuotedString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 448
value$ = 456
?dtor$1@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA PROC ; `Json::valueToQuotedString'::`1'::dtor$1
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA ENDP ; `Json::valueToQuotedString'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 448
value$ = 456
?dtor$2@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA PROC ; `Json::valueToQuotedString'::`1'::dtor$2
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA ENDP ; `Json::valueToQuotedString'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 448
value$ = 456
?dtor$3@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA PROC ; `Json::valueToQuotedString'::`1'::dtor$3
	lea	rcx, QWORD PTR result$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA ENDP ; `Json::valueToQuotedString'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 448
value$ = 456
?dtor$4@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA PROC ; `Json::valueToQuotedString'::`1'::dtor$4
	lea	rcx, QWORD PTR oss$3[rdx]
	jmp	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$4@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA ENDP ; `Json::valueToQuotedString'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 448
value$ = 456
?dtor$5@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA PROC ; `Json::valueToQuotedString'::`1'::dtor$5
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z@4HA ENDP ; `Json::valueToQuotedString'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?strnpbrk@Json@@YAPEBDPEBD0_K@Z
_TEXT	SEGMENT
s$ = 8
accept$dead$ = 16
n$ = 24
?strnpbrk@Json@@YAPEBDPEBD0_K@Z PROC			; Json::strnpbrk, COMDAT

; 244  :   assert((s || !n) && accept);
; 245  : 
; 246  :   char const* const end = s + n;

	lea	r9, QWORD PTR [rcx+r8]
	mov	rdx, rcx

; 247  :   for (char const* cur = s; cur < end; ++cur) {

	cmp	rcx, r9
	jae	SHORT $LN5@strnpbrk
	npad	4
$LL7@strnpbrk:

; 248  :     int const c = *cur;

	movsx	r8d, BYTE PTR [rdx]

; 249  :     for (char const* a = accept; *a; ++a) {

	lea	rax, OFFSET FLAT:??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@
	mov	cl, 34					; 00000022H
	npad	3
$LL4@strnpbrk:

; 250  :       if (*a == c) {

	movsx	ecx, cl
	cmp	ecx, r8d
	je	SHORT $LN12@strnpbrk

; 249  :     for (char const* a = accept; *a; ++a) {

	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL4@strnpbrk

; 247  :   for (char const* cur = s; cur < end; ++cur) {

	inc	rdx
	cmp	rdx, r9
	jb	SHORT $LL7@strnpbrk
$LN5@strnpbrk:

; 252  :       }
; 253  :     }
; 254  :   }
; 255  :   return NULL;

	xor	eax, eax

; 256  : }

	ret	0
$LN12@strnpbrk:

; 251  :         return cur;

	mov	rax, rdx

; 256  : }

	ret	0
?strnpbrk@Json@@YAPEBDPEBD0_K@Z ENDP			; Json::strnpbrk
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_tool.h
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 464
value$ = 472
length$ = 480
?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z PROC ; Json::valueToQuotedStringN, COMDAT

; 257  : static JSONCPP_STRING valueToQuotedStringN(const char* value, unsigned length) {

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-144]
	sub	rsp, 400				; 00000190H
	mov	QWORD PTR $T2[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r10d, r8d
	mov	rdi, rdx
	mov	rsi, rcx
	xor	r15d, r15d
	mov	DWORD PTR $T1[rsp], r15d

; 258  :   if (value == NULL)

	test	rdx, rdx
	jne	SHORT $LN18@valueToQuo
	mov	QWORD PTR [rcx+24], 15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], r15b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 259  :     return "";

	jmp	$LN187@valueToQuo
$LN18@valueToQuo:

; 98   :   }
; 99   :   return false;
; 100  : }
; 101  : 
; 102  : JSONCPP_STRING valueToString(LargestInt value) {
; 103  :   UIntToStringBuffer buffer;
; 104  :   char* current = buffer + sizeof(buffer);
; 105  :   if (value == Value::minLargestInt) {
; 106  :     uintToString(LargestUInt(Value::maxLargestInt) + 1, current);
; 107  :     *--current = '-';
; 108  :   } else if (value < 0) {
; 109  :     uintToString(LargestUInt(-value), current);
; 110  :     *--current = '-';
; 111  :   } else {
; 112  :     uintToString(LargestUInt(value), current);
; 113  :   }
; 114  :   assert(current >= buffer);
; 115  :   return current;
; 116  : }
; 117  : 
; 118  : JSONCPP_STRING valueToString(LargestUInt value) {
; 119  :   UIntToStringBuffer buffer;
; 120  :   char* current = buffer + sizeof(buffer);
; 121  :   uintToString(value, current);
; 122  :   assert(current >= buffer);
; 123  :   return current;
; 124  : }
; 125  : 
; 126  : #if defined(JSON_HAS_INT64)
; 127  : 
; 128  : JSONCPP_STRING valueToString(Int value) {
; 129  :   return valueToString(LargestInt(value));
; 130  : }
; 131  : 
; 132  : JSONCPP_STRING valueToString(UInt value) {
; 133  :   return valueToString(LargestUInt(value));
; 134  : }
; 135  : 
; 136  : #endif // # if defined(JSON_HAS_INT64)
; 137  : 
; 138  : namespace {
; 139  : JSONCPP_STRING valueToString(double value, bool useSpecialFloats, unsigned int precision) {
; 140  :   // Allocate a buffer that is more than large enough to store the 16 digits of
; 141  :   // precision requested below.
; 142  :   char buffer[36];
; 143  :   int len = -1;
; 144  : 
; 145  :   char formatString[6];
; 146  :   sprintf(formatString, "%%.%dg", precision);
; 147  : 
; 148  :   // Print into the buffer. We need not request the alternative representation
; 149  :   // that always has a decimal point because JSON doesn't distingish the
; 150  :   // concepts of reals and integers.
; 151  :   if (isfinite(value)) {
; 152  :     len = snprintf(buffer, sizeof(buffer), formatString, value);
; 153  :     
; 154  :     // try to ensure we preserve the fact that this was given to us as a double on input
; 155  :     if (!strstr(buffer, ".") && !strstr(buffer, "e")) {
; 156  :       strcat(buffer, ".0");
; 157  :     }
; 158  : 
; 159  :   } else {
; 160  :     // IEEE standard states that NaN values will not compare to themselves
; 161  :     if (value != value) {
; 162  :       len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "NaN" : "null");
; 163  :     } else if (value < 0) {
; 164  :       len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "-Infinity" : "-1e+9999");
; 165  :     } else {
; 166  :       len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "Infinity" : "1e+9999");
; 167  :     }
; 168  :     // For those, we do not need to call fixNumLoc, but it is fast.
; 169  :   }
; 170  :   assert(len >= 0);
; 171  :   fixNumericLocale(buffer, buffer + len);
; 172  :   return buffer;
; 173  : }
; 174  : }
; 175  : 
; 176  : JSONCPP_STRING valueToString(double value) { return valueToString(value, false, 17); }
; 177  : 
; 178  : JSONCPP_STRING valueToString(bool value) { return value ? "true" : "false"; }
; 179  : 
; 180  : JSONCPP_STRING valueToQuotedString(const char* value) {
; 181  :   if (value == NULL)
; 182  :     return "";
; 183  :   // Not sure how to handle unicode...
; 184  :   if (strpbrk(value, "\"\\\b\f\n\r\t") == NULL &&
; 185  :       !containsControlCharacter(value))
; 186  :     return JSONCPP_STRING("\"") + value + "\"";
; 187  :   // We have to walk value and escape any special characters.
; 188  :   // Appending to JSONCPP_STRING is not efficient, but this should be rare.
; 189  :   // (Note: forward slashes are *not* rare, but I am not escaping them.)
; 190  :   JSONCPP_STRING::size_type maxsize =
; 191  :       strlen(value) * 2 + 3; // allescaped+quotes+NULL
; 192  :   JSONCPP_STRING result;
; 193  :   result.reserve(maxsize); // to avoid lots of mallocs
; 194  :   result += "\"";
; 195  :   for (const char* c = value; *c != 0; ++c) {
; 196  :     switch (*c) {
; 197  :     case '\"':
; 198  :       result += "\\\"";
; 199  :       break;
; 200  :     case '\\':
; 201  :       result += "\\\\";
; 202  :       break;
; 203  :     case '\b':
; 204  :       result += "\\b";
; 205  :       break;
; 206  :     case '\f':
; 207  :       result += "\\f";
; 208  :       break;
; 209  :     case '\n':
; 210  :       result += "\\n";
; 211  :       break;
; 212  :     case '\r':
; 213  :       result += "\\r";
; 214  :       break;
; 215  :     case '\t':
; 216  :       result += "\\t";
; 217  :       break;
; 218  :     // case '/':
; 219  :     // Even though \/ is considered a legal escape in JSON, a bare
; 220  :     // slash is also legal, so I see no reason to escape it.
; 221  :     // (I hope I am not misunderstanding something.
; 222  :     // blep notes: actually escaping \/ may be useful in javascript to avoid </
; 223  :     // sequence.
; 224  :     // Should add a flag to allow this compatibility mode and prevent this
; 225  :     // sequence from occurring.
; 226  :     default:
; 227  :       if (isControlCharacter(*c)) {
; 228  :         JSONCPP_OSTRINGSTREAM oss;
; 229  :         oss << "\\u" << std::hex << std::uppercase << std::setfill('0')
; 230  :             << std::setw(4) << static_cast<int>(*c);
; 231  :         result += oss.str();
; 232  :       } else {
; 233  :         result += *c;
; 234  :       }
; 235  :       break;
; 236  :     }
; 237  :   }
; 238  :   result += "\"";
; 239  :   return result;
; 240  : }
; 241  : 
; 242  : // https://github.com/upcaste/upcaste/blob/master/src/upcore/src/cstring/strnpbrk.cpp
; 243  : static char const* strnpbrk(char const* s, char const* accept, size_t n) {
; 244  :   assert((s || !n) && accept);
; 245  : 
; 246  :   char const* const end = s + n;

	mov	rax, r10
	lea	r14, QWORD PTR [r10+rdx]

; 247  :   for (char const* cur = s; cur < end; ++cur) {

	mov	r9, rdx
	cmp	rdx, r14
	jae	SHORT $LN592@valueToQuo
	npad	4
$LL78@valueToQuo:

; 248  :     int const c = *cur;

	movsx	r8d, BYTE PTR [r9]

; 249  :     for (char const* a = accept; *a; ++a) {

	lea	rdx, OFFSET FLAT:??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@
	mov	al, 34					; 00000022H
	npad	3
$LL75@valueToQuo:

; 250  :       if (*a == c) {

	movsx	ecx, al
	cmp	ecx, r8d
	je	SHORT $LN17@valueToQuo

; 249  :     for (char const* a = accept; *a; ++a) {

	inc	rdx
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	jne	SHORT $LL75@valueToQuo

; 247  :   for (char const* cur = s; cur < end; ++cur) {

	inc	r9
	cmp	r9, r14
	jb	SHORT $LL78@valueToQuo
$LN592@valueToQuo:

; 260  :   // Not sure how to handle unicode...
; 261  :   if (strnpbrk(value, "\"\\\b\f\n\r\t", length) == NULL &&
; 262  :       !containsControlCharacter0(value, length))

	mov	rcx, rdi

; 94   :   while (end != str) {

	cmp	r14, rdi
	je	$LN83@valueToQuo
$LL84@valueToQuo:

; 95   :     if (isControlCharacter(*str) || 0==*str)

	movzx	edx, BYTE PTR [rcx]
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 65   : static inline bool isControlCharacter(char ch) { return ch > 0 && ch <= 0x1F; }

	lea	eax, DWORD PTR [rdx-1]
	cmp	al, 30
	jbe	SHORT $LN17@valueToQuo
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 95   :     if (isControlCharacter(*str) || 0==*str)

	test	dl, dl
	je	SHORT $LN17@valueToQuo

; 96   :       return true;
; 97   :     ++str;

	inc	rcx

; 94   :   while (end != str) {

	cmp	r14, rcx
	jne	SHORT $LL84@valueToQuo
	jmp	$LN83@valueToQuo
$LN17@valueToQuo:

; 264  :   // We have to walk value and escape any special characters.
; 265  :   // Appending to JSONCPP_STRING is not efficient, but this should be rare.
; 266  :   // (Note: forward slashes are *not* rare, but I am not escaping them.)
; 267  :   JSONCPP_STRING::size_type maxsize =
; 268  :       length * 2 + 3; // allescaped+quotes+NULL

	lea	eax, DWORD PTR [r10*2+3]
	mov	ebx, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, 15
	mov	QWORD PTR result$[rbp-232], rcx

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR result$[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR result$[rbp-256], r15b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)

	cmp	rbx, rcx
	je	SHORT $LN324@valueToQuo

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)

	cmp	rbx, -2
	jbe	SHORT $LN246@valueToQuo

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN246@valueToQuo:

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	cmp	rbx, 15
	jbe	SHORT $LN245@valueToQuo

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	xor	r8d, r8d
	mov	rdx, rbx
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	rcx, QWORD PTR result$[rbp-232]
	jmp	SHORT $LN304@valueToQuo
$LN245@valueToQuo:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	cmp	rbx, 16
	jae	SHORT $LN243@valueToQuo

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, 15
	mov	QWORD PTR result$[rbp-232], rcx

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)

	jmp	SHORT $LN601@valueToQuo
$LN243@valueToQuo:
	test	eax, eax
	jne	SHORT $LN304@valueToQuo
$LN601@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR result$[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR result$[rbp-240], r15
$LN304@valueToQuo:

; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	test	rbx, rbx

; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))

	je	SHORT $LN324@valueToQuo

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR result$[rbp-240], r15

; 513  : 			: this->_Bx._Buf);

	lea	rax, QWORD PTR result$[rbp-256]
	cmp	rcx, 16
	cmovae	rax, QWORD PTR result$[rbp-256]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax], 0
$LN324@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 273  :   for (const char* c = value; c != end; ++c) {

	cmp	rdi, r14
	je	$LN444@valueToQuo
	lea	r12, OFFSET FLAT:__ImageBase
	npad	4
$LL16@valueToQuo:

; 274  :     switch (*c) {

	movsx	r8d, BYTE PTR [rdi]
	lea	eax, DWORD PTR [r8-8]
	cmp	eax, 84					; 00000054H
	ja	$LN4@valueToQuo
	cdqe
	movzx	eax, BYTE PTR $LN598@valueToQuo[r12+rax]
	mov	ecx, DWORD PTR $LN599@valueToQuo[r12+rax*4]
	add	rcx, r12
	jmp	rcx
$LN11@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02MCKKLHBJ@?2?$CC?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 277  :       break;

	jmp	$LN15@valueToQuo
$LN10@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02HDBGODGB@?2?2?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 280  :       break;

	jmp	$LN15@valueToQuo
$LN9@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02DCNDPIBM@?2b?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 283  :       break;

	jmp	$LN15@valueToQuo
$LN8@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02FGLPDNBI@?2f?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 286  :       break;

	jmp	$LN15@valueToQuo
$LN7@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02JOGGLHBA@?2n?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 289  :       break;

	jmp	$LN15@valueToQuo
$LN6@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02HIBBOKEN@?2r?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 292  :       break;

	jmp	$LN15@valueToQuo
$LN380@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02COELENML@?2t?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 295  :       break;

	jmp	$LN15@valueToQuo
$LN4@valueToQuo:
; File e:\jsoncpp-master\src\lib_json\json_tool.h

; 65   : static inline bool isControlCharacter(char ch) { return ch > 0 && ch <= 0x1F; }

	lea	eax, DWORD PTR [r8-1]
	cmp	al, 30
	jbe	SHORT $LN2@valueToQuo
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 305  :       if ((isControlCharacter(*c)) || (*c == 0)) {

	test	r8b, r8b
	je	SHORT $LN2@valueToQuo
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	edx, 1
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	jmp	$LN15@valueToQuo
$LN2@valueToQuo:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 306  :         JSONCPP_OSTRINGSTREAM oss;

	lea	rcx, QWORD PTR oss$3[rsp]
	call	??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 308  :             << std::setw(4) << static_cast<int>(*c);

	lea	rdx, OFFSET FLAT:??_C@_02DHFAHMIK@?2u?$AA@
	lea	rcx, QWORD PTR oss$3[rsp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:?hex@std@@YAAEAVios_base@1@AEAV21@@Z ; std::hex
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:?uppercase@std@@YAAEAVios_base@1@AEAV21@@Z ; std::uppercase
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z
	mov	rbx, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip

; 62   : 	_Ostr.fill(_Manip._Fill);

	mov	rcx, QWORD PTR [rax]
	movsxd	rdx, DWORD PTR [rcx+4]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 115  : 		_Fillch = _Newfill;

	mov	BYTE PTR [rdx+rax+88], 48		; 00000030H
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 308  :             << std::setw(4) << static_cast<int>(*c);

	mov	edx, 4
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	QWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@_J@1@_J@Z
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip

; 277  : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	mov	rcx, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rcx+4]
	add	rcx, rbx
	mov	rdx, QWORD PTR [rax+8]
	call	QWORD PTR [rax]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 308  :             << std::setw(4) << static_cast<int>(*c);

	movsx	edx, BYTE PTR [rdi]
	mov	rcx, rbx
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z

; 309  :         result += oss.str();

	lea	rdx, QWORD PTR $T4[rbp-256]
	lea	rcx, QWORD PTR oss$3[rsp]
	call	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-232], 16
	jb	SHORT $LN422@valueToQuo
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN422@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rbp-256], 0
	lea	rcx, QWORD PTR oss$3[rbp-120]
	call	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, QWORD PTR oss$3[rbp-120]
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN15@valueToQuo:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 273  :   for (const char* c = value; c != end; ++c) {

	inc	rdi
	cmp	rdi, r14
	jne	$LL16@valueToQuo
$LN444@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	lea	rcx, QWORD PTR result$[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	QWORD PTR [rsi+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rsi+16], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rsi], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	mov	rcx, QWORD PTR result$[rbp-232]
	cmp	rcx, 16
	jae	SHORT $LN487@valueToQuo

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	r8, QWORD PTR result$[rbp-240]
	inc	r8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN486@valueToQuo
	lea	rdx, QWORD PTR result$[rbp-256]
	mov	rcx, rsi
	call	QWORD PTR __imp_memmove
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

	mov	rcx, QWORD PTR result$[rbp-232]
	jmp	SHORT $LN486@valueToQuo
$LN487@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR result$[rbp-256]
	mov	QWORD PTR [rsi], rax
$LN486@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 944  : 		this->_Mysize = _Right._Mysize;

	mov	rax, QWORD PTR result$[rbp-240]
	mov	QWORD PTR [rsi+16], rax

; 945  : 		this->_Myres = _Right._Myres;

	mov	QWORD PTR [rsi+24], rcx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 317  :   return result;

	jmp	SHORT $LN187@valueToQuo
$LN83@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T7[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T7[rbp-256], r15b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	lea	rcx, QWORD PTR $T7[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 263  :     return JSONCPP_STRING("\"") + value + "\"";

	mov	r8, rdi
	lea	rdx, QWORD PTR $T7[rbp-256]
	lea	rcx, QWORD PTR $T5[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@PEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	mov	rdx, rax
	mov	rcx, rsi
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@PEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T5[rbp-232], 16
	jb	SHORT $LN155@valueToQuo
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T5[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN155@valueToQuo:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-240], r15
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T7[rbp-232], 16
	jb	SHORT $LN187@valueToQuo
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T7[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN187@valueToQuo:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 263  :     return JSONCPP_STRING("\"") + value + "\"";

	mov	rax, rsi

; 318  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 400				; 00000190H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN600@valueToQuo:
$LN599@valueToQuo:
	DD	$LN9@valueToQuo
	DD	$LN380@valueToQuo
	DD	$LN7@valueToQuo
	DD	$LN8@valueToQuo
	DD	$LN6@valueToQuo
	DD	$LN11@valueToQuo
	DD	$LN10@valueToQuo
	DD	$LN4@valueToQuo
$LN598@valueToQuo:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	3
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z ENDP ; Json::valueToQuotedStringN
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 464
value$ = 472
length$ = 480
?dtor$1@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA PROC ; `Json::valueToQuotedStringN'::`1'::dtor$1
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA ENDP ; `Json::valueToQuotedStringN'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 464
value$ = 472
length$ = 480
?dtor$2@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA PROC ; `Json::valueToQuotedStringN'::`1'::dtor$2
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA ENDP ; `Json::valueToQuotedStringN'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 464
value$ = 472
length$ = 480
?dtor$3@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA PROC ; `Json::valueToQuotedStringN'::`1'::dtor$3
	lea	rcx, QWORD PTR result$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA ENDP ; `Json::valueToQuotedStringN'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 464
value$ = 472
length$ = 480
?dtor$4@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA PROC ; `Json::valueToQuotedStringN'::`1'::dtor$4
	lea	rcx, QWORD PTR oss$3[rdx]
	jmp	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$4@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA ENDP ; `Json::valueToQuotedStringN'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
oss$3 = 48
result$ = 288
$T4 = 320
$T5 = 320
$T6 = 352
$T7 = 352
__$ArrayPad$ = 384
__$ReturnUdt$ = 464
value$ = 472
length$ = 480
?dtor$5@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA PROC ; `Json::valueToQuotedStringN'::`1'::dtor$5
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z@4HA ENDP ; `Json::valueToQuotedStringN'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??_GWriter@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GWriter@Json@@UEAAPEAXI@Z PROC			; Json::Writer::`scalar deleting destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 322  : Writer::~Writer() {}

	lea	rax, OFFSET FLAT:??_7Writer@Json@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN6@scalar
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN6@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GWriter@Json@@UEAAPEAXI@Z ENDP			; Json::Writer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0Writer@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Writer@Json@@QEAA@XZ PROC				; Json::Writer::Writer, COMDAT
	lea	rax, OFFSET FLAT:??_7Writer@Json@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0Writer@Json@@QEAA@XZ ENDP				; Json::Writer::Writer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?write@FastWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
root$ = 80
?write@FastWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z PROC ; Json::FastWriter::write, COMDAT

; 337  : JSONCPP_STRING FastWriter::write(const Value& root) {

$LN69:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+32], 16
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 337  : JSONCPP_STRING FastWriter::write(const Value& root) {

	mov	rdi, rdx
	mov	rsi, rcx
	mov	DWORD PTR $T1[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+24], 0

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN12@write
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rcx+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN13@write
$LN12@write:
	lea	rax, QWORD PTR [rcx+8]
$LN13@write:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 339  :   writeValue(root);

	mov	rdx, r8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 339  :   writeValue(root);

	call	?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::FastWriter::writeValue

; 340  :   if (!omitEndingLineFeed_)

	cmp	BYTE PTR [rsi+42], 0
	jne	SHORT $LN18@write
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	lea	rcx, QWORD PTR [rsi+8]
	mov	r8d, 1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN18@write:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], 0

; 726  : 		assign(_Right, 0, npos);

	lea	rdx, QWORD PTR [rsi+8]
	or	r9, -1
	xor	r8d, r8d
	mov	rcx, rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 343  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rax, rdi
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?write@FastWriter@Json@@UEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVValue@2@@Z ENDP ; Json::FastWriter::write
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z
_TEXT	SEGMENT
tv1553 = 40
size$1$ = 40
tv1554 = 48
value$GSCopy$1$ = 48
members$1 = 56
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
__$ArrayPad$ = 280
this$ = 320
value$ = 328
?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z PROC	; Json::FastWriter::writeValue, COMDAT

; 345  : void FastWriter::writeValue(const Value& value) {

$LN438:
	push	rbp
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [rsp-32]
	sub	rsp, 288				; 00000120H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rsp+336], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rbx, rdx
	mov	QWORD PTR value$GSCopy$1$[rsp], rdx
	mov	rsi, rcx

; 346  :   switch (value.type()) {

	movsx	rcx, BYTE PTR [rdx+8]
	mov	rax, rcx
	cmp	ecx, 7
	ja	$LN357@writeValue
	lea	r8, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR $LN435@writeValue[r8+rcx*4]
	add	rdx, r8
	jmp	rdx
$LN18@writeValue:

; 347  :   case nullValue:
; 348  :     if (!dropNullPlaceholders_)

	cmp	BYTE PTR [rsi+41], 0
	jne	$LN357@writeValue

; 349  :       document_ += "null";

	lea	rcx, QWORD PTR [rsi+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04MLLLIHIP@null?$AA@
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 350  :     break;

	jmp	$LN357@writeValue
$LN16@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 802  :   return asInt64();

	mov	rcx, rbx
	call	?asInt64@Value@Json@@QEBA_JXZ		; Json::Value::asInt64
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 352  :     document_ += valueToString(value.asLargestInt());

	mov	rdx, rax
	lea	rcx, QWORD PTR $T5[rbp-256]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z ; Json::valueToString
	npad	1
	lea	rcx, QWORD PTR [rsi+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T5[rbp-232], 16
	jb	$LN357@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T5[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 353  :     break;

	jmp	$LN436@writeValue
$LN15@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 810  :   return asUInt64();

	mov	rcx, rbx
	call	?asUInt64@Value@Json@@QEBA_KXZ		; Json::Value::asUInt64
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 355  :     document_ += valueToString(value.asLargestUInt());

	mov	rdx, rax
	lea	rcx, QWORD PTR $T7[rbp-256]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::valueToString
	npad	1
	lea	rcx, QWORD PTR [rsi+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T7[rbp-232], 16
	jb	$LN357@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T7[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 356  :     break;

	jmp	$LN436@writeValue
$LN14@writeValue:

; 357  :   case realValue:
; 358  :     document_ += valueToString(value.asDouble());

	mov	rcx, rbx
	call	?asDouble@Value@Json@@QEBANXZ		; Json::Value::asDouble
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T4[rsp]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	npad	1
	lea	rcx, QWORD PTR [rsi+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-232], 16
	jb	$LN357@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rsp]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 359  :     break;

	jmp	$LN436@writeValue
$LN13@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 666  :   if (type_ != stringValue) return false;

	cmp	cl, 4
	jne	$LN357@writeValue

; 667  :   if (value_.string_ == 0) return false;

	mov	rdx, QWORD PTR [rbx]
	test	rdx, rdx
	je	$LN357@writeValue

; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);

	mov	eax, DWORD PTR [rbx+8]
	shr	eax, 8
	and	al, 1

; 143  :   if (!isPrefixed) {

	jne	SHORT $LN157@writeValue

; 144  :     *length = static_cast<unsigned>(strlen(prefixed));

	or	rax, -1
$LL434@writeValue:
	inc	rax
	cmp	BYTE PTR [rdx+rax], 0
	jne	SHORT $LL434@writeValue

; 145  :     *value = prefixed;
; 146  :   } else {

	jmp	SHORT $LN156@writeValue
$LN157@writeValue:

; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);

	mov	eax, DWORD PTR [rdx]

; 148  :     *value = prefixed + sizeof(unsigned);

	add	rdx, 4
$LN156@writeValue:

; 670  :   *cend = *str + length;

	mov	r8d, eax
	add	r8, rdx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 366  :     if (ok) document_ += valueToQuotedStringN(str, static_cast<unsigned>(end-str));

	sub	r8d, edx
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z ; Json::valueToQuotedStringN
	npad	1
	lea	rcx, QWORD PTR [rsi+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T6[rbp-232], 16
	jb	$LN357@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T6[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 367  :     break;

	jmp	$LN436@writeValue
$LN11@writeValue:

; 368  :   }
; 369  :   case booleanValue:
; 370  :     document_ += valueToString(value.asBool());

	mov	rcx, rbx
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	movzx	edx, al
	lea	rcx, QWORD PTR $T8[rbp-256]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	npad	1
	lea	rcx, QWORD PTR [rsi+8]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T8[rbp-232], 16
	jb	$LN357@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T8[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 371  :     break;

	jmp	$LN436@writeValue
$LN10@writeValue:

; 372  :   case arrayValue: {
; 373  :     document_ += '[';

	lea	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR tv1554[rsp], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 91					; 0000005bH
	mov	edx, 1
	mov	rcx, rax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 913  :   switch (type_) {

	movsx	edx, BYTE PTR [rbx+8]
	xor	edi, edi
	test	edx, edx
	js	SHORT $LN238@writeValue
	mov	rcx, rbx
	call	?size@Value@Json@@QEBAIXZ		; Json::Value::size
	jmp	SHORT $LN437@writeValue
$LN238@writeValue:

; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;

	mov	eax, edi
$LN437@writeValue:
	mov	DWORD PTR size$1$[rsp], eax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 375  :     for (ArrayIndex index = 0; index < size; ++index) {

	test	eax, eax
	je	SHORT $LN7@writeValue
$LL9@writeValue:

; 376  :       if (index > 0)

	test	edi, edi
	je	SHORT $LN245@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 44					; 0000002cH
	mov	edx, 1
	lea	rcx, QWORD PTR [rsi+8]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN245@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 378  :       writeValue(value[index]);

	mov	edx, edi
	mov	rcx, rbx
	call	??AValue@Json@@QEBAAEBV01@I@Z		; Json::Value::operator[]
	mov	rdx, rax
	mov	rcx, rsi
	call	?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::FastWriter::writeValue

; 375  :     for (ArrayIndex index = 0; index < size; ++index) {

	inc	edi
	cmp	edi, DWORD PTR size$1$[rsp]
	jb	SHORT $LL9@writeValue
$LN7@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 93					; 0000005dH
	mov	edx, 1
	mov	rcx, QWORD PTR tv1554[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 381  :   } break;

	jmp	$LN357@writeValue
$LN5@writeValue:

; 382  :   case objectValue: {
; 383  :     Value::Members members(value.getMemberNames());

	lea	rdx, QWORD PTR members$1[rsp]
	mov	rcx, rbx
	call	?getMemberNames@Value@Json@@QEBA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
	npad	1

; 384  :     document_ += '{';

	lea	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR tv1553[rsp], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 123				; 0000007bH
	mov	edx, 1
	mov	rcx, rax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR members$1[rsp]
	mov	rbx, rax

; 205  : 		return (this->_Ptr == _Right._Ptr);

	xor	edi, edi
	cmp	rax, QWORD PTR members$1[rsp+8]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 386  :          ++it) {

	je	$LN2@writeValue
$LL261@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, rax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 388  :       if (it != members.begin())

	je	SHORT $LN295@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 44					; 0000002cH
	mov	edx, 1
	lea	rcx, QWORD PTR [rsi+8]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN295@writeValue:

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN305@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rdx, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	jmp	SHORT $LN306@writeValue
$LN305@writeValue:
	mov	rdx, rbx
$LN306@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 390  :       document_ += valueToQuotedStringN(name.data(), static_cast<unsigned>(name.length()));

	mov	r8d, DWORD PTR [rbx+16]
	lea	rcx, QWORD PTR $T3[rsp]
	call	?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z ; Json::valueToQuotedStringN
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	lea	rcx, QWORD PTR [rsi+8]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T3[rsp+24], 16
	jb	SHORT $LN333@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN333@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 15

; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 391  :       document_ += yamlCompatiblityEnabled_ ? ": " : ":";

	lea	rdx, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
	cmp	BYTE PTR [rsi+40], 0
	lea	rax, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
	cmovne	rdx, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [rdx], 0
	jne	SHORT $LN351@writeValue
	mov	r8, rdi
	jmp	SHORT $LN352@writeValue
$LN351@writeValue:
	or	r8, -1
	npad	9
$LL433@writeValue:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL433@writeValue
$LN352@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	lea	rcx, QWORD PTR [rsi+8]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 392  :       writeValue(value[name]);

	mov	rdx, rbx
	mov	rcx, QWORD PTR value$GSCopy$1$[rsp]
	call	??AValue@Json@@QEBAAEBV01@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	rdx, rax
	mov	rcx, rsi
	call	?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::FastWriter::writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rbx, 32					; 00000020H

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, QWORD PTR members$1[rsp+8]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 386  :          ++it) {

	mov	rax, QWORD PTR members$1[rsp]
	jne	$LL261@writeValue
$LN2@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 125				; 0000007dH
	mov	edx, 1
	mov	rcx, QWORD PTR tv1553[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rsi, QWORD PTR members$1[rsp]
	test	rsi, rsi
	je	SHORT $LN357@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	rbx, rsi

; 81   : 	for (; _First != _Last; ++_First)

	mov	rax, QWORD PTR members$1[rsp+8]
	cmp	rsi, rax
	je	SHORT $LN368@writeValue
	npad	7
$LL370@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN402@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	mov	rax, QWORD PTR members$1[rsp+8]
$LN402@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 81   : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rax
	jne	SHORT $LL370@writeValue
$LN368@writeValue:

; 573  : 		::operator delete(_Ptr);

	mov	rcx, rsi
$LN436@writeValue:
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN357@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 397  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+336]
	add	rsp, 288				; 00000120H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
	npad	3
$LN435@writeValue:
	DD	$LN18@writeValue
	DD	$LN16@writeValue
	DD	$LN15@writeValue
	DD	$LN14@writeValue
	DD	$LN13@writeValue
	DD	$LN11@writeValue
	DD	$LN10@writeValue
	DD	$LN5@writeValue
?writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z ENDP	; Json::FastWriter::writeValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1553 = 40
size$1$ = 40
tv1554 = 48
value$GSCopy$1$ = 48
members$1 = 56
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
__$ArrayPad$ = 280
this$ = 320
value$ = 328
?dtor$0@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::FastWriter::writeValue'::`1'::dtor$0
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::FastWriter::writeValue'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1553 = 40
size$1$ = 40
tv1554 = 48
value$GSCopy$1$ = 48
members$1 = 56
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
__$ArrayPad$ = 280
this$ = 320
value$ = 328
?dtor$1@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::FastWriter::writeValue'::`1'::dtor$1
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::FastWriter::writeValue'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1553 = 40
size$1$ = 40
tv1554 = 48
value$GSCopy$1$ = 48
members$1 = 56
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
__$ArrayPad$ = 280
this$ = 320
value$ = 328
?dtor$2@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::FastWriter::writeValue'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::FastWriter::writeValue'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1553 = 40
size$1$ = 40
tv1554 = 48
value$GSCopy$1$ = 48
members$1 = 56
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
__$ArrayPad$ = 280
this$ = 320
value$ = 328
?dtor$3@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::FastWriter::writeValue'::`1'::dtor$3
	lea	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::FastWriter::writeValue'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1553 = 40
size$1$ = 40
tv1554 = 48
value$GSCopy$1$ = 48
members$1 = 56
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
__$ArrayPad$ = 280
this$ = 320
value$ = 328
?dtor$4@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::FastWriter::writeValue'::`1'::dtor$4
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::FastWriter::writeValue'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1553 = 40
size$1$ = 40
tv1554 = 48
value$GSCopy$1$ = 48
members$1 = 56
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
__$ArrayPad$ = 280
this$ = 320
value$ = 328
?dtor$5@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::FastWriter::writeValue'::`1'::dtor$5
	lea	rcx, QWORD PTR members$1[rdx]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$5@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::FastWriter::writeValue'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1553 = 40
size$1$ = 40
tv1554 = 48
value$GSCopy$1$ = 48
members$1 = 56
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
__$ArrayPad$ = 280
this$ = 320
value$ = 328
?dtor$6@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::FastWriter::writeValue'::`1'::dtor$6
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??writeValue@FastWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::FastWriter::writeValue'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
_TEXT	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z PROC	; Json::StyledWriter::writeValue, COMDAT

; 416  : void StyledWriter::writeValue(const Value& value) {

$LN807:
	push	rbp
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [rsp-192]
	sub	rsp, 448				; 000001c0H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rsp+496], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r8, rdx
	mov	QWORD PTR value$GSCopy$1$[rsp], rdx
	mov	rdi, rcx

; 417  :   switch (value.type()) {

	movsx	rdx, BYTE PTR [rdx+8]
	mov	rax, rdx
	cmp	edx, 7
	ja	$LN732@writeValue
	lea	r9, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN805@writeValue[r9+rdx*4]
	add	rcx, r9
	jmp	rcx
$LN15@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T6[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	esi, esi
	mov	QWORD PTR $T6[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T6[rbp-256], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+4]
	lea	rdx, OFFSET FLAT:??_C@_04MLLLIHIP@null?$AA@
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 547  :     childValues_.push_back(value);

	lea	rdx, QWORD PTR $T6[rbp-256]

; 474  : 
; 475  : void StyledWriter::writeArrayValue(const Value& value) {
; 476  :   unsigned size = value.size();
; 477  :   if (size == 0)
; 478  :     pushValue("[]");
; 479  :   else {
; 480  :     bool isArrayMultiLine = isMultineArray(value);
; 481  :     if (isArrayMultiLine) {
; 482  :       writeWithIndent("[");
; 483  :       indent();
; 484  :       bool hasChildValue = !childValues_.empty();
; 485  :       unsigned index = 0;
; 486  :       for (;;) {
; 487  :         const Value& childValue = value[index];
; 488  :         writeCommentBeforeValue(childValue);
; 489  :         if (hasChildValue)
; 490  :           writeWithIndent(childValues_[index]);
; 491  :         else {
; 492  :           writeIndent();
; 493  :           writeValue(childValue);
; 494  :         }
; 495  :         if (++index == size) {
; 496  :           writeCommentAfterValueOnSameLine(childValue);
; 497  :           break;
; 498  :         }
; 499  :         document_ += ',';
; 500  :         writeCommentAfterValueOnSameLine(childValue);
; 501  :       }
; 502  :       unindent();
; 503  :       writeWithIndent("]");
; 504  :     } else // output on a single line
; 505  :     {
; 506  :       assert(childValues_.size() == size);
; 507  :       document_ += "[ ";
; 508  :       for (unsigned index = 0; index < size; ++index) {
; 509  :         if (index > 0)
; 510  :           document_ += ", ";
; 511  :         document_ += childValues_[index];
; 512  :       }
; 513  :       document_ += " ]";
; 514  :     }
; 515  :   }
; 516  : }
; 517  : 
; 518  : bool StyledWriter::isMultineArray(const Value& value) {
; 519  :   ArrayIndex const size = value.size();
; 520  :   bool isMultiLine = size * 3 >= rightMargin_;
; 521  :   childValues_.clear();
; 522  :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 523  :     const Value& childValue = value[index];
; 524  :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 525  :                         childValue.size() > 0);
; 526  :   }
; 527  :   if (!isMultiLine) // check if line length > max line length
; 528  :   {
; 529  :     childValues_.reserve(size);
; 530  :     addChildValues_ = true;
; 531  :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 532  :     for (ArrayIndex index = 0; index < size; ++index) {
; 533  :       if (hasCommentForValue(value[index])) {
; 534  :         isMultiLine = true;
; 535  :       }
; 536  :       writeValue(value[index]);
; 537  :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 538  :     }
; 539  :     addChildValues_ = false;
; 540  :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 541  :   }
; 542  :   return isMultiLine;
; 543  : }
; 544  : 
; 545  : void StyledWriter::pushValue(const JSONCPP_STRING& value) {
; 546  :   if (addChildValues_)

	cmp	BYTE PTR [rdi+104], sil
	je	SHORT $LN79@writeValue

; 547  :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+8]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 548  :   else

	jmp	SHORT $LN82@writeValue
$LN79@writeValue:

; 549  :     document_ += value;

	lea	rcx, QWORD PTR [rdi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN82@writeValue:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T6[rbp-232], 16
	jb	$LN732@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T6[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 420  :     break;

	jmp	$LN806@writeValue
$LN14@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 802  :   return asInt64();

	mov	rcx, r8
	call	?asInt64@Value@Json@@QEBA_JXZ		; Json::Value::asInt64
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 422  :     pushValue(valueToString(value.asLargestInt()));

	mov	rdx, rax
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z ; Json::valueToString
	npad	1

; 547  :     childValues_.push_back(value);

	mov	rdx, rax

; 474  : 
; 475  : void StyledWriter::writeArrayValue(const Value& value) {
; 476  :   unsigned size = value.size();
; 477  :   if (size == 0)
; 478  :     pushValue("[]");
; 479  :   else {
; 480  :     bool isArrayMultiLine = isMultineArray(value);
; 481  :     if (isArrayMultiLine) {
; 482  :       writeWithIndent("[");
; 483  :       indent();
; 484  :       bool hasChildValue = !childValues_.empty();
; 485  :       unsigned index = 0;
; 486  :       for (;;) {
; 487  :         const Value& childValue = value[index];
; 488  :         writeCommentBeforeValue(childValue);
; 489  :         if (hasChildValue)
; 490  :           writeWithIndent(childValues_[index]);
; 491  :         else {
; 492  :           writeIndent();
; 493  :           writeValue(childValue);
; 494  :         }
; 495  :         if (++index == size) {
; 496  :           writeCommentAfterValueOnSameLine(childValue);
; 497  :           break;
; 498  :         }
; 499  :         document_ += ',';
; 500  :         writeCommentAfterValueOnSameLine(childValue);
; 501  :       }
; 502  :       unindent();
; 503  :       writeWithIndent("]");
; 504  :     } else // output on a single line
; 505  :     {
; 506  :       assert(childValues_.size() == size);
; 507  :       document_ += "[ ";
; 508  :       for (unsigned index = 0; index < size; ++index) {
; 509  :         if (index > 0)
; 510  :           document_ += ", ";
; 511  :         document_ += childValues_[index];
; 512  :       }
; 513  :       document_ += " ]";
; 514  :     }
; 515  :   }
; 516  : }
; 517  : 
; 518  : bool StyledWriter::isMultineArray(const Value& value) {
; 519  :   ArrayIndex const size = value.size();
; 520  :   bool isMultiLine = size * 3 >= rightMargin_;
; 521  :   childValues_.clear();
; 522  :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 523  :     const Value& childValue = value[index];
; 524  :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 525  :                         childValue.size() > 0);
; 526  :   }
; 527  :   if (!isMultiLine) // check if line length > max line length
; 528  :   {
; 529  :     childValues_.reserve(size);
; 530  :     addChildValues_ = true;
; 531  :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 532  :     for (ArrayIndex index = 0; index < size; ++index) {
; 533  :       if (hasCommentForValue(value[index])) {
; 534  :         isMultiLine = true;
; 535  :       }
; 536  :       writeValue(value[index]);
; 537  :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 538  :     }
; 539  :     addChildValues_ = false;
; 540  :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 541  :   }
; 542  :   return isMultiLine;
; 543  : }
; 544  : 
; 545  : void StyledWriter::pushValue(const JSONCPP_STRING& value) {
; 546  :   if (addChildValues_)

	cmp	BYTE PTR [rdi+104], 0
	je	SHORT $LN121@writeValue

; 547  :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+8]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 548  :   else

	jmp	SHORT $LN124@writeValue
$LN121@writeValue:

; 549  :     document_ += value;

	lea	rcx, QWORD PTR [rdi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN124@writeValue:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T9[rbp-232], 16
	jb	$LN732@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T9[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 423  :     break;

	jmp	$LN806@writeValue
$LN13@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 810  :   return asUInt64();

	mov	rcx, r8
	call	?asUInt64@Value@Json@@QEBA_KXZ		; Json::Value::asUInt64
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 425  :     pushValue(valueToString(value.asLargestUInt()));

	mov	rdx, rax
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::valueToString
	npad	1

; 547  :     childValues_.push_back(value);

	mov	rdx, rax

; 474  : 
; 475  : void StyledWriter::writeArrayValue(const Value& value) {
; 476  :   unsigned size = value.size();
; 477  :   if (size == 0)
; 478  :     pushValue("[]");
; 479  :   else {
; 480  :     bool isArrayMultiLine = isMultineArray(value);
; 481  :     if (isArrayMultiLine) {
; 482  :       writeWithIndent("[");
; 483  :       indent();
; 484  :       bool hasChildValue = !childValues_.empty();
; 485  :       unsigned index = 0;
; 486  :       for (;;) {
; 487  :         const Value& childValue = value[index];
; 488  :         writeCommentBeforeValue(childValue);
; 489  :         if (hasChildValue)
; 490  :           writeWithIndent(childValues_[index]);
; 491  :         else {
; 492  :           writeIndent();
; 493  :           writeValue(childValue);
; 494  :         }
; 495  :         if (++index == size) {
; 496  :           writeCommentAfterValueOnSameLine(childValue);
; 497  :           break;
; 498  :         }
; 499  :         document_ += ',';
; 500  :         writeCommentAfterValueOnSameLine(childValue);
; 501  :       }
; 502  :       unindent();
; 503  :       writeWithIndent("]");
; 504  :     } else // output on a single line
; 505  :     {
; 506  :       assert(childValues_.size() == size);
; 507  :       document_ += "[ ";
; 508  :       for (unsigned index = 0; index < size; ++index) {
; 509  :         if (index > 0)
; 510  :           document_ += ", ";
; 511  :         document_ += childValues_[index];
; 512  :       }
; 513  :       document_ += " ]";
; 514  :     }
; 515  :   }
; 516  : }
; 517  : 
; 518  : bool StyledWriter::isMultineArray(const Value& value) {
; 519  :   ArrayIndex const size = value.size();
; 520  :   bool isMultiLine = size * 3 >= rightMargin_;
; 521  :   childValues_.clear();
; 522  :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 523  :     const Value& childValue = value[index];
; 524  :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 525  :                         childValue.size() > 0);
; 526  :   }
; 527  :   if (!isMultiLine) // check if line length > max line length
; 528  :   {
; 529  :     childValues_.reserve(size);
; 530  :     addChildValues_ = true;
; 531  :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 532  :     for (ArrayIndex index = 0; index < size; ++index) {
; 533  :       if (hasCommentForValue(value[index])) {
; 534  :         isMultiLine = true;
; 535  :       }
; 536  :       writeValue(value[index]);
; 537  :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 538  :     }
; 539  :     addChildValues_ = false;
; 540  :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 541  :   }
; 542  :   return isMultiLine;
; 543  : }
; 544  : 
; 545  : void StyledWriter::pushValue(const JSONCPP_STRING& value) {
; 546  :   if (addChildValues_)

	cmp	BYTE PTR [rdi+104], 0
	je	SHORT $LN163@writeValue

; 547  :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+8]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 548  :   else

	jmp	SHORT $LN166@writeValue
$LN163@writeValue:

; 549  :     document_ += value;

	lea	rcx, QWORD PTR [rdi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN166@writeValue:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T12[rbp-232], 16
	jb	$LN732@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T12[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 426  :     break;

	jmp	$LN806@writeValue
$LN12@writeValue:

; 427  :   case realValue:
; 428  :     pushValue(valueToString(value.asDouble()));

	mov	rcx, r8
	call	?asDouble@Value@Json@@QEBANXZ		; Json::Value::asDouble
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	npad	1

; 547  :     childValues_.push_back(value);

	mov	rdx, rax

; 474  : 
; 475  : void StyledWriter::writeArrayValue(const Value& value) {
; 476  :   unsigned size = value.size();
; 477  :   if (size == 0)
; 478  :     pushValue("[]");
; 479  :   else {
; 480  :     bool isArrayMultiLine = isMultineArray(value);
; 481  :     if (isArrayMultiLine) {
; 482  :       writeWithIndent("[");
; 483  :       indent();
; 484  :       bool hasChildValue = !childValues_.empty();
; 485  :       unsigned index = 0;
; 486  :       for (;;) {
; 487  :         const Value& childValue = value[index];
; 488  :         writeCommentBeforeValue(childValue);
; 489  :         if (hasChildValue)
; 490  :           writeWithIndent(childValues_[index]);
; 491  :         else {
; 492  :           writeIndent();
; 493  :           writeValue(childValue);
; 494  :         }
; 495  :         if (++index == size) {
; 496  :           writeCommentAfterValueOnSameLine(childValue);
; 497  :           break;
; 498  :         }
; 499  :         document_ += ',';
; 500  :         writeCommentAfterValueOnSameLine(childValue);
; 501  :       }
; 502  :       unindent();
; 503  :       writeWithIndent("]");
; 504  :     } else // output on a single line
; 505  :     {
; 506  :       assert(childValues_.size() == size);
; 507  :       document_ += "[ ";
; 508  :       for (unsigned index = 0; index < size; ++index) {
; 509  :         if (index > 0)
; 510  :           document_ += ", ";
; 511  :         document_ += childValues_[index];
; 512  :       }
; 513  :       document_ += " ]";
; 514  :     }
; 515  :   }
; 516  : }
; 517  : 
; 518  : bool StyledWriter::isMultineArray(const Value& value) {
; 519  :   ArrayIndex const size = value.size();
; 520  :   bool isMultiLine = size * 3 >= rightMargin_;
; 521  :   childValues_.clear();
; 522  :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 523  :     const Value& childValue = value[index];
; 524  :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 525  :                         childValue.size() > 0);
; 526  :   }
; 527  :   if (!isMultiLine) // check if line length > max line length
; 528  :   {
; 529  :     childValues_.reserve(size);
; 530  :     addChildValues_ = true;
; 531  :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 532  :     for (ArrayIndex index = 0; index < size; ++index) {
; 533  :       if (hasCommentForValue(value[index])) {
; 534  :         isMultiLine = true;
; 535  :       }
; 536  :       writeValue(value[index]);
; 537  :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 538  :     }
; 539  :     addChildValues_ = false;
; 540  :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 541  :   }
; 542  :   return isMultiLine;
; 543  : }
; 544  : 
; 545  : void StyledWriter::pushValue(const JSONCPP_STRING& value) {
; 546  :   if (addChildValues_)

	cmp	BYTE PTR [rdi+104], 0
	je	SHORT $LN203@writeValue

; 547  :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+8]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 548  :   else

	jmp	SHORT $LN206@writeValue
$LN203@writeValue:

; 549  :     document_ += value;

	lea	rcx, QWORD PTR [rdi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN206@writeValue:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T10[rbp-232], 16
	jb	$LN732@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T10[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 429  :     break;

	jmp	$LN806@writeValue
$LN11@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 666  :   if (type_ != stringValue) return false;

	cmp	dl, 4
	jne	SHORT $LN10@writeValue

; 667  :   if (value_.string_ == 0) return false;

	mov	rdx, QWORD PTR [r8]
	test	rdx, rdx
	je	SHORT $LN10@writeValue

; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);

	mov	eax, DWORD PTR [r8+8]
	shr	eax, 8
	and	al, 1

; 143  :   if (!isPrefixed) {

	jne	SHORT $LN247@writeValue

; 144  :     *length = static_cast<unsigned>(strlen(prefixed));

	or	rax, -1
	npad	1
$LL804@writeValue:
	inc	rax
	cmp	BYTE PTR [rdx+rax], 0
	jne	SHORT $LL804@writeValue

; 145  :     *value = prefixed;
; 146  :   } else {

	jmp	SHORT $LN246@writeValue
$LN247@writeValue:

; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);

	mov	eax, DWORD PTR [rdx]

; 148  :     *value = prefixed + sizeof(unsigned);

	add	rdx, 4
$LN246@writeValue:

; 670  :   *cend = *str + length;

	mov	r8d, eax
	add	r8, rdx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 436  :     if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end-str)));

	sub	r8d, edx
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z ; Json::valueToQuotedStringN
	npad	1

; 547  :     childValues_.push_back(value);

	mov	rdx, rax

; 474  : 
; 475  : void StyledWriter::writeArrayValue(const Value& value) {
; 476  :   unsigned size = value.size();
; 477  :   if (size == 0)
; 478  :     pushValue("[]");
; 479  :   else {
; 480  :     bool isArrayMultiLine = isMultineArray(value);
; 481  :     if (isArrayMultiLine) {
; 482  :       writeWithIndent("[");
; 483  :       indent();
; 484  :       bool hasChildValue = !childValues_.empty();
; 485  :       unsigned index = 0;
; 486  :       for (;;) {
; 487  :         const Value& childValue = value[index];
; 488  :         writeCommentBeforeValue(childValue);
; 489  :         if (hasChildValue)
; 490  :           writeWithIndent(childValues_[index]);
; 491  :         else {
; 492  :           writeIndent();
; 493  :           writeValue(childValue);
; 494  :         }
; 495  :         if (++index == size) {
; 496  :           writeCommentAfterValueOnSameLine(childValue);
; 497  :           break;
; 498  :         }
; 499  :         document_ += ',';
; 500  :         writeCommentAfterValueOnSameLine(childValue);
; 501  :       }
; 502  :       unindent();
; 503  :       writeWithIndent("]");
; 504  :     } else // output on a single line
; 505  :     {
; 506  :       assert(childValues_.size() == size);
; 507  :       document_ += "[ ";
; 508  :       for (unsigned index = 0; index < size; ++index) {
; 509  :         if (index > 0)
; 510  :           document_ += ", ";
; 511  :         document_ += childValues_[index];
; 512  :       }
; 513  :       document_ += " ]";
; 514  :     }
; 515  :   }
; 516  : }
; 517  : 
; 518  : bool StyledWriter::isMultineArray(const Value& value) {
; 519  :   ArrayIndex const size = value.size();
; 520  :   bool isMultiLine = size * 3 >= rightMargin_;
; 521  :   childValues_.clear();
; 522  :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 523  :     const Value& childValue = value[index];
; 524  :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 525  :                         childValue.size() > 0);
; 526  :   }
; 527  :   if (!isMultiLine) // check if line length > max line length
; 528  :   {
; 529  :     childValues_.reserve(size);
; 530  :     addChildValues_ = true;
; 531  :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 532  :     for (ArrayIndex index = 0; index < size; ++index) {
; 533  :       if (hasCommentForValue(value[index])) {
; 534  :         isMultiLine = true;
; 535  :       }
; 536  :       writeValue(value[index]);
; 537  :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 538  :     }
; 539  :     addChildValues_ = false;
; 540  :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 541  :   }
; 542  :   return isMultiLine;
; 543  : }
; 544  : 
; 545  : void StyledWriter::pushValue(const JSONCPP_STRING& value) {
; 546  :   if (addChildValues_)

	cmp	BYTE PTR [rdi+104], 0
	je	SHORT $LN251@writeValue

; 547  :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+8]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 548  :   else

	jmp	SHORT $LN254@writeValue
$LN251@writeValue:

; 549  :     document_ += value;

	lea	rcx, QWORD PTR [rdi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN254@writeValue:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T11[rbp-232], 16
	jb	$LN732@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T11[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 437  :     else pushValue("");

	jmp	$LN806@writeValue
$LN10@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	esi, esi
	mov	QWORD PTR $T7[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T7[rbp-256], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	lea	rcx, QWORD PTR $T7[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 547  :     childValues_.push_back(value);

	lea	rdx, QWORD PTR $T7[rbp-256]

; 474  : 
; 475  : void StyledWriter::writeArrayValue(const Value& value) {
; 476  :   unsigned size = value.size();
; 477  :   if (size == 0)
; 478  :     pushValue("[]");
; 479  :   else {
; 480  :     bool isArrayMultiLine = isMultineArray(value);
; 481  :     if (isArrayMultiLine) {
; 482  :       writeWithIndent("[");
; 483  :       indent();
; 484  :       bool hasChildValue = !childValues_.empty();
; 485  :       unsigned index = 0;
; 486  :       for (;;) {
; 487  :         const Value& childValue = value[index];
; 488  :         writeCommentBeforeValue(childValue);
; 489  :         if (hasChildValue)
; 490  :           writeWithIndent(childValues_[index]);
; 491  :         else {
; 492  :           writeIndent();
; 493  :           writeValue(childValue);
; 494  :         }
; 495  :         if (++index == size) {
; 496  :           writeCommentAfterValueOnSameLine(childValue);
; 497  :           break;
; 498  :         }
; 499  :         document_ += ',';
; 500  :         writeCommentAfterValueOnSameLine(childValue);
; 501  :       }
; 502  :       unindent();
; 503  :       writeWithIndent("]");
; 504  :     } else // output on a single line
; 505  :     {
; 506  :       assert(childValues_.size() == size);
; 507  :       document_ += "[ ";
; 508  :       for (unsigned index = 0; index < size; ++index) {
; 509  :         if (index > 0)
; 510  :           document_ += ", ";
; 511  :         document_ += childValues_[index];
; 512  :       }
; 513  :       document_ += " ]";
; 514  :     }
; 515  :   }
; 516  : }
; 517  : 
; 518  : bool StyledWriter::isMultineArray(const Value& value) {
; 519  :   ArrayIndex const size = value.size();
; 520  :   bool isMultiLine = size * 3 >= rightMargin_;
; 521  :   childValues_.clear();
; 522  :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 523  :     const Value& childValue = value[index];
; 524  :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 525  :                         childValue.size() > 0);
; 526  :   }
; 527  :   if (!isMultiLine) // check if line length > max line length
; 528  :   {
; 529  :     childValues_.reserve(size);
; 530  :     addChildValues_ = true;
; 531  :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 532  :     for (ArrayIndex index = 0; index < size; ++index) {
; 533  :       if (hasCommentForValue(value[index])) {
; 534  :         isMultiLine = true;
; 535  :       }
; 536  :       writeValue(value[index]);
; 537  :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 538  :     }
; 539  :     addChildValues_ = false;
; 540  :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 541  :   }
; 542  :   return isMultiLine;
; 543  : }
; 544  : 
; 545  : void StyledWriter::pushValue(const JSONCPP_STRING& value) {
; 546  :   if (addChildValues_)

	cmp	BYTE PTR [rdi+104], sil
	je	SHORT $LN335@writeValue

; 547  :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+8]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 548  :   else

	jmp	SHORT $LN338@writeValue
$LN335@writeValue:

; 549  :     document_ += value;

	lea	rcx, QWORD PTR [rdi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN338@writeValue:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T7[rbp-232], 16
	jb	$LN732@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T7[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 438  :     break;

	jmp	$LN806@writeValue
$LN8@writeValue:

; 439  :   }
; 440  :   case booleanValue:
; 441  :     pushValue(valueToString(value.asBool()));

	mov	rcx, r8
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	movzx	edx, al
	lea	rcx, QWORD PTR $T13[rbp-256]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	npad	1

; 547  :     childValues_.push_back(value);

	mov	rdx, rax

; 474  : 
; 475  : void StyledWriter::writeArrayValue(const Value& value) {
; 476  :   unsigned size = value.size();
; 477  :   if (size == 0)
; 478  :     pushValue("[]");
; 479  :   else {
; 480  :     bool isArrayMultiLine = isMultineArray(value);
; 481  :     if (isArrayMultiLine) {
; 482  :       writeWithIndent("[");
; 483  :       indent();
; 484  :       bool hasChildValue = !childValues_.empty();
; 485  :       unsigned index = 0;
; 486  :       for (;;) {
; 487  :         const Value& childValue = value[index];
; 488  :         writeCommentBeforeValue(childValue);
; 489  :         if (hasChildValue)
; 490  :           writeWithIndent(childValues_[index]);
; 491  :         else {
; 492  :           writeIndent();
; 493  :           writeValue(childValue);
; 494  :         }
; 495  :         if (++index == size) {
; 496  :           writeCommentAfterValueOnSameLine(childValue);
; 497  :           break;
; 498  :         }
; 499  :         document_ += ',';
; 500  :         writeCommentAfterValueOnSameLine(childValue);
; 501  :       }
; 502  :       unindent();
; 503  :       writeWithIndent("]");
; 504  :     } else // output on a single line
; 505  :     {
; 506  :       assert(childValues_.size() == size);
; 507  :       document_ += "[ ";
; 508  :       for (unsigned index = 0; index < size; ++index) {
; 509  :         if (index > 0)
; 510  :           document_ += ", ";
; 511  :         document_ += childValues_[index];
; 512  :       }
; 513  :       document_ += " ]";
; 514  :     }
; 515  :   }
; 516  : }
; 517  : 
; 518  : bool StyledWriter::isMultineArray(const Value& value) {
; 519  :   ArrayIndex const size = value.size();
; 520  :   bool isMultiLine = size * 3 >= rightMargin_;
; 521  :   childValues_.clear();
; 522  :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 523  :     const Value& childValue = value[index];
; 524  :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 525  :                         childValue.size() > 0);
; 526  :   }
; 527  :   if (!isMultiLine) // check if line length > max line length
; 528  :   {
; 529  :     childValues_.reserve(size);
; 530  :     addChildValues_ = true;
; 531  :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 532  :     for (ArrayIndex index = 0; index < size; ++index) {
; 533  :       if (hasCommentForValue(value[index])) {
; 534  :         isMultiLine = true;
; 535  :       }
; 536  :       writeValue(value[index]);
; 537  :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 538  :     }
; 539  :     addChildValues_ = false;
; 540  :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 541  :   }
; 542  :   return isMultiLine;
; 543  : }
; 544  : 
; 545  : void StyledWriter::pushValue(const JSONCPP_STRING& value) {
; 546  :   if (addChildValues_)

	cmp	BYTE PTR [rdi+104], 0
	je	SHORT $LN375@writeValue

; 547  :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+8]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 548  :   else

	jmp	SHORT $LN378@writeValue
$LN375@writeValue:

; 549  :     document_ += value;

	lea	rcx, QWORD PTR [rdi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN378@writeValue:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T13[rbp-232], 16
	jb	$LN732@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T13[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 442  :     break;

	jmp	$LN806@writeValue
$LN7@writeValue:

; 443  :   case arrayValue:
; 444  :     writeArrayValue(value);

	mov	rdx, r8
	mov	rcx, rdi
	call	?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeArrayValue

; 445  :     break;

	jmp	$LN732@writeValue
$LN6@writeValue:

; 446  :   case objectValue: {
; 447  :     Value::Members members(value.getMemberNames());

	lea	rdx, QWORD PTR members$1[rsp]
	mov	rcx, r8
	call	?getMemberNames@Value@Json@@QEBA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	rbx, QWORD PTR members$1[rsp]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	esi, esi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

	cmp	rbx, QWORD PTR members$1[rsp+8]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 448  :     if (members.empty())

	jne	SHORT $LN5@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+2]
	lea	rdx, OFFSET FLAT:??_C@_02MCILKGOH@?$HL?$HN?$AA@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 547  :     childValues_.push_back(value);

	lea	rdx, QWORD PTR $T3[rsp]

; 474  : 
; 475  : void StyledWriter::writeArrayValue(const Value& value) {
; 476  :   unsigned size = value.size();
; 477  :   if (size == 0)
; 478  :     pushValue("[]");
; 479  :   else {
; 480  :     bool isArrayMultiLine = isMultineArray(value);
; 481  :     if (isArrayMultiLine) {
; 482  :       writeWithIndent("[");
; 483  :       indent();
; 484  :       bool hasChildValue = !childValues_.empty();
; 485  :       unsigned index = 0;
; 486  :       for (;;) {
; 487  :         const Value& childValue = value[index];
; 488  :         writeCommentBeforeValue(childValue);
; 489  :         if (hasChildValue)
; 490  :           writeWithIndent(childValues_[index]);
; 491  :         else {
; 492  :           writeIndent();
; 493  :           writeValue(childValue);
; 494  :         }
; 495  :         if (++index == size) {
; 496  :           writeCommentAfterValueOnSameLine(childValue);
; 497  :           break;
; 498  :         }
; 499  :         document_ += ',';
; 500  :         writeCommentAfterValueOnSameLine(childValue);
; 501  :       }
; 502  :       unindent();
; 503  :       writeWithIndent("]");
; 504  :     } else // output on a single line
; 505  :     {
; 506  :       assert(childValues_.size() == size);
; 507  :       document_ += "[ ";
; 508  :       for (unsigned index = 0; index < size; ++index) {
; 509  :         if (index > 0)
; 510  :           document_ += ", ";
; 511  :         document_ += childValues_[index];
; 512  :       }
; 513  :       document_ += " ]";
; 514  :     }
; 515  :   }
; 516  : }
; 517  : 
; 518  : bool StyledWriter::isMultineArray(const Value& value) {
; 519  :   ArrayIndex const size = value.size();
; 520  :   bool isMultiLine = size * 3 >= rightMargin_;
; 521  :   childValues_.clear();
; 522  :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 523  :     const Value& childValue = value[index];
; 524  :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 525  :                         childValue.size() > 0);
; 526  :   }
; 527  :   if (!isMultiLine) // check if line length > max line length
; 528  :   {
; 529  :     childValues_.reserve(size);
; 530  :     addChildValues_ = true;
; 531  :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 532  :     for (ArrayIndex index = 0; index < size; ++index) {
; 533  :       if (hasCommentForValue(value[index])) {
; 534  :         isMultiLine = true;
; 535  :       }
; 536  :       writeValue(value[index]);
; 537  :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 538  :     }
; 539  :     addChildValues_ = false;
; 540  :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 541  :   }
; 542  :   return isMultiLine;
; 543  : }
; 544  : 
; 545  : void StyledWriter::pushValue(const JSONCPP_STRING& value) {
; 546  :   if (addChildValues_)

	cmp	BYTE PTR [rdi+104], sil
	je	SHORT $LN461@writeValue

; 547  :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+8]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 548  :   else

	jmp	SHORT $LN464@writeValue
$LN461@writeValue:

; 549  :     document_ += value;

	lea	rcx, QWORD PTR [rdi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN464@writeValue:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T3[rsp+24], 16
	jb	SHORT $LN488@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN488@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 450  :     else {

	jmp	$LN728@writeValue
$LN5@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-256], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01HCONENDN@?$HL?$AA@
	lea	rcx, QWORD PTR $T5[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 451  :       writeWithIndent("{");

	lea	rdx, QWORD PTR $T5[rbp-256]
	mov	rcx, rdi
	call	?writeWithIndent@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T5[rbp-232], 16
	jb	SHORT $LN564@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T5[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN564@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-256], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 452  :       indent();

	mov	rcx, rdi
	call	?indent@StyledWriter@Json@@AEAAXXZ	; Json::StyledWriter::indent
	npad	8
$LL3@writeValue:

; 453  :       Value::Members::iterator it = members.begin();
; 454  :       for (;;) {
; 455  :         const JSONCPP_STRING& name = *it;
; 456  :         const Value& childValue = value[name];

	mov	rdx, rbx
	mov	rcx, QWORD PTR value$GSCopy$1$[rsp]
	call	??AValue@Json@@QEBAAEBV01@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	QWORD PTR childValue$1$[rsp], rax

; 457  :         writeCommentBeforeValue(childValue);

	mov	rdx, rax
	mov	rcx, rdi
	call	?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN592@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rdx, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	jmp	SHORT $LN593@writeValue
$LN592@writeValue:
	mov	rdx, rbx
$LN593@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 458  :         writeWithIndent(valueToQuotedString(name.c_str()));

	lea	rcx, QWORD PTR $T8[rbp-256]
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBD@Z ; Json::valueToQuotedString
	npad	1
	mov	rdx, rax
	mov	rcx, rdi
	call	?writeWithIndent@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T8[rbp-232], 16
	jb	SHORT $LN616@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T8[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN616@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T8[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T8[rbp-256], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:??_C@_03MCPBMLDJ@?5?3?5?$AA@
	lea	rcx, QWORD PTR [rdi+32]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 460  :         writeValue(childValue);

	mov	rdx, QWORD PTR childValue$1$[rsp]
	mov	rcx, rdi
	call	?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rbx, 32					; 00000020H

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, QWORD PTR members$1[rsp+8]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 461  :         if (++it == members.end()) {

	je	SHORT $LN797@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 44					; 0000002cH
	mov	edx, 1
	lea	rcx, QWORD PTR [rdi+32]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 466  :         writeCommentAfterValueOnSameLine(childValue);

	mov	rdx, QWORD PTR childValue$1$[rsp]
	mov	rcx, rdi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 467  :       }

	jmp	$LL3@writeValue
$LN797@writeValue:

; 462  :           writeCommentAfterValueOnSameLine(childValue);

	mov	rdx, QWORD PTR childValue$1$[rsp]
	mov	rcx, rdi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 468  :       unindent();

	mov	rcx, rdi
	call	?unindent@StyledWriter@Json@@AEAAXXZ	; Json::StyledWriter::unindent
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
	lea	rcx, QWORD PTR $T4[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 469  :       writeWithIndent("}");

	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rdi
	call	?writeWithIndent@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-232], 16
	jb	SHORT $LN718@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN718@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rsp], 0
$LN728@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rax, QWORD PTR members$1[rsp]
	test	rax, rax
	je	SHORT $LN732@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	rbx, rax

; 81   : 	for (; _First != _Last; ++_First)

	mov	rdi, QWORD PTR members$1[rsp+8]
	cmp	rax, rdi
	je	SHORT $LN743@writeValue
	npad	6
$LL745@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN777@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN777@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 81   : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL745@writeValue
	mov	rax, QWORD PTR members$1[rsp]
$LN743@writeValue:

; 573  : 		::operator delete(_Ptr);

	mov	rcx, rax
$LN806@writeValue:
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN732@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 473  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+496]
	add	rsp, 448				; 000001c0H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN805@writeValue:
	DD	$LN15@writeValue
	DD	$LN14@writeValue
	DD	$LN13@writeValue
	DD	$LN12@writeValue
	DD	$LN11@writeValue
	DD	$LN8@writeValue
	DD	$LN7@writeValue
	DD	$LN6@writeValue
?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ENDP	; Json::StyledWriter::writeValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$0@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$0
	lea	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$1@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$1
	lea	rcx, QWORD PTR $T9[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$2@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$2
	lea	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$3@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$3
	lea	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$4@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$4
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$5@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$5
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$6@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$6
	lea	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$7@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$7
	lea	rcx, QWORD PTR members$1[rdx]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$7@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$8@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$8
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$9@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$9
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$10@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$10
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
$T13 = 408
__$ArrayPad$ = 440
this$ = 480
value$ = 488
?dtor$11@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeValue'::`1'::dtor$11
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeValue'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
__$ArrayPad$ = 72
this$ = 144
value$ = 152
?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z PROC ; Json::StyledWriter::writeArrayValue, COMDAT

; 475  : void StyledWriter::writeArrayValue(const Value& value) {

$LN414:
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+160], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r12, rdx
	mov	rbx, rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 913  :   switch (type_) {

	movsx	edx, BYTE PTR [rdx+8]
	test	edx, edx
	js	$LN411@writeArray
	mov	rcx, r12
	call	?size@Value@Json@@QEBAIXZ		; Json::Value::size
	mov	r15d, eax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 477  :   if (size == 0)

	test	eax, eax
	je	$LN411@writeArray

; 478  :     pushValue("[]");
; 479  :   else {
; 480  :     bool isArrayMultiLine = isMultineArray(value);

	mov	rdx, r12
	mov	rcx, rbx
	call	?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z ; Json::StyledWriter::isMultineArray

; 481  :     if (isArrayMultiLine) {

	test	al, al
	je	$LN379@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 15

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	esi, esi
	mov	QWORD PTR $T3[rsp+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+1]
	lea	rdx, OFFSET FLAT:??_C@_01OHGJGJJP@?$FL?$AA@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 1793 : 		return (this->_Mysize == 0);

	mov	rcx, QWORD PTR [rbx+48]
	test	rcx, rcx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 553  :   if (!document_.empty()) {

	je	SHORT $LN177@writeArray

; 554  :     char last = document_[document_.length() - 1];

	lea	rdi, QWORD PTR [rbx+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN173@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rdi]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN174@writeArray
$LN173@writeArray:
	mov	rax, rdi
$LN174@writeArray:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 554  :     char last = document_[document_.length() - 1];

	movzx	eax, BYTE PTR [rax+rcx-1]

; 555  :     if (last == ' ') // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN179@writeArray

; 556  :       return;
; 557  :     if (last != '\n') // Comments may add new-line

	cmp	al, 10
	je	SHORT $LN177@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 10
	mov	edx, 1
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN177@writeArray:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 560  :   document_ += indentString_;

	lea	rdi, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR [rbx+64]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN179@writeArray:
	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T3[rsp+24], 16
	jb	SHORT $LN207@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN207@writeArray:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 483  :       indent();

	mov	rcx, rbx
	call	?indent@StyledWriter@Json@@AEAAXXZ	; Json::StyledWriter::indent
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	rax, QWORD PTR [rbx+16]
	cmp	QWORD PTR [rbx+8], rax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 484  :       bool hasChildValue = !childValues_.empty();

	setne	r13b

; 485  :       unsigned index = 0;

	mov	ebp, esi
$LL10@writeArray:

; 486  :       for (;;) {
; 487  :         const Value& childValue = value[index];

	mov	edx, ebp
	mov	rcx, r12
	call	??AValue@Json@@QEBAAEBV01@I@Z		; Json::Value::operator[]
	mov	r14, rax

; 488  :         writeCommentBeforeValue(childValue);

	mov	rdx, rax
	mov	rcx, rbx
	call	?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 489  :         if (hasChildValue)

	test	r13b, r13b
	je	SHORT $LN8@writeArray

; 490  :           writeWithIndent(childValues_[index]);

	mov	edx, ebp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

	shl	rdx, 5
	add	rdx, QWORD PTR [rbx+8]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 490  :           writeWithIndent(childValues_[index]);

	mov	rcx, rbx
	call	?writeWithIndent@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent

; 491  :         else {

	jmp	SHORT $LN7@writeArray
$LN8@writeArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	mov	rcx, QWORD PTR [rbx+48]
	test	rcx, rcx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 553  :   if (!document_.empty()) {

	je	SHORT $LN240@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN236@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rdi]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN237@writeArray
$LN236@writeArray:
	mov	rax, rdi
$LN237@writeArray:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 554  :     char last = document_[document_.length() - 1];

	movzx	eax, BYTE PTR [rax+rcx-1]

; 555  :     if (last == ' ') // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN242@writeArray

; 556  :       return;
; 557  :     if (last != '\n') // Comments may add new-line

	cmp	al, 10
	je	SHORT $LN240@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 10
	mov	edx, 1
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN240@writeArray:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 560  :   document_ += indentString_;

	lea	rdx, QWORD PTR [rbx+64]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN242@writeArray:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 493  :           writeValue(childValue);

	mov	rdx, r14
	mov	rcx, rbx
	call	?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeValue
$LN7@writeArray:

; 494  :         }
; 495  :         if (++index == size) {

	inc	ebp
	cmp	ebp, r15d
	je	SHORT $LN405@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 44					; 0000002cH
	mov	edx, 1
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 500  :         writeCommentAfterValueOnSameLine(childValue);

	mov	rdx, r14
	mov	rcx, rbx
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 501  :       }

	jmp	$LL10@writeArray
$LN405@writeArray:

; 496  :           writeCommentAfterValueOnSameLine(childValue);

	mov	rdx, r14
	mov	rcx, rbx
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

	mov	rdx, QWORD PTR [rbx+80]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 572  :   indentString_.resize(indentString_.size() - indentSize_);

	mov	eax, DWORD PTR [rbx+100]
	sub	rdx, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1770 : 		if (_Newsize <= this->_Mysize)

	mov	rax, QWORD PTR [rbx+80]
	cmp	rdx, rax
	ja	SHORT $LN255@writeArray

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+80], rdx

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+88], 16
	jb	SHORT $LN262@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rbx+64]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN263@writeArray
$LN262@writeArray:
	lea	rax, QWORD PTR [rbx+64]
$LN263@writeArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax+rdx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1772 : 		else

	jmp	SHORT $LN254@writeArray
$LN255@writeArray:

; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

	sub	rdx, rax
	xor	r8d, r8d
	lea	rcx, QWORD PTR [rbx+64]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN254@writeArray:

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T2[rsp+24], 15

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T2[rsp+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T2[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01LBDDMOBJ@?$FN?$AA@
	lea	rcx, QWORD PTR $T2[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 1793 : 		return (this->_Mysize == 0);

	mov	rcx, QWORD PTR [rbx+48]
	test	rcx, rcx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 553  :   if (!document_.empty()) {

	je	SHORT $LN331@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN327@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rdi]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN328@writeArray
$LN327@writeArray:
	mov	rax, rdi
$LN328@writeArray:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 554  :     char last = document_[document_.length() - 1];

	movzx	eax, BYTE PTR [rax+rcx-1]

; 555  :     if (last == ' ') // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN333@writeArray

; 556  :       return;
; 557  :     if (last != '\n') // Comments may add new-line

	cmp	al, 10
	je	SHORT $LN331@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 10
	mov	edx, 1
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN331@writeArray:

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR [rbx+64]
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN333@writeArray:
	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 504  :     } else // output on a single line

	jmp	$LN413@writeArray
$LN379@writeArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02PFNDMDBO@?$FL?5?$AA@
	lea	rcx, QWORD PTR [rbx+32]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 508  :       for (unsigned index = 0; index < size; ++index) {

	xor	esi, esi
	test	r15d, r15d
	je	SHORT $LN401@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r14d, esi
$LL4@writeArray:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 509  :         if (index > 0)

	test	esi, esi
	je	SHORT $LN381@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
	lea	rcx, QWORD PTR [rbx+32]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN381@writeArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

	mov	rdx, QWORD PTR [rbx+8]
	add	rdx, r14
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rcx, QWORD PTR [rbx+32]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 508  :       for (unsigned index = 0; index < size; ++index) {

	inc	esi
	add	r14, 32					; 00000020H
	cmp	esi, r15d
	jb	SHORT $LL4@writeArray
$LN401@writeArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02DHOGEDBE@?5?$FN?$AA@
	lea	rcx, QWORD PTR [rbx+32]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	jmp	SHORT $LN395@writeArray
$LN411@writeArray:

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rsp+24], 15

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	esi, esi
	mov	QWORD PTR $T4[rsp+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rsp], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+2]
	lea	rdx, OFFSET FLAT:??_C@_02GPECMEKF@?$FL?$FN?$AA@
	lea	rcx, QWORD PTR $T4[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 547  :     childValues_.push_back(value);

	lea	rdx, QWORD PTR $T4[rsp]

; 517  : 
; 518  : bool StyledWriter::isMultineArray(const Value& value) {
; 519  :   ArrayIndex const size = value.size();
; 520  :   bool isMultiLine = size * 3 >= rightMargin_;
; 521  :   childValues_.clear();
; 522  :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 523  :     const Value& childValue = value[index];
; 524  :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 525  :                         childValue.size() > 0);
; 526  :   }
; 527  :   if (!isMultiLine) // check if line length > max line length
; 528  :   {
; 529  :     childValues_.reserve(size);
; 530  :     addChildValues_ = true;
; 531  :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 532  :     for (ArrayIndex index = 0; index < size; ++index) {
; 533  :       if (hasCommentForValue(value[index])) {
; 534  :         isMultiLine = true;
; 535  :       }
; 536  :       writeValue(value[index]);
; 537  :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 538  :     }
; 539  :     addChildValues_ = false;
; 540  :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 541  :   }
; 542  :   return isMultiLine;
; 543  : }
; 544  : 
; 545  : void StyledWriter::pushValue(const JSONCPP_STRING& value) {
; 546  :   if (addChildValues_)

	cmp	BYTE PTR [rbx+104], sil
	je	SHORT $LN75@writeArray

; 547  :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rbx+8]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 548  :   else

	jmp	SHORT $LN78@writeArray
$LN75@writeArray:

; 549  :     document_ += value;

	lea	rcx, QWORD PTR [rbx+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN78@writeArray:
$LN413@writeArray:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rsp+24], 16
	jb	SHORT $LN395@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN395@writeArray:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 516  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+160]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ENDP ; Json::StyledWriter::writeArrayValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
__$ArrayPad$ = 72
this$ = 144
value$ = 152
?dtor$0@?0??writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeArrayValue'::`1'::dtor$0
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeArrayValue'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
__$ArrayPad$ = 72
this$ = 144
value$ = 152
?dtor$1@?0??writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeArrayValue'::`1'::dtor$1
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeArrayValue'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
__$ArrayPad$ = 72
this$ = 144
value$ = 152
?dtor$2@?0??writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeArrayValue'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??writeArrayValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeArrayValue'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z
_TEXT	SEGMENT
this$ = 80
value$ = 88
?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z PROC ; Json::StyledWriter::isMultineArray, COMDAT

; 518  : bool StyledWriter::isMultineArray(const Value& value) {

$LN99:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 32					; 00000020H
	mov	r14, rdx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 913  :   switch (type_) {

	movsx	edx, BYTE PTR [rdx+8]
	xor	ebp, ebp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 518  : bool StyledWriter::isMultineArray(const Value& value) {

	mov	r13, rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 913  :   switch (type_) {

	test	edx, edx
	js	SHORT $LN20@isMultineA
	mov	rcx, r14
	call	?size@Value@Json@@QEBAIXZ		; Json::Value::size
	mov	esi, eax
	jmp	SHORT $LN22@isMultineA
$LN20@isMultineA:

; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;

	mov	esi, ebp
$LN22@isMultineA:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 520  :   bool isMultiLine = size * 3 >= rightMargin_;

	lea	eax, DWORD PTR [rsi+rsi*2]

; 521  :   childValues_.clear();

	lea	rcx, QWORD PTR [r13+8]
	cmp	eax, DWORD PTR [r13+96]
	setae	bl
	call	?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear

; 522  :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {

	mov	edi, ebp
	test	esi, esi
	je	SHORT $LN6@isMultineA
	npad	3
$LL8@isMultineA:
	test	bl, bl
	jne	$LN15@isMultineA

; 523  :     const Value& childValue = value[index];

	mov	edx, edi
	mov	rcx, r14
	call	??AValue@Json@@QEBAAEBV01@I@Z		; Json::Value::operator[]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1388 : bool Value::isArray() const { return type_ == arrayValue; }

	movzx	edx, BYTE PTR [rax+8]
	lea	ecx, DWORD PTR [rdx-6]
	cmp	cl, 1
	ja	SHORT $LN12@isMultineA

; 913  :   switch (type_) {

	movsx	edx, dl
	test	edx, edx
	js	SHORT $LN12@isMultineA
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 525  :                         childValue.size() > 0);

	mov	rcx, rax
	call	?size@Value@Json@@QEBAIXZ		; Json::Value::size
	test	eax, eax
	je	SHORT $LN12@isMultineA
	mov	bl, 1
	jmp	SHORT $LN13@isMultineA
$LN12@isMultineA:
	xor	bl, bl
$LN13@isMultineA:

; 522  :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {

	inc	edi
	cmp	edi, esi
	jb	SHORT $LL8@isMultineA
$LN6@isMultineA:

; 526  :   }
; 527  :   if (!isMultiLine) // check if line length > max line length

	test	bl, bl
	jne	$LN15@isMultineA
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [r13+24]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 529  :     childValues_.reserve(size);

	mov	edx, esi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	rax, QWORD PTR [r13+8]
	sar	rax, 5

; 1000 : 		if (capacity() < _Count)

	cmp	rax, rdx
	jae	SHORT $LN43@isMultineA

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	rdx, rax
	jbe	SHORT $LN42@isMultineA

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN42@isMultineA:

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	lea	rcx, QWORD PTR [r13+8]
	call	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN43@isMultineA:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 530  :     addChildValues_ = true;

	mov	BYTE PTR [r13+104], 1

; 531  :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'

	lea	edi, DWORD PTR [rsi*2+2]

; 532  :     for (ArrayIndex index = 0; index < size; ++index) {

	test	esi, esi
	je	SHORT $LN2@isMultineA
	mov	QWORD PTR [rsp+80], r15
	mov	r15, rbp
$LL4@isMultineA:

; 533  :       if (hasCommentForValue(value[index])) {

	mov	edx, ebp
	mov	rcx, r14
	call	??AValue@Json@@QEBAAEBV01@I@Z		; Json::Value::operator[]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1411 :   return comments_ != 0 && comments_[placement].comment_ != 0;

	mov	rcx, QWORD PTR [rax+16]
	test	rcx, rcx
	je	SHORT $LN1@isMultineA
	cmp	QWORD PTR [rcx], 0
	jne	SHORT $LN64@isMultineA
	test	rcx, rcx
	je	SHORT $LN1@isMultineA
	cmp	QWORD PTR [rcx+8], 0
	jne	SHORT $LN64@isMultineA
	test	rcx, rcx
	je	SHORT $LN1@isMultineA
	cmp	QWORD PTR [rcx+16], 0
	je	SHORT $LN1@isMultineA
$LN64@isMultineA:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 534  :         isMultiLine = true;

	mov	bl, 1
$LN1@isMultineA:

; 535  :       }
; 536  :       writeValue(value[index]);

	mov	edx, ebp
	mov	rcx, r14
	call	??AValue@Json@@QEBAAEBV01@I@Z		; Json::Value::operator[]
	mov	rcx, r13
	mov	rdx, rax
	call	?writeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::StyledWriter::writeValue

; 537  :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());

	mov	rax, QWORD PTR [r13+8]
	inc	ebp
	add	edi, DWORD PTR [r15+rax+16]
	add	r15, 32					; 00000020H
	cmp	ebp, esi
	jb	SHORT $LL4@isMultineA
	mov	r15, QWORD PTR [rsp+80]
$LN2@isMultineA:

; 538  :     }
; 539  :     addChildValues_ = false;

	mov	BYTE PTR [r13+104], 0

; 540  :     isMultiLine = isMultiLine || lineLength >= rightMargin_;

	test	bl, bl
	jne	SHORT $LN14@isMultineA
	cmp	edi, DWORD PTR [r13+96]
	jb	SHORT $LN15@isMultineA
$LN14@isMultineA:
	mov	bl, 1
$LN15@isMultineA:

; 541  :   }
; 542  :   return isMultiLine;
; 543  : }

	mov	rbp, QWORD PTR [rsp+96]
	movzx	eax, bl
	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN98@isMultineA:
?isMultineArray@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z ENDP ; Json::StyledWriter::isMultineArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?pushValue@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 8
value$ = 16
?pushValue@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledWriter::pushValue, COMDAT

; 546  :   if (addChildValues_)

	cmp	BYTE PTR [rcx+104], 0
	je	SHORT $LN2@pushValue

; 547  :     childValues_.push_back(value);

	add	rcx, 8
	jmp	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
$LN2@pushValue:

; 548  :   else
; 549  :     document_ += value;

	add	rcx, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?pushValue@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledWriter::pushValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeIndent@StyledWriter@Json@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?writeIndent@StyledWriter@Json@@AEAAXXZ PROC		; Json::StyledWriter::writeIndent, COMDAT

; 552  : void StyledWriter::writeIndent() {

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	mov	rax, QWORD PTR [rcx+48]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 552  : void StyledWriter::writeIndent() {

	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	test	rax, rax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 553  :   if (!document_.empty()) {

	je	SHORT $LN18@writeInden

; 554  :     char last = document_[document_.length() - 1];

	add	rcx, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+24], 16
	jb	SHORT $LN14@writeInden
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rdx, QWORD PTR [rcx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN15@writeInden
$LN14@writeInden:
	mov	rdx, rcx
$LN15@writeInden:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 554  :     char last = document_[document_.length() - 1];

	movzx	edx, BYTE PTR [rdx+rax-1]

; 555  :     if (last == ' ') // already indented

	cmp	dl, 32					; 00000020H
	je	SHORT $LN20@writeInden

; 556  :       return;
; 557  :     if (last != '\n') // Comments may add new-line

	cmp	dl, 10
	je	SHORT $LN18@writeInden
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 10
	mov	edx, 1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN18@writeInden:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 560  :   document_ += indentString_;

	lea	rdx, QWORD PTR [rbx+64]
	lea	rcx, QWORD PTR [rbx+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 561  : }

	add	rsp, 32					; 00000020H
	pop	rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN20@writeInden:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 561  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?writeIndent@StyledWriter@Json@@AEAAXXZ ENDP		; Json::StyledWriter::writeIndent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeWithIndent@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 48
value$ = 56
?writeWithIndent@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledWriter::writeWithIndent, COMDAT

; 563  : void StyledWriter::writeWithIndent(const JSONCPP_STRING& value) {

$LN31:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	mov	rcx, QWORD PTR [rcx+48]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 563  : void StyledWriter::writeWithIndent(const JSONCPP_STRING& value) {

	mov	rsi, rdx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	test	rcx, rcx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 553  :   if (!document_.empty()) {

	je	SHORT $LN20@writeWithI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdi+56], 16
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 554  :     char last = document_[document_.length() - 1];

	lea	rbx, QWORD PTR [rdi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN16@writeWithI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN17@writeWithI
$LN16@writeWithI:
	mov	rax, rbx
$LN17@writeWithI:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 554  :     char last = document_[document_.length() - 1];

	movzx	eax, BYTE PTR [rax+rcx-1]

; 555  :     if (last == ' ') // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN22@writeWithI

; 556  :       return;
; 557  :     if (last != '\n') // Comments may add new-line

	cmp	al, 10
	je	SHORT $LN20@writeWithI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 10
	mov	edx, 1
	mov	rcx, rbx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN20@writeWithI:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 560  :   document_ += indentString_;

	lea	rbx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rdi+64]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	mov	rcx, rbx
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN22@writeWithI:
	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rsi
	mov	rcx, rbx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 566  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?writeWithIndent@StyledWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledWriter::writeWithIndent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?indent@StyledWriter@Json@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
__$ArrayPad$ = 72
this$ = 96
?indent@StyledWriter@Json@@AEAAXXZ PROC			; Json::StyledWriter::indent, COMDAT

; 568  : void StyledWriter::indent() { indentString_ += JSONCPP_STRING(indentSize_, ' '); }

$LN78:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR $T1[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx
	mov	edx, DWORD PTR [rcx+100]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T2[rsp+24], 15

; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T2[rsp+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T2[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 796  : 		assign(_Count, _Ch);

	mov	r8b, 32					; 00000020H
	lea	rcx, QWORD PTR $T2[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 568  : void StyledWriter::indent() { indentString_ += JSONCPP_STRING(indentSize_, ' '); }

	lea	rcx, QWORD PTR [rbx+64]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T2[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T2[rsp+24], 16
	jb	SHORT $LN66@indent
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN66@indent:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 568  : void StyledWriter::indent() { indentString_ += JSONCPP_STRING(indentSize_, ' '); }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?indent@StyledWriter@Json@@AEAAXXZ ENDP			; Json::StyledWriter::indent
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
__$ArrayPad$ = 72
this$ = 96
?dtor$0@?0??indent@StyledWriter@Json@@AEAAXXZ@4HA PROC	; `Json::StyledWriter::indent'::`1'::dtor$0
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??indent@StyledWriter@Json@@AEAAXXZ@4HA ENDP	; `Json::StyledWriter::indent'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?unindent@StyledWriter@Json@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?unindent@StyledWriter@Json@@AEAAXXZ PROC		; Json::StyledWriter::unindent, COMDAT

; 571  :   assert(indentString_.size() >= indentSize_);
; 572  :   indentString_.resize(indentString_.size() - indentSize_);

	mov	eax, DWORD PTR [rcx+100]
	mov	rdx, QWORD PTR [rcx+80]
	add	rcx, 64					; 00000040H
	sub	rdx, rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1770 : 		if (_Newsize <= this->_Mysize)

	mov	rax, QWORD PTR [rcx+16]
	cmp	rdx, rax
	ja	SHORT $LN8@unindent

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+24], 16

; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN16@unindent
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR [rcx]
$LN16@unindent:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx+rdx], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 573  : }

	ret	0
$LN8@unindent:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

	sub	rdx, rax
	xor	r8d, r8d
	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?unindent@StyledWriter@Json@@AEAAXXZ ENDP		; Json::StyledWriter::unindent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
_TEXT	SEGMENT
$T1 = 32
$S1$ = 40
__$ArrayPad$ = 72
this$ = 96
root$ = 104
?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z PROC ; Json::StyledWriter::writeCommentBeforeValue, COMDAT

; 575  : void StyledWriter::writeCommentBeforeValue(const Value& root) {

$LN173:
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+120], rsi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	rsi, rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1411 :   return comments_ != 0 && comments_[placement].comment_ != 0;

	mov	rax, QWORD PTR [rdx+16]
	test	rax, rax
	je	$LN156@writeComme
	cmp	QWORD PTR [rax], 0
	je	$LN156@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	add	rcx, 32					; 00000020H
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1793 : 		return (this->_Mysize == 0);

	mov	rcx, QWORD PTR [rsi+48]
	test	rcx, rcx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 553  :   if (!document_.empty()) {

	je	SHORT $LN37@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rsi+56], 16
	jb	SHORT $LN33@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rsi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN34@writeComme
$LN33@writeComme:
	lea	rax, QWORD PTR [rsi+32]
$LN34@writeComme:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 554  :     char last = document_[document_.length() - 1];

	movzx	eax, BYTE PTR [rax+rcx-1]

; 555  :     if (last == ' ') // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN39@writeComme

; 556  :       return;
; 557  :     if (last != '\n') // Comments may add new-line

	cmp	al, 10
	je	SHORT $LN37@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 10
	mov	edx, 1
	lea	rcx, QWORD PTR [rsi+32]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN37@writeComme:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 560  :   document_ += indentString_;

	lea	rdx, QWORD PTR [rsi+64]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rcx, QWORD PTR [rsi+32]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN39@writeComme:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 581  :   const JSONCPP_STRING& comment = root.getComment(commentBefore);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $S1$[rsp]
	mov	rcx, rbx
	call	?getComment@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rbx, QWORD PTR $S1$[rsp]
	cmp	QWORD PTR $S1$[rsp+24], 16
	cmovae	rbx, QWORD PTR $S1$[rsp]
	npad	7
$LL3@writeComme:
	lea	rcx, QWORD PTR $S1$[rsp]
	cmp	QWORD PTR $S1$[rsp+24], 16
	cmovae	rcx, QWORD PTR $S1$[rsp]

; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));

	mov	rax, QWORD PTR $S1$[rsp+16]
	add	rax, rcx

; 1034 : 		return (append((size_type)1, _Ch));

	lea	rcx, QWORD PTR [rsi+32]

; 121  : 		return (*this);
; 122  : 		}
; 123  : 
; 124  : 	_Myiter operator++(int)
; 125  : 		{	// postincrement
; 126  : 		_Myiter _Tmp = *this;
; 127  : 		++*this;
; 128  : 		return (_Tmp);
; 129  : 		}
; 130  : 
; 131  : 	_Myiter& operator--()
; 132  : 		{	// predecrement
; 133  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 134  : 		if (this->_Getcont() == 0
; 135  : 			|| this->_Ptr == 0
; 136  : 			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())
; 137  : 			{	// report error
; 138  : 			_DEBUG_ERROR("string iterator not decrementable");
; 139  : 			_SCL_SECURE_OUT_OF_RANGE;
; 140  : 			}
; 141  : 
; 142  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 143  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 144  : 		_SCL_SECURE_VALIDATE_RANGE(
; 145  : 			((_Mystr *)this->_Getcont())->_Myptr() < this->_Ptr);
; 146  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 147  : 
; 148  : 		--this->_Ptr;
; 149  : 		return (*this);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter operator--(int)
; 153  : 		{	// postdecrement
; 154  : 		_Myiter _Tmp = *this;
; 155  : 		--*this;
; 156  : 		return (_Tmp);
; 157  : 		}
; 158  : 
; 159  : 	_Myiter& operator+=(difference_type _Off)
; 160  : 		{	// increment by integer
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 		if (this->_Getcont() == 0
; 163  : 			|| this->_Ptr == 0
; 164  : 			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()
; 165  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 166  : 				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)
; 167  : 			{	// report error
; 168  : 			_DEBUG_ERROR("string iterator + offset out of range");
; 169  : 			_SCL_SECURE_OUT_OF_RANGE;
; 170  : 			}
; 171  : 
; 172  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 173  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 174  : 		_SCL_SECURE_VALIDATE_RANGE(
; 175  : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr + _Off
; 176  : 				&& this->_Ptr + _Off <= ((_Mystr *)this->_Getcont())->_Myptr()
; 177  : 					+ ((_Mystr *)this->_Getcont())->_Mysize);
; 178  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 179  : 
; 180  : 		_Ptr += _Off;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myiter operator+(difference_type _Off) const
; 185  : 		{	// return this + integer
; 186  : 		_Myiter _Tmp = *this;
; 187  : 		return (_Tmp += _Off);
; 188  : 		}
; 189  : 
; 190  : 	_Myiter& operator-=(difference_type _Off)
; 191  : 		{	// decrement by integer
; 192  : 		return (*this += -_Off);
; 193  : 		}
; 194  : 
; 195  : 	_Myiter operator-(difference_type _Off) const
; 196  : 		{	// return this - integer
; 197  : 		_Myiter _Tmp = *this;
; 198  : 		return (_Tmp -= _Off);
; 199  : 		}
; 200  : 
; 201  : 	difference_type operator-(const _Myiter& _Right) const
; 202  : 		{	// return difference of iterators
; 203  : 		_Compat(_Right);
; 204  : 		return (this->_Ptr - _Right._Ptr);
; 205  : 		}
; 206  : 
; 207  : 	reference operator[](difference_type _Off) const
; 208  : 		{	// subscript
; 209  : 		return (*(*this + _Off));
; 210  : 		}
; 211  : 
; 212  : 	bool operator==(const _Myiter& _Right) const
; 213  : 		{	// test for iterator equality
; 214  : 		_Compat(_Right);
; 215  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, rax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 583  :   while (iter != comment.end()) {

	je	$LN134@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	movzx	r8d, BYTE PTR [rbx]
	mov	edx, 1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 586  :        (iter != comment.end() && *(iter + 1) == '/'))

	cmp	BYTE PTR [rbx], 10
	jne	SHORT $LN172@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rcx, QWORD PTR $S1$[rsp]
	cmp	QWORD PTR $S1$[rsp+24], 16
	cmovae	rcx, QWORD PTR $S1$[rsp]

; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));

	add	rcx, QWORD PTR $S1$[rsp+16]

; 121  : 		return (*this);
; 122  : 		}
; 123  : 
; 124  : 	_Myiter operator++(int)
; 125  : 		{	// postincrement
; 126  : 		_Myiter _Tmp = *this;
; 127  : 		++*this;
; 128  : 		return (_Tmp);
; 129  : 		}
; 130  : 
; 131  : 	_Myiter& operator--()
; 132  : 		{	// predecrement
; 133  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 134  : 		if (this->_Getcont() == 0
; 135  : 			|| this->_Ptr == 0
; 136  : 			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())
; 137  : 			{	// report error
; 138  : 			_DEBUG_ERROR("string iterator not decrementable");
; 139  : 			_SCL_SECURE_OUT_OF_RANGE;
; 140  : 			}
; 141  : 
; 142  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 143  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 144  : 		_SCL_SECURE_VALIDATE_RANGE(
; 145  : 			((_Mystr *)this->_Getcont())->_Myptr() < this->_Ptr);
; 146  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 147  : 
; 148  : 		--this->_Ptr;
; 149  : 		return (*this);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter operator--(int)
; 153  : 		{	// postdecrement
; 154  : 		_Myiter _Tmp = *this;
; 155  : 		--*this;
; 156  : 		return (_Tmp);
; 157  : 		}
; 158  : 
; 159  : 	_Myiter& operator+=(difference_type _Off)
; 160  : 		{	// increment by integer
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 		if (this->_Getcont() == 0
; 163  : 			|| this->_Ptr == 0
; 164  : 			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()
; 165  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 166  : 				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)
; 167  : 			{	// report error
; 168  : 			_DEBUG_ERROR("string iterator + offset out of range");
; 169  : 			_SCL_SECURE_OUT_OF_RANGE;
; 170  : 			}
; 171  : 
; 172  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 173  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 174  : 		_SCL_SECURE_VALIDATE_RANGE(
; 175  : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr + _Off
; 176  : 				&& this->_Ptr + _Off <= ((_Mystr *)this->_Getcont())->_Myptr()
; 177  : 					+ ((_Mystr *)this->_Getcont())->_Mysize);
; 178  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 179  : 
; 180  : 		_Ptr += _Off;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myiter operator+(difference_type _Off) const
; 185  : 		{	// return this + integer
; 186  : 		_Myiter _Tmp = *this;
; 187  : 		return (_Tmp += _Off);
; 188  : 		}
; 189  : 
; 190  : 	_Myiter& operator-=(difference_type _Off)
; 191  : 		{	// decrement by integer
; 192  : 		return (*this += -_Off);
; 193  : 		}
; 194  : 
; 195  : 	_Myiter operator-(difference_type _Off) const
; 196  : 		{	// return this - integer
; 197  : 		_Myiter _Tmp = *this;
; 198  : 		return (_Tmp -= _Off);
; 199  : 		}
; 200  : 
; 201  : 	difference_type operator-(const _Myiter& _Right) const
; 202  : 		{	// return difference of iterators
; 203  : 		_Compat(_Right);
; 204  : 		return (this->_Ptr - _Right._Ptr);
; 205  : 		}
; 206  : 
; 207  : 	reference operator[](difference_type _Off) const
; 208  : 		{	// subscript
; 209  : 		return (*(*this + _Off));
; 210  : 		}
; 211  : 
; 212  : 	bool operator==(const _Myiter& _Right) const
; 213  : 		{	// test for iterator equality
; 214  : 		_Compat(_Right);
; 215  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, rcx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 586  :        (iter != comment.end() && *(iter + 1) == '/'))

	je	SHORT $LN172@writeComme
	cmp	BYTE PTR [rbx+1], 47			; 0000002fH
	jne	SHORT $LN172@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	mov	rax, QWORD PTR [rsi+48]
	test	rax, rax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 553  :   if (!document_.empty()) {

	je	SHORT $LN120@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rsi+56], 16
	jb	SHORT $LN116@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR [rsi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN117@writeComme
$LN116@writeComme:
	lea	rcx, QWORD PTR [rsi+32]
$LN117@writeComme:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 554  :     char last = document_[document_.length() - 1];

	movzx	eax, BYTE PTR [rcx+rax-1]

; 555  :     if (last == ' ') // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN172@writeComme

; 556  :       return;
; 557  :     if (last != '\n') // Comments may add new-line

	cmp	al, 10
	je	SHORT $LN120@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	mov	r8b, 10
	mov	edx, 1
	lea	rcx, QWORD PTR [rsi+32]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN120@writeComme:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 560  :   document_ += indentString_;

	lea	rdx, QWORD PTR [rsi+64]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rcx, QWORD PTR [rsi+32]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN172@writeComme:

; 120  : 		++this->_Ptr;

	inc	rbx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 589  :   }

	jmp	$LL3@writeComme
$LN134@writeComme:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $S1$[rsp+24], 16
	jb	SHORT $LN156@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $S1$[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN156@writeComme:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 593  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentBeforeValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$S1$ = 40
__$ArrayPad$ = 72
this$ = 96
root$ = 104
?dtor$0@?0??writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeCommentBeforeValue'::`1'::dtor$0
	lea	rcx, QWORD PTR $S1$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??writeCommentBeforeValue@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeCommentBeforeValue'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 72
$T4 = 72
__$ArrayPad$ = 104
this$ = 128
root$ = 136
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z PROC ; Json::StyledWriter::writeCommentAfterValueOnSameLine, COMDAT

; 595  : void StyledWriter::writeCommentAfterValueOnSameLine(const Value& root) {

$LN138:
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+144], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	rdi, rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1411 :   return comments_ != 0 && comments_[placement].comment_ != 0;

	mov	rax, QWORD PTR [rdx+16]
	test	rax, rax
	je	$LN68@writeComme
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN68@writeComme
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 597  :     document_ += " " + root.getComment(commentAfterOnSameLine);

	mov	r8d, 1
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rbx
	call	?getComment@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	npad	1
	mov	r8, rax
	lea	rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+32]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T2[rsp+24], 16
	jb	SHORT $LN36@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN36@writeComme:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T2[rsp+24], 15

; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T2[rsp+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T2[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rsp+24], 16
	jb	SHORT $LN68@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN68@writeComme:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1411 :   return comments_ != 0 && comments_[placement].comment_ != 0;

	mov	rax, QWORD PTR [rbx+16]
	test	rax, rax
	je	SHORT $LN128@writeComme
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN128@writeComme
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 600  :     document_ += "\n";

	add	rdi, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 601  :     document_ += root.getComment(commentAfter);

	mov	r8d, 2
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rbx
	call	?getComment@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T3[rsp+24], 16
	jb	SHORT $LN116@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN116@writeComme:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN128@writeComme:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 604  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentAfterValueOnSameLine
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 72
$T4 = 72
__$ArrayPad$ = 104
this$ = 128
root$ = 136
?dtor$0@?0??writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$0
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 72
$T4 = 72
__$ArrayPad$ = 104
this$ = 128
root$ = 136
?dtor$1@?0??writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 72
$T4 = 72
__$ArrayPad$ = 104
this$ = 128
root$ = 136
?dtor$2@?0??writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::StyledWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$2
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??writeCommentAfterValueOnSameLine@StyledWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::StyledWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?hasCommentForValue@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
value$ = 16
?hasCommentForValue@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z PROC ; Json::StyledWriter::hasCommentForValue, COMDAT
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1411 :   return comments_ != 0 && comments_[placement].comment_ != 0;

	mov	rax, QWORD PTR [rdx+16]
	test	rax, rax
	je	SHORT $LN15@hasComment
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN3@hasComment
	test	rax, rax
	je	SHORT $LN15@hasComment
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN3@hasComment
	test	rax, rax
	je	SHORT $LN15@hasComment
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN15@hasComment
$LN3@hasComment:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 609  :          value.hasComment(commentAfter);

	mov	al, 1

; 610  : }

	ret	0
$LN15@hasComment:

; 609  :          value.hasComment(commentAfter);

	xor	al, al

; 610  : }

	ret	0
?hasCommentForValue@StyledWriter@Json@@AEAA_NAEBVValue@2@@Z ENDP ; Json::StyledWriter::hasCommentForValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
indentation$ = 72
cs$ = 80
colonSymbol$ = 88
nullSymbol$ = 96
endingLineFeedSymbol$ = 104
useSpecialFloats$ = 112
precision$ = 120
??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z PROC ; Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter, COMDAT

; 897  : {

$LN226:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+88], rsi
	mov	rdi, r9
	mov	ebx, r8d
	mov	rsi, rcx

; 899  : int BuiltStyledStreamWriter::write(Value const& root, JSONCPP_OSTREAM* sout)
; 900  : {
; 901  :   sout_ = sout;
; 902  :   addChildValues_ = false;
; 903  :   indented_ = true;
; 904  :   indentString_.clear();
; 905  :   writeCommentBeforeValue(root);
; 906  :   if (!indented_) writeIndent();
; 907  :   indented_ = true;
; 908  :   writeValue(root);
; 909  :   writeCommentAfterValueOnSameLine(root);
; 910  :   *sout_ << endingLineFeedSymbol_;
; 911  :   sout_ = NULL;
; 912  :   return 0;
; 913  : }
; 914  : void BuiltStyledStreamWriter::writeValue(Value const& value) {
; 915  :   switch (value.type()) {
; 916  :   case nullValue:
; 917  :     pushValue(nullSymbol_);
; 918  :     break;
; 919  :   case intValue:
; 920  :     pushValue(valueToString(value.asLargestInt()));
; 921  :     break;
; 922  :   case uintValue:
; 923  :     pushValue(valueToString(value.asLargestUInt()));
; 924  :     break;
; 925  :   case realValue:
; 926  :     pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_));
; 927  :     break;
; 928  :   case stringValue:
; 929  :   {
; 930  :     // Is NULL is possible for value.string_? No.
; 931  :     char const* str;
; 932  :     char const* end;
; 933  :     bool ok = value.getString(&str, &end);
; 934  :     if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end-str)));
; 935  :     else pushValue("");
; 936  :     break;
; 937  :   }
; 938  :   case booleanValue:
; 939  :     pushValue(valueToString(value.asBool()));
; 940  :     break;
; 941  :   case arrayValue:
; 942  :     writeArrayValue(value);
; 943  :     break;
; 944  :   case objectValue: {
; 945  :     Value::Members members(value.getMemberNames());
; 946  :     if (members.empty())
; 947  :       pushValue("{}");
; 948  :     else {
; 949  :       writeWithIndent("{");
; 950  :       indent();
; 951  :       Value::Members::iterator it = members.begin();
; 952  :       for (;;) {
; 953  :         JSONCPP_STRING const& name = *it;
; 954  :         Value const& childValue = value[name];
; 955  :         writeCommentBeforeValue(childValue);
; 956  :         writeWithIndent(valueToQuotedStringN(name.data(), static_cast<unsigned>(name.length())));
; 957  :         *sout_ << colonSymbol_;
; 958  :         writeValue(childValue);
; 959  :         if (++it == members.end()) {
; 960  :           writeCommentAfterValueOnSameLine(childValue);
; 961  :           break;
; 962  :         }
; 963  :         *sout_ << ",";
; 964  :         writeCommentAfterValueOnSameLine(childValue);
; 965  :       }
; 966  :       unindent();
; 967  :       writeWithIndent("}");
; 968  :     }
; 969  :   } break;
; 970  :   }
; 971  : }
; 972  : 
; 973  : void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
; 974  :   unsigned size = value.size();
; 975  :   if (size == 0)
; 976  :     pushValue("[]");
; 977  :   else {
; 978  :     bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
; 979  :     if (isMultiLine) {
; 980  :       writeWithIndent("[");
; 981  :       indent();
; 982  :       bool hasChildValue = !childValues_.empty();
; 983  :       unsigned index = 0;
; 984  :       for (;;) {
; 985  :         Value const& childValue = value[index];
; 986  :         writeCommentBeforeValue(childValue);
; 987  :         if (hasChildValue)
; 988  :           writeWithIndent(childValues_[index]);
; 989  :         else {
; 990  :           if (!indented_) writeIndent();
; 991  :           indented_ = true;
; 992  :           writeValue(childValue);
; 993  :           indented_ = false;
; 994  :         }
; 995  :         if (++index == size) {
; 996  :           writeCommentAfterValueOnSameLine(childValue);
; 997  :           break;
; 998  :         }
; 999  :         *sout_ << ",";
; 1000 :         writeCommentAfterValueOnSameLine(childValue);
; 1001 :       }
; 1002 :       unindent();
; 1003 :       writeWithIndent("]");
; 1004 :     } else // output on a single line
; 1005 :     {
; 1006 :       assert(childValues_.size() == size);
; 1007 :       *sout_ << "[";
; 1008 :       if (!indentation_.empty()) *sout_ << " ";
; 1009 :       for (unsigned index = 0; index < size; ++index) {
; 1010 :         if (index > 0)
; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");
; 1012 :         *sout_ << childValues_[index];
; 1013 :       }
; 1014 :       if (!indentation_.empty()) *sout_ << " ";
; 1015 :       *sout_ << "]";
; 1016 :     }
; 1017 :   }
; 1018 : }
; 1019 : 
; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
; 1021 :   ArrayIndex const size = value.size();
; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;
; 1023 :   childValues_.clear();
; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 1025 :     Value const& childValue = value[index];
; 1026 :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 1027 :                         childValue.size() > 0);
; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length
; 1030 :   {
; 1031 :     childValues_.reserve(size);
; 1032 :     addChildValues_ = true;
; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {
; 1035 :       if (hasCommentForValue(value[index])) {
; 1036 :         isMultiLine = true;
; 1037 :       }
; 1038 :       writeValue(value[index]);
; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 1040 :     }
; 1041 :     addChildValues_ = false;
; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }
; 1046 : 
; 1047 : void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
; 1048 :   if (addChildValues_)
; 1049 :     childValues_.push_back(value);
; 1050 :   else
; 1051 :     *sout_ << value;
; 1052 : }
; 1053 : 
; 1054 : void BuiltStyledStreamWriter::writeIndent() {
; 1055 :   // blep intended this to look at the so-far-written string
; 1056 :   // to determine whether we are already indented, but
; 1057 :   // with a stream we cannot do that. So we rely on some saved state.
; 1058 :   // The caller checks indented_.
; 1059 : 
; 1060 :   if (!indentation_.empty()) {
; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;
; 1063 :   }
; 1064 : }
; 1065 : 
; 1066 : void BuiltStyledStreamWriter::writeWithIndent(JSONCPP_STRING const& value) {
; 1067 :   if (!indented_) writeIndent();
; 1068 :   *sout_ << value;
; 1069 :   indented_ = false;
; 1070 : }
; 1071 : 
; 1072 : void BuiltStyledStreamWriter::indent() { indentString_ += indentation_; }
; 1073 : 
; 1074 : void BuiltStyledStreamWriter::unindent() {
; 1075 :   assert(indentString_.size() >= indentation_.size());
; 1076 :   indentString_.resize(indentString_.size() - indentation_.size());
; 1077 : }
; 1078 : 
; 1079 : void BuiltStyledStreamWriter::writeCommentBeforeValue(Value const& root) {
; 1080 :   if (cs_ == CommentStyle::None) return;
; 1081 :   if (!root.hasComment(commentBefore))
; 1082 :     return;
; 1083 : 
; 1084 :   if (!indented_) writeIndent();
; 1085 :   const JSONCPP_STRING& comment = root.getComment(commentBefore);
; 1086 :   JSONCPP_STRING::const_iterator iter = comment.begin();
; 1087 :   while (iter != comment.end()) {
; 1088 :     *sout_ << *iter;
; 1089 :     if (*iter == '\n' &&
; 1090 :        (iter != comment.end() && *(iter + 1) == '/'))
; 1091 :       // writeIndent();  // would write extra newline
; 1092 :       *sout_ << indentString_;
; 1093 :     ++iter;
; 1094 :   }
; 1095 :   indented_ = false;
; 1096 : }
; 1097 : 
; 1098 : void BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine(Value const& root) {
; 1099 :   if (cs_ == CommentStyle::None) return;
; 1100 :   if (root.hasComment(commentAfterOnSameLine))
; 1101 :     *sout_ << " " + root.getComment(commentAfterOnSameLine);
; 1102 : 
; 1103 :   if (root.hasComment(commentAfter)) {
; 1104 :     writeIndent();
; 1105 :     *sout_ << root.getComment(commentAfter);
; 1106 :   }
; 1107 : }
; 1108 : 
; 1109 : // static
; 1110 : bool BuiltStyledStreamWriter::hasCommentForValue(const Value& value) {
; 1111 :   return value.hasComment(commentBefore) ||
; 1112 :          value.hasComment(commentAfterOnSameLine) ||
; 1113 :          value.hasComment(commentAfter);
; 1114 : }
; 1115 : 
; 1116 : ///////////////
; 1117 : // StreamWriter
; 1118 : 
; 1119 : StreamWriter::StreamWriter()
; 1120 :     : sout_(NULL)
; 1121 : {

	xor	ebp, ebp
	mov	QWORD PTR [rcx+8], rbp

; 897  : {

	lea	rax, OFFSET FLAT:??_7BuiltStyledStreamWriter@Json@@6B@
	mov	QWORD PTR [rcx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rcx+16], rbp

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+24], rbp

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+32], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+64], 15

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+56], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx+40], bpl
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 897  : {

	mov	DWORD PTR [rcx+72], 74			; 0000004aH
	add	rcx, 80					; 00000050H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], bpl
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 897  : {

	mov	DWORD PTR [rsi+112], ebx
	lea	rcx, QWORD PTR [rsi+120]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], bpl
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 897  : {

	lea	rcx, QWORD PTR [rsi+152]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], bpl
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, QWORD PTR nullSymbol$[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 897  : {

	lea	rcx, QWORD PTR [rsi+184]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rbp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], bpl
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, QWORD PTR endingLineFeedSymbol$[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 897  : {

	and	BYTE PTR [rsi+216], 248			; 000000f8H
	movzx	eax, BYTE PTR useSpecialFloats$[rsp]
	and	al, 1
	shl	al, 2
	or	BYTE PTR [rsi+216], al
	mov	eax, DWORD PTR precision$[rsp]
	mov	DWORD PTR [rsi+220], eax

; 898  : }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z ENDP ; Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
indentation$ = 72
cs$ = 80
colonSymbol$ = 88
nullSymbol$ = 96
endingLineFeedSymbol$ = 104
useSpecialFloats$ = 112
precision$ = 120
?dtor$0@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1StreamWriter@Json@@UEAA@XZ		; Json::StreamWriter::~StreamWriter
?dtor$0@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
indentation$ = 72
cs$ = 80
colonSymbol$ = 88
nullSymbol$ = 96
endingLineFeedSymbol$ = 104
useSpecialFloats$ = 112
precision$ = 120
?dtor$1@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 16
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$1@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
indentation$ = 72
cs$ = 80
colonSymbol$ = 88
nullSymbol$ = 96
endingLineFeedSymbol$ = 104
useSpecialFloats$ = 112
precision$ = 120
?dtor$2@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
indentation$ = 72
cs$ = 80
colonSymbol$ = 88
nullSymbol$ = 96
endingLineFeedSymbol$ = 104
useSpecialFloats$ = 112
precision$ = 120
?dtor$3@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$3
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 80					; 00000050H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
indentation$ = 72
cs$ = 80
colonSymbol$ = 88
nullSymbol$ = 96
endingLineFeedSymbol$ = 104
useSpecialFloats$ = 112
precision$ = 120
?dtor$4@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$4
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 120				; 00000078H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
indentation$ = 72
cs$ = 80
colonSymbol$ = 88
nullSymbol$ = 96
endingLineFeedSymbol$ = 104
useSpecialFloats$ = 112
precision$ = 120
?dtor$5@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$5
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 152				; 00000098H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0???0BuiltStyledStreamWriter@Json@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Enum@CommentStyle@1@000_NI@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::BuiltStyledStreamWriter'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GBuiltStyledStreamWriter@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GBuiltStyledStreamWriter@Json@@UEAAPEAXI@Z PROC	; Json::BuiltStyledStreamWriter::`scalar deleting destructor', COMDAT
$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rdi, rcx
	call	??1BuiltStyledStreamWriter@Json@@UEAA@XZ
	test	bl, 1
	je	SHORT $LN4@scalar
	mov	rcx, rdi
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN4@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GBuiltStyledStreamWriter@Json@@UEAAPEAXI@Z ENDP	; Json::BuiltStyledStreamWriter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??1BuiltStyledStreamWriter@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1BuiltStyledStreamWriter@Json@@UEAA@XZ PROC		; Json::BuiltStyledStreamWriter::~BuiltStyledStreamWriter, COMDAT
$LN168:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rcx+208], 16
	mov	rbx, rcx
	jb	SHORT $LN23@BuiltStyle
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rcx+184]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN23@BuiltStyle:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	edi, edi

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+208], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+200], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+184], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rbx+176], 16
	jb	SHORT $LN55@BuiltStyle
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx+152]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN55@BuiltStyle:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+176], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+168], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+152], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rbx+144], 16
	jb	SHORT $LN87@BuiltStyle
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx+120]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN87@BuiltStyle:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+144], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+136], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+120], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rbx+104], 16
	jb	SHORT $LN119@BuiltStyle
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx+80]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN119@BuiltStyle:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+104], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+96], rdi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+80], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rbx+64], 16
	jb	SHORT $LN151@BuiltStyle
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN151@BuiltStyle:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+64], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+56], rdi
	lea	rcx, QWORD PTR [rbx+16]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+40], dil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 945  : 		_Tidy();

	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1124 : {

	lea	rax, OFFSET FLAT:??_7StreamWriter@Json@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1BuiltStyledStreamWriter@Json@@UEAA@XZ ENDP		; Json::BuiltStyledStreamWriter::~BuiltStyledStreamWriter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?write@BuiltStyledStreamWriter@Json@@UEAAHAEBVValue@2@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z
_TEXT	SEGMENT
this$ = 48
root$ = 56
sout$ = 64
?write@BuiltStyledStreamWriter@Json@@UEAAHAEBVValue@2@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z PROC ; Json::BuiltStyledStreamWriter::write, COMDAT

; 900  : {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 901  :   sout_ = sout;
; 902  :   addChildValues_ = false;

	and	BYTE PTR [rcx+216], 254			; 000000feH

; 903  :   indented_ = true;

	or	BYTE PTR [rcx+216], 2
	mov	QWORD PTR [rcx+8], r8
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+64], 16
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 900  : {

	mov	rsi, rdx
	mov	rbx, rcx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+56], 0

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN10@write
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rcx+40]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN11@write
$LN10@write:
	lea	rax, QWORD PTR [rcx+40]
$LN11@write:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 905  :   writeCommentBeforeValue(root);

	call	?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeCommentBeforeValue

; 906  :   if (!indented_) writeIndent();

	test	BYTE PTR [rbx+216], 2
	jne	SHORT $LN16@write
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1060 :   if (!indentation_.empty()) {

	je	SHORT $LN16@write

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	mov	rcx, QWORD PTR [rbx+8]
	mov	dl, 10
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, QWORD PTR [rbx+40]
	mov	rcx, rax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN16@write:

; 907  :   indented_ = true;

	or	BYTE PTR [rbx+216], 2

; 908  :   writeValue(root);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeValue

; 909  :   writeCommentAfterValueOnSameLine(root);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine

; 910  :   *sout_ << endingLineFeedSymbol_;

	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, QWORD PTR [rbx+184]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 911  :   sout_ = NULL;
; 912  :   return 0;
; 913  : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	QWORD PTR [rbx+8], 0
	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?write@BuiltStyledStreamWriter@Json@@UEAAHAEBVValue@2@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z ENDP ; Json::BuiltStyledStreamWriter::write
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
_TEXT	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z PROC ; Json::BuiltStyledStreamWriter::writeValue, COMDAT

; 914  : void BuiltStyledStreamWriter::writeValue(Value const& value) {

$LN714:
	push	rbp
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [rsp-160]
	sub	rsp, 416				; 000001a0H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rsp+464], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r8, rdx
	mov	QWORD PTR value$GSCopy$1$[rsp], rdx
	mov	rdi, rcx

; 915  :   switch (value.type()) {

	movsx	rdx, BYTE PTR [rdx+8]
	mov	rax, rdx
	cmp	edx, 7
	ja	$LN639@writeValue
	lea	r9, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN712@writeValue[r9+rdx*4]
	add	rcx, r9
	jmp	rcx
$LN15@writeValue:

; 916  :   case nullValue:
; 917  :     pushValue(nullSymbol_);

	lea	rdx, QWORD PTR [rdi+152]

; 972  : 
; 973  : void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
; 974  :   unsigned size = value.size();
; 975  :   if (size == 0)
; 976  :     pushValue("[]");
; 977  :   else {
; 978  :     bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
; 979  :     if (isMultiLine) {
; 980  :       writeWithIndent("[");
; 981  :       indent();
; 982  :       bool hasChildValue = !childValues_.empty();
; 983  :       unsigned index = 0;
; 984  :       for (;;) {
; 985  :         Value const& childValue = value[index];
; 986  :         writeCommentBeforeValue(childValue);
; 987  :         if (hasChildValue)
; 988  :           writeWithIndent(childValues_[index]);
; 989  :         else {
; 990  :           if (!indented_) writeIndent();
; 991  :           indented_ = true;
; 992  :           writeValue(childValue);
; 993  :           indented_ = false;
; 994  :         }
; 995  :         if (++index == size) {
; 996  :           writeCommentAfterValueOnSameLine(childValue);
; 997  :           break;
; 998  :         }
; 999  :         *sout_ << ",";
; 1000 :         writeCommentAfterValueOnSameLine(childValue);
; 1001 :       }
; 1002 :       unindent();
; 1003 :       writeWithIndent("]");
; 1004 :     } else // output on a single line
; 1005 :     {
; 1006 :       assert(childValues_.size() == size);
; 1007 :       *sout_ << "[";
; 1008 :       if (!indentation_.empty()) *sout_ << " ";
; 1009 :       for (unsigned index = 0; index < size; ++index) {
; 1010 :         if (index > 0)
; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");
; 1012 :         *sout_ << childValues_[index];
; 1013 :       }
; 1014 :       if (!indentation_.empty()) *sout_ << " ";
; 1015 :       *sout_ << "]";
; 1016 :     }
; 1017 :   }
; 1018 : }
; 1019 : 
; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
; 1021 :   ArrayIndex const size = value.size();
; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;
; 1023 :   childValues_.clear();
; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 1025 :     Value const& childValue = value[index];
; 1026 :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 1027 :                         childValue.size() > 0);
; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length
; 1030 :   {
; 1031 :     childValues_.reserve(size);
; 1032 :     addChildValues_ = true;
; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {
; 1035 :       if (hasCommentForValue(value[index])) {
; 1036 :         isMultiLine = true;
; 1037 :       }
; 1038 :       writeValue(value[index]);
; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 1040 :     }
; 1041 :     addChildValues_ = false;
; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }
; 1046 : 
; 1047 : void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
; 1048 :   if (addChildValues_)

	test	BYTE PTR [rdi+216], 1
	je	SHORT $LN34@writeValue

; 1049 :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+16]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 1050 :   else

	jmp	$LN639@writeValue
$LN34@writeValue:

; 1051 :     *sout_ << value;

	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 918  :     break;

	jmp	$LN639@writeValue
$LN14@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 802  :   return asInt64();

	mov	rcx, r8
	call	?asInt64@Value@Json@@QEBA_JXZ		; Json::Value::asInt64
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 920  :     pushValue(valueToString(value.asLargestInt()));

	mov	rdx, rax
	lea	rcx, QWORD PTR $T8[rbp-256]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z ; Json::valueToString
	npad	1

; 1049 :     childValues_.push_back(value);

	mov	rdx, rax

; 972  : 
; 973  : void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
; 974  :   unsigned size = value.size();
; 975  :   if (size == 0)
; 976  :     pushValue("[]");
; 977  :   else {
; 978  :     bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
; 979  :     if (isMultiLine) {
; 980  :       writeWithIndent("[");
; 981  :       indent();
; 982  :       bool hasChildValue = !childValues_.empty();
; 983  :       unsigned index = 0;
; 984  :       for (;;) {
; 985  :         Value const& childValue = value[index];
; 986  :         writeCommentBeforeValue(childValue);
; 987  :         if (hasChildValue)
; 988  :           writeWithIndent(childValues_[index]);
; 989  :         else {
; 990  :           if (!indented_) writeIndent();
; 991  :           indented_ = true;
; 992  :           writeValue(childValue);
; 993  :           indented_ = false;
; 994  :         }
; 995  :         if (++index == size) {
; 996  :           writeCommentAfterValueOnSameLine(childValue);
; 997  :           break;
; 998  :         }
; 999  :         *sout_ << ",";
; 1000 :         writeCommentAfterValueOnSameLine(childValue);
; 1001 :       }
; 1002 :       unindent();
; 1003 :       writeWithIndent("]");
; 1004 :     } else // output on a single line
; 1005 :     {
; 1006 :       assert(childValues_.size() == size);
; 1007 :       *sout_ << "[";
; 1008 :       if (!indentation_.empty()) *sout_ << " ";
; 1009 :       for (unsigned index = 0; index < size; ++index) {
; 1010 :         if (index > 0)
; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");
; 1012 :         *sout_ << childValues_[index];
; 1013 :       }
; 1014 :       if (!indentation_.empty()) *sout_ << " ";
; 1015 :       *sout_ << "]";
; 1016 :     }
; 1017 :   }
; 1018 : }
; 1019 : 
; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
; 1021 :   ArrayIndex const size = value.size();
; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;
; 1023 :   childValues_.clear();
; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 1025 :     Value const& childValue = value[index];
; 1026 :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 1027 :                         childValue.size() > 0);
; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length
; 1030 :   {
; 1031 :     childValues_.reserve(size);
; 1032 :     addChildValues_ = true;
; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {
; 1035 :       if (hasCommentForValue(value[index])) {
; 1036 :         isMultiLine = true;
; 1037 :       }
; 1038 :       writeValue(value[index]);
; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 1040 :     }
; 1041 :     addChildValues_ = false;
; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }
; 1046 : 
; 1047 : void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
; 1048 :   if (addChildValues_)

	test	BYTE PTR [rdi+216], 1
	je	SHORT $LN40@writeValue

; 1049 :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+16]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 1050 :   else

	jmp	SHORT $LN39@writeValue
$LN40@writeValue:

; 1051 :     *sout_ << value;

	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN39@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T8[rbp-232], 16
	jb	$LN639@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T8[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 921  :     break;

	jmp	$LN713@writeValue
$LN13@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 810  :   return asUInt64();

	mov	rcx, r8
	call	?asUInt64@Value@Json@@QEBA_KXZ		; Json::Value::asUInt64
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 923  :     pushValue(valueToString(value.asLargestUInt()));

	mov	rdx, rax
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::valueToString
	npad	1

; 1049 :     childValues_.push_back(value);

	mov	rdx, rax

; 972  : 
; 973  : void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
; 974  :   unsigned size = value.size();
; 975  :   if (size == 0)
; 976  :     pushValue("[]");
; 977  :   else {
; 978  :     bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
; 979  :     if (isMultiLine) {
; 980  :       writeWithIndent("[");
; 981  :       indent();
; 982  :       bool hasChildValue = !childValues_.empty();
; 983  :       unsigned index = 0;
; 984  :       for (;;) {
; 985  :         Value const& childValue = value[index];
; 986  :         writeCommentBeforeValue(childValue);
; 987  :         if (hasChildValue)
; 988  :           writeWithIndent(childValues_[index]);
; 989  :         else {
; 990  :           if (!indented_) writeIndent();
; 991  :           indented_ = true;
; 992  :           writeValue(childValue);
; 993  :           indented_ = false;
; 994  :         }
; 995  :         if (++index == size) {
; 996  :           writeCommentAfterValueOnSameLine(childValue);
; 997  :           break;
; 998  :         }
; 999  :         *sout_ << ",";
; 1000 :         writeCommentAfterValueOnSameLine(childValue);
; 1001 :       }
; 1002 :       unindent();
; 1003 :       writeWithIndent("]");
; 1004 :     } else // output on a single line
; 1005 :     {
; 1006 :       assert(childValues_.size() == size);
; 1007 :       *sout_ << "[";
; 1008 :       if (!indentation_.empty()) *sout_ << " ";
; 1009 :       for (unsigned index = 0; index < size; ++index) {
; 1010 :         if (index > 0)
; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");
; 1012 :         *sout_ << childValues_[index];
; 1013 :       }
; 1014 :       if (!indentation_.empty()) *sout_ << " ";
; 1015 :       *sout_ << "]";
; 1016 :     }
; 1017 :   }
; 1018 : }
; 1019 : 
; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
; 1021 :   ArrayIndex const size = value.size();
; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;
; 1023 :   childValues_.clear();
; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 1025 :     Value const& childValue = value[index];
; 1026 :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 1027 :                         childValue.size() > 0);
; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length
; 1030 :   {
; 1031 :     childValues_.reserve(size);
; 1032 :     addChildValues_ = true;
; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {
; 1035 :       if (hasCommentForValue(value[index])) {
; 1036 :         isMultiLine = true;
; 1037 :       }
; 1038 :       writeValue(value[index]);
; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 1040 :     }
; 1041 :     addChildValues_ = false;
; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }
; 1046 : 
; 1047 : void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
; 1048 :   if (addChildValues_)

	test	BYTE PTR [rdi+216], 1
	je	SHORT $LN78@writeValue

; 1049 :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+16]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 1050 :   else

	jmp	SHORT $LN77@writeValue
$LN78@writeValue:

; 1051 :     *sout_ << value;

	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN77@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T11[rbp-232], 16
	jb	$LN639@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T11[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 924  :     break;

	jmp	$LN713@writeValue
$LN12@writeValue:

; 925  :   case realValue:
; 926  :     pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_));

	movzx	ebx, BYTE PTR [rdi+216]
	shr	bl, 2
	and	bl, 1
	mov	rcx, r8
	call	?asDouble@Value@Json@@QEBANXZ		; Json::Value::asDouble
	movaps	xmm1, xmm0
	mov	r9d, DWORD PTR [rdi+220]
	movzx	r8d, bl
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	?valueToString@?A0xcff6a387@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N_NI@Z ; Json::`anonymous namespace'::valueToString
	npad	1

; 1049 :     childValues_.push_back(value);

	mov	rdx, rax

; 972  : 
; 973  : void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
; 974  :   unsigned size = value.size();
; 975  :   if (size == 0)
; 976  :     pushValue("[]");
; 977  :   else {
; 978  :     bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
; 979  :     if (isMultiLine) {
; 980  :       writeWithIndent("[");
; 981  :       indent();
; 982  :       bool hasChildValue = !childValues_.empty();
; 983  :       unsigned index = 0;
; 984  :       for (;;) {
; 985  :         Value const& childValue = value[index];
; 986  :         writeCommentBeforeValue(childValue);
; 987  :         if (hasChildValue)
; 988  :           writeWithIndent(childValues_[index]);
; 989  :         else {
; 990  :           if (!indented_) writeIndent();
; 991  :           indented_ = true;
; 992  :           writeValue(childValue);
; 993  :           indented_ = false;
; 994  :         }
; 995  :         if (++index == size) {
; 996  :           writeCommentAfterValueOnSameLine(childValue);
; 997  :           break;
; 998  :         }
; 999  :         *sout_ << ",";
; 1000 :         writeCommentAfterValueOnSameLine(childValue);
; 1001 :       }
; 1002 :       unindent();
; 1003 :       writeWithIndent("]");
; 1004 :     } else // output on a single line
; 1005 :     {
; 1006 :       assert(childValues_.size() == size);
; 1007 :       *sout_ << "[";
; 1008 :       if (!indentation_.empty()) *sout_ << " ";
; 1009 :       for (unsigned index = 0; index < size; ++index) {
; 1010 :         if (index > 0)
; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");
; 1012 :         *sout_ << childValues_[index];
; 1013 :       }
; 1014 :       if (!indentation_.empty()) *sout_ << " ";
; 1015 :       *sout_ << "]";
; 1016 :     }
; 1017 :   }
; 1018 : }
; 1019 : 
; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
; 1021 :   ArrayIndex const size = value.size();
; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;
; 1023 :   childValues_.clear();
; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 1025 :     Value const& childValue = value[index];
; 1026 :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 1027 :                         childValue.size() > 0);
; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length
; 1030 :   {
; 1031 :     childValues_.reserve(size);
; 1032 :     addChildValues_ = true;
; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {
; 1035 :       if (hasCommentForValue(value[index])) {
; 1036 :         isMultiLine = true;
; 1037 :       }
; 1038 :       writeValue(value[index]);
; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 1040 :     }
; 1041 :     addChildValues_ = false;
; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }
; 1046 : 
; 1047 : void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
; 1048 :   if (addChildValues_)

	test	BYTE PTR [rdi+216], 1
	je	SHORT $LN114@writeValue

; 1049 :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+16]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 1050 :   else

	jmp	SHORT $LN113@writeValue
$LN114@writeValue:

; 1051 :     *sout_ << value;

	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN113@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T9[rbp-232], 16
	jb	$LN639@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T9[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 927  :     break;

	jmp	$LN713@writeValue
$LN11@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 666  :   if (type_ != stringValue) return false;

	cmp	dl, 4
	jne	SHORT $LN10@writeValue

; 667  :   if (value_.string_ == 0) return false;

	mov	rdx, QWORD PTR [r8]
	test	rdx, rdx
	je	SHORT $LN10@writeValue

; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);

	mov	eax, DWORD PTR [r8+8]
	shr	eax, 8
	and	al, 1

; 143  :   if (!isPrefixed) {

	jne	SHORT $LN154@writeValue

; 144  :     *length = static_cast<unsigned>(strlen(prefixed));

	or	r9, -1
$LL711@writeValue:
	inc	r9
	cmp	BYTE PTR [rdx+r9], 0
	jne	SHORT $LL711@writeValue

; 145  :     *value = prefixed;
; 146  :   } else {

	jmp	SHORT $LN153@writeValue
$LN154@writeValue:

; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);

	mov	r9d, DWORD PTR [rdx]

; 148  :     *value = prefixed + sizeof(unsigned);

	add	rdx, 4
$LN153@writeValue:

; 670  :   *cend = *str + length;

	mov	r8d, r9d
	add	r8, rdx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 934  :     if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end-str)));

	sub	r8d, edx
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z ; Json::valueToQuotedStringN
	npad	1

; 1049 :     childValues_.push_back(value);

	mov	rdx, rax

; 972  : 
; 973  : void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
; 974  :   unsigned size = value.size();
; 975  :   if (size == 0)
; 976  :     pushValue("[]");
; 977  :   else {
; 978  :     bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
; 979  :     if (isMultiLine) {
; 980  :       writeWithIndent("[");
; 981  :       indent();
; 982  :       bool hasChildValue = !childValues_.empty();
; 983  :       unsigned index = 0;
; 984  :       for (;;) {
; 985  :         Value const& childValue = value[index];
; 986  :         writeCommentBeforeValue(childValue);
; 987  :         if (hasChildValue)
; 988  :           writeWithIndent(childValues_[index]);
; 989  :         else {
; 990  :           if (!indented_) writeIndent();
; 991  :           indented_ = true;
; 992  :           writeValue(childValue);
; 993  :           indented_ = false;
; 994  :         }
; 995  :         if (++index == size) {
; 996  :           writeCommentAfterValueOnSameLine(childValue);
; 997  :           break;
; 998  :         }
; 999  :         *sout_ << ",";
; 1000 :         writeCommentAfterValueOnSameLine(childValue);
; 1001 :       }
; 1002 :       unindent();
; 1003 :       writeWithIndent("]");
; 1004 :     } else // output on a single line
; 1005 :     {
; 1006 :       assert(childValues_.size() == size);
; 1007 :       *sout_ << "[";
; 1008 :       if (!indentation_.empty()) *sout_ << " ";
; 1009 :       for (unsigned index = 0; index < size; ++index) {
; 1010 :         if (index > 0)
; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");
; 1012 :         *sout_ << childValues_[index];
; 1013 :       }
; 1014 :       if (!indentation_.empty()) *sout_ << " ";
; 1015 :       *sout_ << "]";
; 1016 :     }
; 1017 :   }
; 1018 : }
; 1019 : 
; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
; 1021 :   ArrayIndex const size = value.size();
; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;
; 1023 :   childValues_.clear();
; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 1025 :     Value const& childValue = value[index];
; 1026 :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 1027 :                         childValue.size() > 0);
; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length
; 1030 :   {
; 1031 :     childValues_.reserve(size);
; 1032 :     addChildValues_ = true;
; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {
; 1035 :       if (hasCommentForValue(value[index])) {
; 1036 :         isMultiLine = true;
; 1037 :       }
; 1038 :       writeValue(value[index]);
; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 1040 :     }
; 1041 :     addChildValues_ = false;
; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }
; 1046 : 
; 1047 : void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
; 1048 :   if (addChildValues_)

	test	BYTE PTR [rdi+216], 1
	je	SHORT $LN158@writeValue

; 1049 :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+16]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 1050 :   else

	jmp	SHORT $LN157@writeValue
$LN158@writeValue:

; 1051 :     *sout_ << value;

	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN157@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T10[rbp-232], 16
	jb	$LN639@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T10[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 935  :     else pushValue("");

	jmp	$LN713@writeValue
$LN10@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T6[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	esi, esi
	mov	QWORD PTR $T6[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T6[rbp-256], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1049 :     childValues_.push_back(value);

	lea	rdx, QWORD PTR $T6[rbp-256]

; 972  : 
; 973  : void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
; 974  :   unsigned size = value.size();
; 975  :   if (size == 0)
; 976  :     pushValue("[]");
; 977  :   else {
; 978  :     bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
; 979  :     if (isMultiLine) {
; 980  :       writeWithIndent("[");
; 981  :       indent();
; 982  :       bool hasChildValue = !childValues_.empty();
; 983  :       unsigned index = 0;
; 984  :       for (;;) {
; 985  :         Value const& childValue = value[index];
; 986  :         writeCommentBeforeValue(childValue);
; 987  :         if (hasChildValue)
; 988  :           writeWithIndent(childValues_[index]);
; 989  :         else {
; 990  :           if (!indented_) writeIndent();
; 991  :           indented_ = true;
; 992  :           writeValue(childValue);
; 993  :           indented_ = false;
; 994  :         }
; 995  :         if (++index == size) {
; 996  :           writeCommentAfterValueOnSameLine(childValue);
; 997  :           break;
; 998  :         }
; 999  :         *sout_ << ",";
; 1000 :         writeCommentAfterValueOnSameLine(childValue);
; 1001 :       }
; 1002 :       unindent();
; 1003 :       writeWithIndent("]");
; 1004 :     } else // output on a single line
; 1005 :     {
; 1006 :       assert(childValues_.size() == size);
; 1007 :       *sout_ << "[";
; 1008 :       if (!indentation_.empty()) *sout_ << " ";
; 1009 :       for (unsigned index = 0; index < size; ++index) {
; 1010 :         if (index > 0)
; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");
; 1012 :         *sout_ << childValues_[index];
; 1013 :       }
; 1014 :       if (!indentation_.empty()) *sout_ << " ";
; 1015 :       *sout_ << "]";
; 1016 :     }
; 1017 :   }
; 1018 : }
; 1019 : 
; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
; 1021 :   ArrayIndex const size = value.size();
; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;
; 1023 :   childValues_.clear();
; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 1025 :     Value const& childValue = value[index];
; 1026 :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 1027 :                         childValue.size() > 0);
; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length
; 1030 :   {
; 1031 :     childValues_.reserve(size);
; 1032 :     addChildValues_ = true;
; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {
; 1035 :       if (hasCommentForValue(value[index])) {
; 1036 :         isMultiLine = true;
; 1037 :       }
; 1038 :       writeValue(value[index]);
; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 1040 :     }
; 1041 :     addChildValues_ = false;
; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }
; 1046 : 
; 1047 : void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
; 1048 :   if (addChildValues_)

	test	BYTE PTR [rdi+216], 1
	je	SHORT $LN238@writeValue

; 1049 :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+16]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 1050 :   else

	jmp	SHORT $LN237@writeValue
$LN238@writeValue:

; 1051 :     *sout_ << value;

	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN237@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T6[rbp-232], 16
	jb	$LN639@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T6[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 936  :     break;

	jmp	$LN713@writeValue
$LN8@writeValue:

; 937  :   }
; 938  :   case booleanValue:
; 939  :     pushValue(valueToString(value.asBool()));

	mov	rcx, r8
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	movzx	edx, al
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	npad	1

; 1049 :     childValues_.push_back(value);

	mov	rdx, rax

; 972  : 
; 973  : void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
; 974  :   unsigned size = value.size();
; 975  :   if (size == 0)
; 976  :     pushValue("[]");
; 977  :   else {
; 978  :     bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
; 979  :     if (isMultiLine) {
; 980  :       writeWithIndent("[");
; 981  :       indent();
; 982  :       bool hasChildValue = !childValues_.empty();
; 983  :       unsigned index = 0;
; 984  :       for (;;) {
; 985  :         Value const& childValue = value[index];
; 986  :         writeCommentBeforeValue(childValue);
; 987  :         if (hasChildValue)
; 988  :           writeWithIndent(childValues_[index]);
; 989  :         else {
; 990  :           if (!indented_) writeIndent();
; 991  :           indented_ = true;
; 992  :           writeValue(childValue);
; 993  :           indented_ = false;
; 994  :         }
; 995  :         if (++index == size) {
; 996  :           writeCommentAfterValueOnSameLine(childValue);
; 997  :           break;
; 998  :         }
; 999  :         *sout_ << ",";
; 1000 :         writeCommentAfterValueOnSameLine(childValue);
; 1001 :       }
; 1002 :       unindent();
; 1003 :       writeWithIndent("]");
; 1004 :     } else // output on a single line
; 1005 :     {
; 1006 :       assert(childValues_.size() == size);
; 1007 :       *sout_ << "[";
; 1008 :       if (!indentation_.empty()) *sout_ << " ";
; 1009 :       for (unsigned index = 0; index < size; ++index) {
; 1010 :         if (index > 0)
; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");
; 1012 :         *sout_ << childValues_[index];
; 1013 :       }
; 1014 :       if (!indentation_.empty()) *sout_ << " ";
; 1015 :       *sout_ << "]";
; 1016 :     }
; 1017 :   }
; 1018 : }
; 1019 : 
; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
; 1021 :   ArrayIndex const size = value.size();
; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;
; 1023 :   childValues_.clear();
; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 1025 :     Value const& childValue = value[index];
; 1026 :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 1027 :                         childValue.size() > 0);
; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length
; 1030 :   {
; 1031 :     childValues_.reserve(size);
; 1032 :     addChildValues_ = true;
; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {
; 1035 :       if (hasCommentForValue(value[index])) {
; 1036 :         isMultiLine = true;
; 1037 :       }
; 1038 :       writeValue(value[index]);
; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 1040 :     }
; 1041 :     addChildValues_ = false;
; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }
; 1046 : 
; 1047 : void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
; 1048 :   if (addChildValues_)

	test	BYTE PTR [rdi+216], 1
	je	SHORT $LN274@writeValue

; 1049 :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+16]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 1050 :   else

	jmp	SHORT $LN273@writeValue
$LN274@writeValue:

; 1051 :     *sout_ << value;

	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN273@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T12[rbp-232], 16
	jb	$LN639@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T12[rbp-256]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 940  :     break;

	jmp	$LN713@writeValue
$LN7@writeValue:

; 941  :   case arrayValue:
; 942  :     writeArrayValue(value);

	mov	rdx, r8
	mov	rcx, rdi
	call	?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeArrayValue

; 943  :     break;

	jmp	$LN639@writeValue
$LN6@writeValue:

; 944  :   case objectValue: {
; 945  :     Value::Members members(value.getMemberNames());

	lea	rdx, QWORD PTR members$1[rsp]
	mov	rcx, r8
	call	?getMemberNames@Value@Json@@QEBA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	rbx, QWORD PTR members$1[rsp]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	esi, esi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

	cmp	rbx, QWORD PTR members$1[rsp+8]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 946  :     if (members.empty())

	jne	SHORT $LN5@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+2]
	lea	rdx, OFFSET FLAT:??_C@_02MCILKGOH@?$HL?$HN?$AA@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1049 :     childValues_.push_back(value);

	lea	rdx, QWORD PTR $T3[rsp]

; 972  : 
; 973  : void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
; 974  :   unsigned size = value.size();
; 975  :   if (size == 0)
; 976  :     pushValue("[]");
; 977  :   else {
; 978  :     bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
; 979  :     if (isMultiLine) {
; 980  :       writeWithIndent("[");
; 981  :       indent();
; 982  :       bool hasChildValue = !childValues_.empty();
; 983  :       unsigned index = 0;
; 984  :       for (;;) {
; 985  :         Value const& childValue = value[index];
; 986  :         writeCommentBeforeValue(childValue);
; 987  :         if (hasChildValue)
; 988  :           writeWithIndent(childValues_[index]);
; 989  :         else {
; 990  :           if (!indented_) writeIndent();
; 991  :           indented_ = true;
; 992  :           writeValue(childValue);
; 993  :           indented_ = false;
; 994  :         }
; 995  :         if (++index == size) {
; 996  :           writeCommentAfterValueOnSameLine(childValue);
; 997  :           break;
; 998  :         }
; 999  :         *sout_ << ",";
; 1000 :         writeCommentAfterValueOnSameLine(childValue);
; 1001 :       }
; 1002 :       unindent();
; 1003 :       writeWithIndent("]");
; 1004 :     } else // output on a single line
; 1005 :     {
; 1006 :       assert(childValues_.size() == size);
; 1007 :       *sout_ << "[";
; 1008 :       if (!indentation_.empty()) *sout_ << " ";
; 1009 :       for (unsigned index = 0; index < size; ++index) {
; 1010 :         if (index > 0)
; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");
; 1012 :         *sout_ << childValues_[index];
; 1013 :       }
; 1014 :       if (!indentation_.empty()) *sout_ << " ";
; 1015 :       *sout_ << "]";
; 1016 :     }
; 1017 :   }
; 1018 : }
; 1019 : 
; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
; 1021 :   ArrayIndex const size = value.size();
; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;
; 1023 :   childValues_.clear();
; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 1025 :     Value const& childValue = value[index];
; 1026 :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 1027 :                         childValue.size() > 0);
; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length
; 1030 :   {
; 1031 :     childValues_.reserve(size);
; 1032 :     addChildValues_ = true;
; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {
; 1035 :       if (hasCommentForValue(value[index])) {
; 1036 :         isMultiLine = true;
; 1037 :       }
; 1038 :       writeValue(value[index]);
; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 1040 :     }
; 1041 :     addChildValues_ = false;
; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }
; 1046 : 
; 1047 : void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
; 1048 :   if (addChildValues_)

	test	BYTE PTR [rdi+216], 1
	je	SHORT $LN356@writeValue

; 1049 :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rdi+16]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 1050 :   else

	jmp	SHORT $LN355@writeValue
$LN356@writeValue:

; 1051 :     *sout_ << value;

	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN355@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T3[rsp+24], 16
	jb	SHORT $LN379@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN379@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 948  :     else {

	jmp	$LN635@writeValue
$LN5@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-256], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01HCONENDN@?$HL?$AA@
	lea	rcx, QWORD PTR $T5[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1067 :   if (!indented_) writeIndent();

	test	BYTE PTR [rdi+216], 2
	jne	SHORT $LN438@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rdi+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1060 :   if (!indentation_.empty()) {

	je	SHORT $LN438@writeValue

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	mov	dl, 10
	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, QWORD PTR [rdi+40]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, QWORD PTR members$1[rsp]
$LN438@writeValue:

; 1068 :   *sout_ << value;

	lea	rdx, QWORD PTR $T5[rbp-256]
	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 1069 :   indented_ = false;

	and	BYTE PTR [rdi+216], 253			; 000000fdH
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T5[rbp-232], 16
	jb	SHORT $LN463@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T5[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN463@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-256], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1072 : void BuiltStyledStreamWriter::indent() { indentString_ += indentation_; }

	lea	rcx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR [rdi+80]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	10
$LL3@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 954  :         Value const& childValue = value[name];

	mov	rdx, rbx
	mov	rcx, QWORD PTR value$GSCopy$1$[rsp]
	call	??AValue@Json@@QEBAAEBV01@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	QWORD PTR childValue$1$[rsp], rax

; 955  :         writeCommentBeforeValue(childValue);

	mov	rdx, rax
	mov	rcx, rdi
	call	?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeCommentBeforeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN501@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rdx, QWORD PTR [rbx]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	jmp	SHORT $LN502@writeValue
$LN501@writeValue:
	mov	rdx, rbx
$LN502@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 956  :         writeWithIndent(valueToQuotedStringN(name.data(), static_cast<unsigned>(name.length())));

	mov	r8d, DWORD PTR [rbx+16]
	lea	rcx, QWORD PTR $T7[rbp-256]
	call	?valueToQuotedStringN@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDI@Z ; Json::valueToQuotedStringN
	npad	1
	mov	rdx, rax
	mov	rcx, rdi
	call	?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::BuiltStyledStreamWriter::writeWithIndent
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T7[rbp-232], 16
	jb	SHORT $LN525@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T7[rbp-256]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN525@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T7[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T7[rbp-256], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 957  :         *sout_ << colonSymbol_;

	lea	rdx, QWORD PTR [rdi+120]
	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 958  :         writeValue(childValue);

	mov	rdx, QWORD PTR childValue$1$[rsp]
	mov	rcx, rdi
	call	?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rbx, 32					; 00000020H

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, QWORD PTR members$1[rsp+8]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 959  :         if (++it == members.end()) {

	je	SHORT $LN704@writeValue

; 961  :           break;
; 962  :         }
; 963  :         *sout_ << ",";

	lea	rdx, OFFSET FLAT:??_C@_01IHBHIGKO@?0?$AA@
	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 964  :         writeCommentAfterValueOnSameLine(childValue);

	mov	rdx, QWORD PTR childValue$1$[rsp]
	mov	rcx, rdi
	call	?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine

; 965  :       }

	jmp	$LL3@writeValue
$LN704@writeValue:

; 960  :           writeCommentAfterValueOnSameLine(childValue);

	mov	rdx, QWORD PTR childValue$1$[rsp]
	mov	rcx, rdi
	call	?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine

; 966  :       unindent();

	mov	rcx, rdi
	call	?unindent@BuiltStyledStreamWriter@Json@@AEAAXXZ ; Json::BuiltStyledStreamWriter::unindent
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
	lea	rcx, QWORD PTR $T4[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1067 :   if (!indented_) writeIndent();

	test	BYTE PTR [rdi+216], 2
	jne	SHORT $LN600@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rdi+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1060 :   if (!indentation_.empty()) {

	je	SHORT $LN600@writeValue

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	mov	dl, 10
	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, QWORD PTR [rdi+40]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN600@writeValue:

; 1068 :   *sout_ << value;

	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 1069 :   indented_ = false;

	and	BYTE PTR [rdi+216], 253			; 000000fdH
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rbp-232], 16
	jb	SHORT $LN625@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN625@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-240], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rsp], 0
$LN635@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rax, QWORD PTR members$1[rsp]
	test	rax, rax
	je	SHORT $LN639@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	rbx, rax

; 81   : 	for (; _First != _Last; ++_First)

	mov	rdi, QWORD PTR members$1[rsp+8]
	cmp	rax, rdi
	je	SHORT $LN650@writeValue
$LL652@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN684@writeValue
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN684@writeValue:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 81   : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL652@writeValue
	mov	rax, QWORD PTR members$1[rsp]
$LN650@writeValue:

; 573  : 		::operator delete(_Ptr);

	mov	rcx, rax
$LN713@writeValue:
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN639@writeValue:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 971  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+464]
	add	rsp, 416				; 000001a0H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
	npad	2
$LN712@writeValue:
	DD	$LN15@writeValue
	DD	$LN14@writeValue
	DD	$LN13@writeValue
	DD	$LN12@writeValue
	DD	$LN11@writeValue
	DD	$LN8@writeValue
	DD	$LN7@writeValue
	DD	$LN6@writeValue
?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ENDP ; Json::BuiltStyledStreamWriter::writeValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?dtor$0@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$0
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?dtor$1@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$1
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?dtor$2@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$2
	lea	rcx, QWORD PTR $T9[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?dtor$3@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$3
	lea	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?dtor$4@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$4
	lea	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?dtor$5@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$5
	lea	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?dtor$6@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$6
	lea	rcx, QWORD PTR members$1[rdx]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$6@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?dtor$7@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$7
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?dtor$8@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$8
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?dtor$9@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$9
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
childValue$1$ = 40
members$1 = 48
value$GSCopy$1$ = 72
$T2 = 80
$T3 = 88
$T4 = 120
$T5 = 152
$T6 = 184
$T7 = 216
$T8 = 248
$T9 = 280
$T10 = 312
$T11 = 344
$T12 = 376
__$ArrayPad$ = 408
this$ = 448
value$ = 456
?dtor$10@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$10
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0??writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeValue'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
_TEXT	SEGMENT
hasChildValue$1$ = 32
$T1 = 40
$T2 = 48
$T3 = 48
$T4 = 48
__$ArrayPad$ = 80
this$ = 160
value$ = 168
?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z PROC ; Json::BuiltStyledStreamWriter::writeArrayValue, COMDAT

; 973  : void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {

$LN349:
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+176], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r13, rdx
	mov	rbx, rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 913  :   switch (type_) {

	movsx	edx, BYTE PTR [rdx+8]
	test	edx, edx
	js	$LN344@writeArray
	mov	rcx, r13
	call	?size@Value@Json@@QEBAIXZ		; Json::Value::size
	mov	r12d, eax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 975  :   if (size == 0)

	test	eax, eax
	je	$LN344@writeArray

; 976  :     pushValue("[]");
; 977  :   else {
; 978  :     bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);

	cmp	DWORD PTR [rbx+112], 2
	je	$LN19@writeArray
	mov	rdx, r13
	mov	rcx, rbx
	call	?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::isMultineArray
	test	al, al
	jne	$LN19@writeArray

; 1005 :     {
; 1006 :       assert(childValues_.size() == size);
; 1007 :       *sout_ << "[";

	lea	rdx, OFFSET FLAT:??_C@_01OHGJGJJP@?$FL?$AA@
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1008 :       if (!indentation_.empty()) *sout_ << " ";

	je	SHORT $LN6@writeArray
	lea	rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
$LN6@writeArray:

; 1009 :       for (unsigned index = 0; index < size; ++index) {

	xor	esi, esi
	test	r12d, r12d
	je	SHORT $LN3@writeArray
	mov	edi, esi
	lea	rbp, OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
	npad	7
$LL5@writeArray:

; 1010 :         if (index > 0)

	test	esi, esi
	je	SHORT $LN2@writeArray

; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");

	lea	rdx, OFFSET FLAT:??_C@_01IHBHIGKO@?0?$AA@
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");

	cmovne	rdx, rbp
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
$LN2@writeArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

	mov	rdx, QWORD PTR [rbx+16]
	add	rdx, rdi
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1012 :         *sout_ << childValues_[index];

	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 1009 :       for (unsigned index = 0; index < size; ++index) {

	inc	esi
	add	rdi, 32					; 00000020H
	cmp	esi, r12d
	jb	SHORT $LL5@writeArray
$LN3@writeArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1014 :       if (!indentation_.empty()) *sout_ << " ";

	je	SHORT $LN1@writeArray
	lea	rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
$LN1@writeArray:

; 1015 :       *sout_ << "]";

	lea	rdx, OFFSET FLAT:??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	jmp	$LN7@writeArray
$LN19@writeArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 15

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	esi, esi
	mov	QWORD PTR $T3[rsp+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+1]
	lea	rdx, OFFSET FLAT:??_C@_01OHGJGJJP@?$FL?$AA@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1067 :   if (!indented_) writeIndent();

	test	BYTE PTR [rbx+216], 2
	jne	SHORT $LN162@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+96], rsi
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1060 :   if (!indentation_.empty()) {

	je	SHORT $LN162@writeArray

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	lea	rdi, QWORD PTR [rbx+40]
	mov	dl, 10
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	mov	rdx, rdi
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN162@writeArray:

; 1068 :   *sout_ << value;

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 1069 :   indented_ = false;

	and	BYTE PTR [rbx+216], 253			; 000000fdH
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T3[rsp+24], 16
	jb	SHORT $LN187@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN187@writeArray:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1072 : void BuiltStyledStreamWriter::indent() { indentString_ += indentation_; }

	lea	rdx, QWORD PTR [rbx+80]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
	lea	rcx, QWORD PTR [rbx+40]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	rax, QWORD PTR [rbx+24]
	cmp	QWORD PTR [rbx+16], rax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 982  :       bool hasChildValue = !childValues_.empty();

	setne	dil
	mov	BYTE PTR hasChildValue$1$[rsp], dil

; 983  :       unsigned index = 0;

	mov	ebp, esi
	npad	9
$LL13@writeArray:

; 984  :       for (;;) {
; 985  :         Value const& childValue = value[index];

	mov	edx, ebp
	mov	rcx, r13
	call	??AValue@Json@@QEBAAEBV01@I@Z		; Json::Value::operator[]
	mov	r15, rax

; 986  :         writeCommentBeforeValue(childValue);

	mov	rdx, rax
	mov	rcx, rbx
	call	?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeCommentBeforeValue

; 987  :         if (hasChildValue)

	test	dil, dil
	je	SHORT $LN11@writeArray

; 988  :           writeWithIndent(childValues_[index]);

	mov	edi, ebp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

	shl	rdi, 5
	add	rdi, QWORD PTR [rbx+16]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1067 :   if (!indented_) writeIndent();

	test	BYTE PTR [rbx+216], 2
	jne	SHORT $LN212@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1060 :   if (!indentation_.empty()) {

	je	SHORT $LN212@writeArray

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	mov	dl, 10
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, QWORD PTR [rbx+40]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN212@writeArray:

; 1068 :   *sout_ << value;

	mov	rdx, rdi
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 989  :         else {

	movzx	edi, BYTE PTR hasChildValue$1$[rsp]
	jmp	SHORT $LN346@writeArray
$LN11@writeArray:

; 990  :           if (!indented_) writeIndent();

	test	BYTE PTR [rbx+216], 2
	jne	SHORT $LN217@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1060 :   if (!indentation_.empty()) {

	je	SHORT $LN217@writeArray

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	mov	dl, 10
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, QWORD PTR [rbx+40]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN217@writeArray:

; 991  :           indented_ = true;

	or	BYTE PTR [rbx+216], 2

; 992  :           writeValue(childValue);

	mov	rdx, r15
	mov	rcx, rbx
	call	?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeValue
$LN346@writeArray:

; 993  :           indented_ = false;

	and	BYTE PTR [rbx+216], 253			; 000000fdH

; 994  :         }
; 995  :         if (++index == size) {

	inc	ebp
	cmp	ebp, r12d
	je	SHORT $LN338@writeArray

; 997  :           break;
; 998  :         }
; 999  :         *sout_ << ",";

	lea	rdx, OFFSET FLAT:??_C@_01IHBHIGKO@?0?$AA@
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1000 :         writeCommentAfterValueOnSameLine(childValue);

	mov	rdx, r15
	mov	rcx, rbx
	call	?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine

; 1001 :       }

	jmp	$LL13@writeArray
$LN338@writeArray:

; 996  :           writeCommentAfterValueOnSameLine(childValue);

	mov	rdx, r15
	mov	rcx, rbx
	call	?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

	mov	rdx, QWORD PTR [rbx+56]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1076 :   indentString_.resize(indentString_.size() - indentation_.size());

	sub	rdx, QWORD PTR [rbx+96]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1770 : 		if (_Newsize <= this->_Mysize)

	mov	rax, QWORD PTR [rbx+56]
	cmp	rdx, rax
	ja	SHORT $LN231@writeArray

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+56], rdx

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rbx+64], 16
	jb	SHORT $LN238@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR [rbx+40]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN239@writeArray
$LN238@writeArray:
	lea	rax, QWORD PTR [rbx+40]
$LN239@writeArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax+rdx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1772 : 		else

	jmp	SHORT $LN230@writeArray
$LN231@writeArray:

; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

	sub	rdx, rax
	xor	r8d, r8d
	lea	rcx, QWORD PTR [rbx+40]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN230@writeArray:

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T2[rsp+24], 15

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T2[rsp+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T2[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01LBDDMOBJ@?$FN?$AA@
	lea	rcx, QWORD PTR $T2[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1067 :   if (!indented_) writeIndent();

	test	BYTE PTR [rbx+216], 2
	jne	SHORT $LN291@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rbx+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1060 :   if (!indentation_.empty()) {

	je	SHORT $LN291@writeArray

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	mov	dl, 10
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, QWORD PTR [rbx+40]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN291@writeArray:

; 1068 :   *sout_ << value;

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 1069 :   indented_ = false;

	and	BYTE PTR [rbx+216], 253			; 000000fdH

; 1002 :       unindent();
; 1003 :       writeWithIndent("]");
; 1004 :     } else // output on a single line

	jmp	SHORT $LN348@writeArray
$LN344@writeArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rsp+24], 15

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	esi, esi
	mov	QWORD PTR $T4[rsp+16], rsi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rsp], sil
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+2]
	lea	rdx, OFFSET FLAT:??_C@_02GPECMEKF@?$FL?$FN?$AA@
	lea	rcx, QWORD PTR $T4[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1049 :     childValues_.push_back(value);

	lea	rdx, QWORD PTR $T4[rsp]

; 1019 : 
; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
; 1021 :   ArrayIndex const size = value.size();
; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;
; 1023 :   childValues_.clear();
; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 1025 :     Value const& childValue = value[index];
; 1026 :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 1027 :                         childValue.size() > 0);
; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length
; 1030 :   {
; 1031 :     childValues_.reserve(size);
; 1032 :     addChildValues_ = true;
; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {
; 1035 :       if (hasCommentForValue(value[index])) {
; 1036 :         isMultiLine = true;
; 1037 :       }
; 1038 :       writeValue(value[index]);
; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 1040 :     }
; 1041 :     addChildValues_ = false;
; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }
; 1046 : 
; 1047 : void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
; 1048 :   if (addChildValues_)

	test	BYTE PTR [rbx+216], 1
	je	SHORT $LN80@writeArray

; 1049 :     childValues_.push_back(value);

	lea	rcx, QWORD PTR [rbx+16]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 1050 :   else

	jmp	SHORT $LN79@writeArray
$LN80@writeArray:

; 1051 :     *sout_ << value;

	mov	rcx, QWORD PTR [rbx+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN79@writeArray:
$LN348@writeArray:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T4[rsp+24], 16
	jb	SHORT $LN7@writeArray
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN7@writeArray:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1018 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+176]
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ENDP ; Json::BuiltStyledStreamWriter::writeArrayValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
hasChildValue$1$ = 32
$T1 = 40
$T2 = 48
$T3 = 48
$T4 = 48
__$ArrayPad$ = 80
this$ = 160
value$ = 168
?dtor$0@?0??writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeArrayValue'::`1'::dtor$0
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeArrayValue'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
hasChildValue$1$ = 32
$T1 = 40
$T2 = 48
$T3 = 48
$T4 = 48
__$ArrayPad$ = 80
this$ = 160
value$ = 168
?dtor$1@?0??writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeArrayValue'::`1'::dtor$1
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeArrayValue'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
hasChildValue$1$ = 32
$T1 = 40
$T2 = 48
$T3 = 48
$T4 = 48
__$ArrayPad$ = 80
this$ = 160
value$ = 168
?dtor$2@?0??writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeArrayValue'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??writeArrayValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeArrayValue'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z
_TEXT	SEGMENT
this$ = 80
value$ = 88
?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z PROC ; Json::BuiltStyledStreamWriter::isMultineArray, COMDAT

; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {

$LN99:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r15, rdx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 913  :   switch (type_) {

	movsx	edx, BYTE PTR [rdx+8]
	xor	ebp, ebp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {

	mov	r14, rcx
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 913  :   switch (type_) {

	test	edx, edx
	js	SHORT $LN20@isMultineA
	mov	rcx, r15
	call	?size@Value@Json@@QEBAIXZ		; Json::Value::size
	mov	esi, eax
	jmp	SHORT $LN22@isMultineA
$LN20@isMultineA:

; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;

	mov	esi, ebp
$LN22@isMultineA:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;

	lea	eax, DWORD PTR [rsi+rsi*2]

; 1023 :   childValues_.clear();

	lea	rcx, QWORD PTR [r14+16]
	cmp	eax, DWORD PTR [r14+72]
	setae	bl
	call	?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear

; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {

	mov	edi, ebp
	test	esi, esi
	je	SHORT $LN6@isMultineA
	npad	3
$LL8@isMultineA:
	test	bl, bl
	jne	$LN15@isMultineA

; 1025 :     Value const& childValue = value[index];

	mov	edx, edi
	mov	rcx, r15
	call	??AValue@Json@@QEBAAEBV01@I@Z		; Json::Value::operator[]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1388 : bool Value::isArray() const { return type_ == arrayValue; }

	movzx	edx, BYTE PTR [rax+8]
	lea	ecx, DWORD PTR [rdx-6]
	cmp	cl, 1
	ja	SHORT $LN12@isMultineA

; 913  :   switch (type_) {

	movsx	edx, dl
	test	edx, edx
	js	SHORT $LN12@isMultineA
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1027 :                         childValue.size() > 0);

	mov	rcx, rax
	call	?size@Value@Json@@QEBAIXZ		; Json::Value::size
	test	eax, eax
	je	SHORT $LN12@isMultineA
	mov	bl, 1
	jmp	SHORT $LN13@isMultineA
$LN12@isMultineA:
	xor	bl, bl
$LN13@isMultineA:

; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {

	inc	edi
	cmp	edi, esi
	jb	SHORT $LL8@isMultineA
$LN6@isMultineA:

; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length

	test	bl, bl
	jne	$LN15@isMultineA
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [r14+32]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1031 :     childValues_.reserve(size);

	mov	edx, esi
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	rax, QWORD PTR [r14+16]
	sar	rax, 5

; 1000 : 		if (capacity() < _Count)

	cmp	rax, rdx
	jae	SHORT $LN43@isMultineA

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	rdx, rax
	jbe	SHORT $LN42@isMultineA

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN42@isMultineA:

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	lea	rcx, QWORD PTR [r14+16]
	call	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN43@isMultineA:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1032 :     addChildValues_ = true;

	or	BYTE PTR [r14+216], 1

; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'

	lea	edi, DWORD PTR [rsi*2+2]

; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {

	test	esi, esi
	je	SHORT $LN2@isMultineA
	mov	QWORD PTR [rsp+80], r12
	mov	r12, rbp
	npad	7
$LL4@isMultineA:

; 1035 :       if (hasCommentForValue(value[index])) {

	mov	edx, ebp
	mov	rcx, r15
	call	??AValue@Json@@QEBAAEBV01@I@Z		; Json::Value::operator[]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1411 :   return comments_ != 0 && comments_[placement].comment_ != 0;

	mov	rcx, QWORD PTR [rax+16]
	test	rcx, rcx
	je	SHORT $LN1@isMultineA
	cmp	QWORD PTR [rcx], 0
	jne	SHORT $LN64@isMultineA
	test	rcx, rcx
	je	SHORT $LN1@isMultineA
	cmp	QWORD PTR [rcx+8], 0
	jne	SHORT $LN64@isMultineA
	test	rcx, rcx
	je	SHORT $LN1@isMultineA
	cmp	QWORD PTR [rcx+16], 0
	je	SHORT $LN1@isMultineA
$LN64@isMultineA:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1036 :         isMultiLine = true;

	mov	bl, 1
$LN1@isMultineA:

; 1037 :       }
; 1038 :       writeValue(value[index]);

	mov	edx, ebp
	mov	rcx, r15
	call	??AValue@Json@@QEBAAEBV01@I@Z		; Json::Value::operator[]
	mov	rcx, r14
	mov	rdx, rax
	call	?writeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ; Json::BuiltStyledStreamWriter::writeValue

; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());

	mov	rax, QWORD PTR [r14+16]
	inc	ebp
	add	edi, DWORD PTR [r12+rax+16]
	add	r12, 32					; 00000020H
	cmp	ebp, esi
	jb	SHORT $LL4@isMultineA
	mov	r12, QWORD PTR [rsp+80]
$LN2@isMultineA:

; 1040 :     }
; 1041 :     addChildValues_ = false;

	and	BYTE PTR [r14+216], 254			; 000000feH

; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;

	test	bl, bl
	jne	SHORT $LN14@isMultineA
	cmp	edi, DWORD PTR [r14+72]
	jb	SHORT $LN15@isMultineA
$LN14@isMultineA:
	mov	bl, 1
$LN15@isMultineA:

; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }

	mov	rbp, QWORD PTR [rsp+96]
	movzx	eax, bl
	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	ret	0
$LN98@isMultineA:
?isMultineArray@BuiltStyledStreamWriter@Json@@AEAA_NAEBVValue@2@@Z ENDP ; Json::BuiltStyledStreamWriter::isMultineArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?pushValue@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 8
value$ = 16
?pushValue@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::BuiltStyledStreamWriter::pushValue, COMDAT

; 1048 :   if (addChildValues_)
; 1049 :     childValues_.push_back(value);

	add	rcx, 16
	jmp	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
?pushValue@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::BuiltStyledStreamWriter::pushValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ PROC	; Json::BuiltStyledStreamWriter::writeIndent, COMDAT

; 1054 : void BuiltStyledStreamWriter::writeIndent() {

$LN7:
	sub	rsp, 40					; 00000028H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rcx+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1060 :   if (!indentation_.empty()) {

	je	SHORT $LN1@writeInden

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	mov	QWORD PTR [rsp+32], rbx
	lea	rbx, QWORD PTR [rcx+40]
	mov	rcx, QWORD PTR [rcx+8]
	mov	dl, 10
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
	mov	rdx, rbx
	mov	rcx, rax
	mov	rbx, QWORD PTR [rsp+32]

; 1063 :   }
; 1064 : }

	add	rsp, 40					; 00000028H

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	jmp	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, QWORD PTR [rsp+32]
$LN1@writeInden:

; 1063 :   }
; 1064 : }

	add	rsp, 40					; 00000028H
	ret	0
?writeIndent@BuiltStyledStreamWriter@Json@@AEAAXXZ ENDP	; Json::BuiltStyledStreamWriter::writeIndent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 48
value$ = 56
?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::BuiltStyledStreamWriter::writeWithIndent, COMDAT

; 1066 : void BuiltStyledStreamWriter::writeWithIndent(JSONCPP_STRING const& value) {

$LN10:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1067 :   if (!indented_) writeIndent();

	test	BYTE PTR [rcx+216], 2
	mov	rsi, rdx
	mov	rdi, rcx
	jne	SHORT $LN4@writeWithI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rcx+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1060 :   if (!indentation_.empty()) {

	je	SHORT $LN4@writeWithI

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	mov	rcx, QWORD PTR [rcx+8]
	mov	dl, 10
	mov	QWORD PTR [rsp+48], rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, QWORD PTR [rdi+40]
	mov	rcx, rax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, QWORD PTR [rsp+48]
$LN4@writeWithI:

; 1068 :   *sout_ << value;

	mov	rcx, QWORD PTR [rdi+8]
	mov	rdx, rsi
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 1069 :   indented_ = false;

	and	BYTE PTR [rdi+216], 253			; 000000fdH

; 1070 : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?writeWithIndent@BuiltStyledStreamWriter@Json@@AEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::BuiltStyledStreamWriter::writeWithIndent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?indent@BuiltStyledStreamWriter@Json@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?indent@BuiltStyledStreamWriter@Json@@AEAAXXZ PROC	; Json::BuiltStyledStreamWriter::indent, COMDAT

; 1072 : void BuiltStyledStreamWriter::indent() { indentString_ += indentation_; }

	lea	rdx, QWORD PTR [rcx+80]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	or	r9, -1
	xor	r8d, r8d
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1072 : void BuiltStyledStreamWriter::indent() { indentString_ += indentation_; }

	add	rcx, 40					; 00000028H
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?indent@BuiltStyledStreamWriter@Json@@AEAAXXZ ENDP	; Json::BuiltStyledStreamWriter::indent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?unindent@BuiltStyledStreamWriter@Json@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?unindent@BuiltStyledStreamWriter@Json@@AEAAXXZ PROC	; Json::BuiltStyledStreamWriter::unindent, COMDAT

; 1076 :   indentString_.resize(indentString_.size() - indentation_.size());

	mov	rdx, QWORD PTR [rcx+56]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1770 : 		if (_Newsize <= this->_Mysize)

	mov	rax, QWORD PTR [rcx+56]
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1076 :   indentString_.resize(indentString_.size() - indentation_.size());

	add	rcx, 40					; 00000028H
	sub	rdx, QWORD PTR [rcx+56]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1770 : 		if (_Newsize <= this->_Mysize)

	cmp	rdx, rax
	ja	SHORT $LN10@unindent

; 513  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rcx+24], 16

; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN18@unindent
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rcx, QWORD PTR [rcx]
$LN18@unindent:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx+rdx], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1077 : }

	ret	0
$LN10@unindent:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

	sub	rdx, rax
	xor	r8d, r8d
	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?unindent@BuiltStyledStreamWriter@Json@@AEAAXXZ ENDP	; Json::BuiltStyledStreamWriter::unindent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
_TEXT	SEGMENT
$T1 = 32
$S3$ = 40
__$ArrayPad$ = 72
this$ = 96
root$ = 104
?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z PROC ; Json::BuiltStyledStreamWriter::writeCommentBeforeValue, COMDAT

; 1079 : void BuiltStyledStreamWriter::writeCommentBeforeValue(Value const& root) {

$LN116:
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+120], rsi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rdx
	mov	rdi, rcx

; 1080 :   if (cs_ == CommentStyle::None) return;

	cmp	DWORD PTR [rcx+112], 0
	je	$LN99@writeComme
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1411 :   return comments_ != 0 && comments_[placement].comment_ != 0;

	mov	rax, QWORD PTR [rdx+16]
	test	rax, rax
	je	$LN99@writeComme
	cmp	QWORD PTR [rax], 0
	je	$LN99@writeComme
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1084 :   if (!indented_) writeIndent();

	test	BYTE PTR [rcx+216], 2
	jne	SHORT $LN14@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rcx+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1060 :   if (!indentation_.empty()) {

	je	SHORT $LN14@writeComme

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	mov	dl, 10
	mov	rcx, QWORD PTR [rcx+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, QWORD PTR [rdi+40]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN14@writeComme:

; 1085 :   const JSONCPP_STRING& comment = root.getComment(commentBefore);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $S3$[rsp]
	mov	rcx, rsi
	call	?getComment@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rbx, QWORD PTR $S3$[rsp]
	cmp	QWORD PTR $S3$[rsp+24], 16
	cmovae	rbx, QWORD PTR $S3$[rsp]
	npad	8
$LL3@writeComme:
	lea	rcx, QWORD PTR $S3$[rsp]
	cmp	QWORD PTR $S3$[rsp+24], 16
	cmovae	rcx, QWORD PTR $S3$[rsp]

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));

	mov	rax, QWORD PTR $S3$[rsp+16]
	add	rax, rcx

; 121  : 		return (*this);
; 122  : 		}
; 123  : 
; 124  : 	_Myiter operator++(int)
; 125  : 		{	// postincrement
; 126  : 		_Myiter _Tmp = *this;
; 127  : 		++*this;
; 128  : 		return (_Tmp);
; 129  : 		}
; 130  : 
; 131  : 	_Myiter& operator--()
; 132  : 		{	// predecrement
; 133  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 134  : 		if (this->_Getcont() == 0
; 135  : 			|| this->_Ptr == 0
; 136  : 			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())
; 137  : 			{	// report error
; 138  : 			_DEBUG_ERROR("string iterator not decrementable");
; 139  : 			_SCL_SECURE_OUT_OF_RANGE;
; 140  : 			}
; 141  : 
; 142  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 143  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 144  : 		_SCL_SECURE_VALIDATE_RANGE(
; 145  : 			((_Mystr *)this->_Getcont())->_Myptr() < this->_Ptr);
; 146  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 147  : 
; 148  : 		--this->_Ptr;
; 149  : 		return (*this);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter operator--(int)
; 153  : 		{	// postdecrement
; 154  : 		_Myiter _Tmp = *this;
; 155  : 		--*this;
; 156  : 		return (_Tmp);
; 157  : 		}
; 158  : 
; 159  : 	_Myiter& operator+=(difference_type _Off)
; 160  : 		{	// increment by integer
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 		if (this->_Getcont() == 0
; 163  : 			|| this->_Ptr == 0
; 164  : 			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()
; 165  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 166  : 				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)
; 167  : 			{	// report error
; 168  : 			_DEBUG_ERROR("string iterator + offset out of range");
; 169  : 			_SCL_SECURE_OUT_OF_RANGE;
; 170  : 			}
; 171  : 
; 172  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 173  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 174  : 		_SCL_SECURE_VALIDATE_RANGE(
; 175  : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr + _Off
; 176  : 				&& this->_Ptr + _Off <= ((_Mystr *)this->_Getcont())->_Myptr()
; 177  : 					+ ((_Mystr *)this->_Getcont())->_Mysize);
; 178  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 179  : 
; 180  : 		_Ptr += _Off;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myiter operator+(difference_type _Off) const
; 185  : 		{	// return this + integer
; 186  : 		_Myiter _Tmp = *this;
; 187  : 		return (_Tmp += _Off);
; 188  : 		}
; 189  : 
; 190  : 	_Myiter& operator-=(difference_type _Off)
; 191  : 		{	// decrement by integer
; 192  : 		return (*this += -_Off);
; 193  : 		}
; 194  : 
; 195  : 	_Myiter operator-(difference_type _Off) const
; 196  : 		{	// return this - integer
; 197  : 		_Myiter _Tmp = *this;
; 198  : 		return (_Tmp -= _Off);
; 199  : 		}
; 200  : 
; 201  : 	difference_type operator-(const _Myiter& _Right) const
; 202  : 		{	// return difference of iterators
; 203  : 		_Compat(_Right);
; 204  : 		return (this->_Ptr - _Right._Ptr);
; 205  : 		}
; 206  : 
; 207  : 	reference operator[](difference_type _Off) const
; 208  : 		{	// subscript
; 209  : 		return (*(*this + _Off));
; 210  : 		}
; 211  : 
; 212  : 	bool operator==(const _Myiter& _Right) const
; 213  : 		{	// test for iterator equality
; 214  : 		_Compat(_Right);
; 215  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, rax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1087 :   while (iter != comment.end()) {

	je	SHORT $LN2@writeComme

; 1088 :     *sout_ << *iter;

	movzx	edx, BYTE PTR [rbx]
	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 1090 :        (iter != comment.end() && *(iter + 1) == '/'))

	cmp	BYTE PTR [rbx], 10
	jne	SHORT $LN115@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rcx, QWORD PTR $S3$[rsp]
	cmp	QWORD PTR $S3$[rsp+24], 16
	cmovae	rcx, QWORD PTR $S3$[rsp]

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));

	add	rcx, QWORD PTR $S3$[rsp+16]

; 121  : 		return (*this);
; 122  : 		}
; 123  : 
; 124  : 	_Myiter operator++(int)
; 125  : 		{	// postincrement
; 126  : 		_Myiter _Tmp = *this;
; 127  : 		++*this;
; 128  : 		return (_Tmp);
; 129  : 		}
; 130  : 
; 131  : 	_Myiter& operator--()
; 132  : 		{	// predecrement
; 133  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 134  : 		if (this->_Getcont() == 0
; 135  : 			|| this->_Ptr == 0
; 136  : 			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())
; 137  : 			{	// report error
; 138  : 			_DEBUG_ERROR("string iterator not decrementable");
; 139  : 			_SCL_SECURE_OUT_OF_RANGE;
; 140  : 			}
; 141  : 
; 142  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 143  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 144  : 		_SCL_SECURE_VALIDATE_RANGE(
; 145  : 			((_Mystr *)this->_Getcont())->_Myptr() < this->_Ptr);
; 146  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 147  : 
; 148  : 		--this->_Ptr;
; 149  : 		return (*this);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter operator--(int)
; 153  : 		{	// postdecrement
; 154  : 		_Myiter _Tmp = *this;
; 155  : 		--*this;
; 156  : 		return (_Tmp);
; 157  : 		}
; 158  : 
; 159  : 	_Myiter& operator+=(difference_type _Off)
; 160  : 		{	// increment by integer
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 		if (this->_Getcont() == 0
; 163  : 			|| this->_Ptr == 0
; 164  : 			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()
; 165  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 166  : 				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)
; 167  : 			{	// report error
; 168  : 			_DEBUG_ERROR("string iterator + offset out of range");
; 169  : 			_SCL_SECURE_OUT_OF_RANGE;
; 170  : 			}
; 171  : 
; 172  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 173  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 174  : 		_SCL_SECURE_VALIDATE_RANGE(
; 175  : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr + _Off
; 176  : 				&& this->_Ptr + _Off <= ((_Mystr *)this->_Getcont())->_Myptr()
; 177  : 					+ ((_Mystr *)this->_Getcont())->_Mysize);
; 178  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 179  : 
; 180  : 		_Ptr += _Off;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myiter operator+(difference_type _Off) const
; 185  : 		{	// return this + integer
; 186  : 		_Myiter _Tmp = *this;
; 187  : 		return (_Tmp += _Off);
; 188  : 		}
; 189  : 
; 190  : 	_Myiter& operator-=(difference_type _Off)
; 191  : 		{	// decrement by integer
; 192  : 		return (*this += -_Off);
; 193  : 		}
; 194  : 
; 195  : 	_Myiter operator-(difference_type _Off) const
; 196  : 		{	// return this - integer
; 197  : 		_Myiter _Tmp = *this;
; 198  : 		return (_Tmp -= _Off);
; 199  : 		}
; 200  : 
; 201  : 	difference_type operator-(const _Myiter& _Right) const
; 202  : 		{	// return difference of iterators
; 203  : 		_Compat(_Right);
; 204  : 		return (this->_Ptr - _Right._Ptr);
; 205  : 		}
; 206  : 
; 207  : 	reference operator[](difference_type _Off) const
; 208  : 		{	// subscript
; 209  : 		return (*(*this + _Off));
; 210  : 		}
; 211  : 
; 212  : 	bool operator==(const _Myiter& _Right) const
; 213  : 		{	// test for iterator equality
; 214  : 		_Compat(_Right);
; 215  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, rcx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1090 :        (iter != comment.end() && *(iter + 1) == '/'))

	je	SHORT $LN115@writeComme
	cmp	BYTE PTR [rbx+1], 47			; 0000002fH
	jne	SHORT $LN115@writeComme

; 1091 :       // writeIndent();  // would write extra newline
; 1092 :       *sout_ << indentString_;

	lea	rdx, QWORD PTR [rdi+40]
	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN115@writeComme:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 120  : 		++this->_Ptr;

	inc	rbx
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1094 :   }

	jmp	SHORT $LL3@writeComme
$LN2@writeComme:

; 1095 :   indented_ = false;

	and	BYTE PTR [rdi+216], 253			; 000000fdH
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $S3$[rsp+24], 16
	jb	SHORT $LN99@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $S3$[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN99@writeComme:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1096 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ENDP ; Json::BuiltStyledStreamWriter::writeCommentBeforeValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$S3$ = 40
__$ArrayPad$ = 72
this$ = 96
root$ = 104
?dtor$0@?0??writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeCommentBeforeValue'::`1'::dtor$0
	lea	rcx, QWORD PTR $S3$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??writeCommentBeforeValue@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeCommentBeforeValue'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z
_TEXT	SEGMENT
$T1 = 40
$T2 = 72
$T3 = 72
__$ArrayPad$ = 104
this$ = 128
root$ = 136
?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z PROC ; Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine, COMDAT

; 1098 : void BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine(Value const& root) {

$LN120:
	mov	r11, rsp
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	QWORD PTR [r11-88], -2
	mov	QWORD PTR [r11+24], rbx
	mov	QWORD PTR [r11+32], rsi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rdx
	mov	rdi, rcx

; 1099 :   if (cs_ == CommentStyle::None) return;

	cmp	DWORD PTR [rcx+112], 0
	je	$LN106@writeComme
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1411 :   return comments_ != 0 && comments_[placement].comment_ != 0;

	mov	rax, QWORD PTR [rdx+16]
	test	rax, rax
	je	SHORT $LN65@writeComme
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN65@writeComme
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1101 :     *sout_ << " " + root.getComment(commentAfterOnSameLine);

	mov	r8d, 1
	lea	rdx, QWORD PTR [r11-48]
	mov	rcx, rsi
	call	?getComment@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	npad	1
	mov	r8, rax
	lea	rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T1[rsp+24], 16
	jb	SHORT $LN33@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN33@writeComme:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T1[rsp+24], 15

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T1[rsp+16], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T1[rsp], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T3[rsp+24], 16
	jb	SHORT $LN65@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN65@writeComme:
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1411 :   return comments_ != 0 && comments_[placement].comment_ != 0;

	mov	rax, QWORD PTR [rsi+16]
	test	rax, rax
	je	SHORT $LN106@writeComme
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN106@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR [rdi+96], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1060 :   if (!indentation_.empty()) {

	je	SHORT $LN81@writeComme

; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;

	mov	dl, 10
	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, QWORD PTR [rdi+40]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN81@writeComme:

; 1102 : 
; 1103 :   if (root.hasComment(commentAfter)) {
; 1104 :     writeIndent();
; 1105 :     *sout_ << root.getComment(commentAfter);

	mov	r8d, 2
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rsi
	call	?getComment@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	npad	1
	mov	rdx, rax
	mov	rcx, QWORD PTR [rdi+8]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T2[rsp+24], 16
	jb	SHORT $LN106@writeComme
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN106@writeComme:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1107 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
?writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z ENDP ; Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 72
$T3 = 72
__$ArrayPad$ = 104
this$ = 128
root$ = 136
?dtor$0@?0??writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$0
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 72
$T3 = 72
__$ArrayPad$ = 104
this$ = 128
root$ = 136
?dtor$1@?0??writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$1
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 72
$T3 = 72
__$ArrayPad$ = 104
this$ = 128
root$ = 136
?dtor$2@?0??writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA PROC ; `Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??writeCommentAfterValueOnSameLine@BuiltStyledStreamWriter@Json@@AEAAXAEBVValue@2@@Z@4HA ENDP ; `Json::BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?hasCommentForValue@BuiltStyledStreamWriter@Json@@CA_NAEBVValue@2@@Z
_TEXT	SEGMENT
value$ = 8
?hasCommentForValue@BuiltStyledStreamWriter@Json@@CA_NAEBVValue@2@@Z PROC ; Json::BuiltStyledStreamWriter::hasCommentForValue, COMDAT
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1411 :   return comments_ != 0 && comments_[placement].comment_ != 0;

	mov	rax, QWORD PTR [rcx+16]
	test	rax, rax
	je	SHORT $LN15@hasComment
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN3@hasComment
	test	rax, rax
	je	SHORT $LN15@hasComment
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN3@hasComment
	test	rax, rax
	je	SHORT $LN15@hasComment
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN15@hasComment
$LN3@hasComment:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1113 :          value.hasComment(commentAfter);

	mov	al, 1

; 1114 : }

	ret	0
$LN15@hasComment:

; 1113 :          value.hasComment(commentAfter);

	xor	al, al

; 1114 : }

	ret	0
?hasCommentForValue@BuiltStyledStreamWriter@Json@@CA_NAEBVValue@2@@Z ENDP ; Json::BuiltStyledStreamWriter::hasCommentForValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??0StreamWriter@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0StreamWriter@Json@@QEAA@XZ PROC			; Json::StreamWriter::StreamWriter, COMDAT

; 1121 : {

	lea	rax, OFFSET FLAT:??_7StreamWriter@Json@@6B@
	mov	QWORD PTR [rcx+8], 0
	mov	QWORD PTR [rcx], rax

; 1122 : }

	mov	rax, rcx
	ret	0
??0StreamWriter@Json@@QEAA@XZ ENDP			; Json::StreamWriter::StreamWriter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??_GStreamWriter@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GStreamWriter@Json@@UEAAPEAXI@Z PROC			; Json::StreamWriter::`scalar deleting destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1124 : {

	lea	rax, OFFSET FLAT:??_7StreamWriter@Json@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN6@scalar
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN6@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GStreamWriter@Json@@UEAAPEAXI@Z ENDP			; Json::StreamWriter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??1StreamWriter@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1StreamWriter@Json@@UEAA@XZ PROC			; Json::StreamWriter::~StreamWriter, COMDAT

; 1124 : {

	lea	rax, OFFSET FLAT:??_7StreamWriter@Json@@6B@
	mov	QWORD PTR [rcx], rax

; 1125 : }

	ret	0
??1StreamWriter@Json@@UEAA@XZ ENDP			; Json::StreamWriter::~StreamWriter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??1Factory@StreamWriter@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Factory@StreamWriter@Json@@UEAA@XZ PROC		; Json::StreamWriter::Factory::~Factory, COMDAT

; 1127 : {}

	lea	rax, OFFSET FLAT:??_7Factory@StreamWriter@Json@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1Factory@StreamWriter@Json@@UEAA@XZ ENDP		; Json::StreamWriter::Factory::~Factory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??_GFactory@StreamWriter@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GFactory@StreamWriter@Json@@UEAAPEAXI@Z PROC		; Json::StreamWriter::Factory::`scalar deleting destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1127 : {}

	lea	rax, OFFSET FLAT:??_7Factory@StreamWriter@Json@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN6@scalar
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN6@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GFactory@StreamWriter@Json@@UEAAPEAXI@Z ENDP		; Json::StreamWriter::Factory::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z PROC		; Json::StreamWriterBuilder::`scalar deleting destructor', COMDAT
$LN11:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	ebx, edx
	mov	rdi, rcx

; 1133 : {}

	lea	rax, OFFSET FLAT:??_7StreamWriterBuilder@Json@@6B@
	mov	QWORD PTR [rcx], rax
	add	rcx, 8
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	npad	1

; 1127 : {}

	lea	rax, OFFSET FLAT:??_7Factory@StreamWriter@Json@@6B@
	mov	QWORD PTR [rdi], rax
	test	bl, 1
	je	SHORT $LN10@scalar
	mov	rcx, rdi
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN10@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??_GStreamWriterBuilder@Json@@UEAAPEAXI@Z ENDP		; Json::StreamWriterBuilder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
?dtor$0@?0???_GStreamWriterBuilder@Json@@UEAAPEAXI@Z@4HA PROC ; `Json::StreamWriterBuilder::`scalar deleting destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1Factory@StreamWriter@Json@@UEAA@XZ	; Json::StreamWriter::Factory::~Factory
?dtor$0@?0???_GStreamWriterBuilder@Json@@UEAAPEAXI@Z@4HA ENDP ; `Json::StreamWriterBuilder::`scalar deleting destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ??1StreamWriterBuilder@Json@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1StreamWriterBuilder@Json@@UEAA@XZ PROC		; Json::StreamWriterBuilder::~StreamWriterBuilder, COMDAT

; 1133 : {}

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
	lea	rax, OFFSET FLAT:??_7StreamWriterBuilder@Json@@6B@
	mov	QWORD PTR [rcx], rax
	add	rcx, 8
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	npad	1

; 1127 : {}

	lea	rax, OFFSET FLAT:??_7Factory@StreamWriter@Json@@6B@
	mov	QWORD PTR [rbx], rax

; 1133 : {}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??1StreamWriterBuilder@Json@@UEAA@XZ ENDP		; Json::StreamWriterBuilder::~StreamWriterBuilder
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1StreamWriterBuilder@Json@@UEAA@XZ@4HA PROC ; `Json::StreamWriterBuilder::~StreamWriterBuilder'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1Factory@StreamWriter@Json@@UEAA@XZ	; Json::StreamWriter::Factory::~Factory
?dtor$0@?0???1StreamWriterBuilder@Json@@UEAA@XZ@4HA ENDP ; `Json::StreamWriterBuilder::~StreamWriterBuilder'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File e:\jsoncpp-master\src\lib_json\json_value.cpp
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp
;	COMDAT ?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ PROC ; Json::StreamWriterBuilder::newStreamWriter, COMDAT

; 1135 : {

$LN949:
	mov	rax, rsp
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 224				; 000000e0H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-169], rax

; 1136 :   JSONCPP_STRING indentation = settings_["indentation"].asString();

	lea	rdi, QWORD PTR [rcx+8]
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0M@BBOMBMCK@indentation?$AA@+11
	lea	rdx, OFFSET FLAT:??_C@_0M@BBOMBMCK@indentation?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	xor	esi, esi
	lea	rbx, OFFSET FLAT:?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B
	test	rax, rax
	jne	SHORT $LN22@newStreamW

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN24@newStreamW
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, sil

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rsi

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN24@newStreamW:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN22@newStreamW:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1136 :   JSONCPP_STRING indentation = settings_["indentation"].asString();

	lea	rdx, QWORD PTR indentation$[rbp-169]
	mov	rcx, rax
	call	?asString@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Value::asString
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0N@KEKHFENH@commentStyle?$AA@+12
	lea	rdx, OFFSET FLAT:??_C@_0N@KEKHFENH@commentStyle?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN63@newStreamW

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN65@newStreamW
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, 0

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rsi

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN65@newStreamW:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN63@newStreamW:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1137 :   JSONCPP_STRING cs_str = settings_["commentStyle"].asString();

	lea	rdx, QWORD PTR cs_str$[rbp-169]
	mov	rcx, rax
	call	?asString@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Value::asString
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0BI@GHONPDJP@enableYAMLCompatibility?$AA@+23
	lea	rdx, OFFSET FLAT:??_C@_0BI@GHONPDJP@enableYAMLCompatibility?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN104@newStreamW

; 42   :  static Value const nullStatic;

	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	al, 1
	jne	SHORT $LN106@newStreamW
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, 0

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rsi

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN106@newStreamW:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN104@newStreamW:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1138 :   bool eyc = settings_["enableYAMLCompatibility"].asBool();

	mov	rcx, rax
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	movzx	r12d, al
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0BF@JIKFMOIK@dropNullPlaceholders?$AA@+20
	lea	rdx, OFFSET FLAT:??_C@_0BF@JIKFMOIK@dropNullPlaceholders?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN145@newStreamW

; 42   :  static Value const nullStatic;

	mov	ecx, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	cl, 1
	jne	SHORT $LN147@newStreamW
	or	ecx, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, ecx

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, al

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rsi

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN147@newStreamW:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN145@newStreamW:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1139 :   bool dnp = settings_["dropNullPlaceholders"].asBool();

	mov	rcx, rax
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	movzx	r15d, al
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_0BB@MPBFLDFF@useSpecialFloats?$AA@+16
	lea	rdx, OFFSET FLAT:??_C@_0BB@MPBFLDFF@useSpecialFloats?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN186@newStreamW

; 42   :  static Value const nullStatic;

	mov	ecx, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	cl, 1
	jne	SHORT $LN188@newStreamW
	or	ecx, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, ecx

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, al

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rsi

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1
$LN188@newStreamW:

; 1091 :   if (!found) return nullSingleton();

	mov	rax, rbx
$LN186@newStreamW:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1140 :   bool usf = settings_["useSpecialFloats"].asBool(); 

	mov	rcx, rax
	call	?asBool@Value@Json@@QEBA_NXZ		; Json::Value::asBool
	movzx	r13d, al
; File e:\jsoncpp-master\src\lib_json\json_value.cpp

; 1090 :   Value const* found = find(key, key + strlen(key));

	lea	r8, OFFSET FLAT:??_C@_09HJGOLHNF@precision?$AA@+9
	lea	rdx, OFFSET FLAT:??_C@_09HJGOLHNF@precision?$AA@
	mov	rcx, rdi
	call	?find@Value@Json@@QEBAPEBV12@PEBD0@Z	; Json::Value::find

; 1091 :   if (!found) return nullSingleton();

	test	rax, rax
	jne	SHORT $LN226@newStreamW

; 42   :  static Value const nullStatic;

	mov	edx, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	test	dl, 1
	jne	SHORT $LN227@newStreamW
	or	edx, 1
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, edx

; 43   :  return nullStatic;
; 44   : }
; 45   : 
; 46   : // for backwards compatibility, we'll leave these global references around, but DO NOT
; 47   : // use them in JSONCPP library code any more!
; 48   : Value const& Value::null = Value::nullSingleton();
; 49   : Value const& Value::nullRef = Value::nullSingleton();
; 50   : 
; 51   : const Int Value::minInt = Int(~(UInt(-1) / 2));
; 52   : const Int Value::maxInt = Int(UInt(-1) / 2);
; 53   : const UInt Value::maxUInt = UInt(-1);
; 54   : #if defined(JSON_HAS_INT64)
; 55   : const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
; 56   : const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
; 57   : const UInt64 Value::maxUInt64 = UInt64(-1);
; 58   : // The constant is hard-coded because some compiler have trouble
; 59   : // converting Value::maxUInt64 to a double correctly (AIX/xlC).
; 60   : // Assumes that UInt64 is a 64 bits integer.
; 61   : static const double maxUInt64AsDouble = 18446744073709551615.0;
; 62   : #endif // defined(JSON_HAS_INT64)
; 63   : const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
; 64   : const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
; 65   : const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
; 66   : 
; 67   : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 68   : template <typename T, typename U>
; 69   : static inline bool InRange(double d, T min, U max) {
; 70   :   // The casts can lose precision, but we are looking only for
; 71   :   // an approximate range. Might fail on edge cases though. ~cdunn
; 72   :   //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
; 73   :   return d >= min && d <= max;
; 74   : }
; 75   : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 76   : static inline double integerToDouble(Json::UInt64 value) {
; 77   :   return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
; 78   : }
; 79   : 
; 80   : template <typename T> static inline double integerToDouble(T value) {
; 81   :   return static_cast<double>(value);
; 82   : }
; 83   : 
; 84   : template <typename T, typename U>
; 85   : static inline bool InRange(double d, T min, U max) {
; 86   :   return d >= integerToDouble(min) && d <= integerToDouble(max);
; 87   : }
; 88   : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 89   : 
; 90   : /** Duplicates the specified string value.
; 91   :  * @param value Pointer to the string to duplicate. Must be zero-terminated if
; 92   :  *              length is "unknown".
; 93   :  * @param length Length of the value. if equals to unknown, then it will be
; 94   :  *               computed using strlen(value).
; 95   :  * @return Pointer on the duplicate instance of string.
; 96   :  */
; 97   : static inline char* duplicateStringValue(const char* value,
; 98   :                                          size_t length)
; 99   : {
; 100  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 101  :   // to a sane value.
; 102  :   if (length >= static_cast<size_t>(Value::maxInt))
; 103  :     length = Value::maxInt - 1;
; 104  : 
; 105  :   char* newString = static_cast<char*>(malloc(length + 1));
; 106  :   if (newString == NULL) {
; 107  :     throwRuntimeError(
; 108  :         "in Json::Value::duplicateStringValue(): "
; 109  :         "Failed to allocate string value buffer");
; 110  :   }
; 111  :   memcpy(newString, value, length);
; 112  :   newString[length] = 0;
; 113  :   return newString;
; 114  : }
; 115  : 
; 116  : /* Record the length as a prefix.
; 117  :  */
; 118  : static inline char* duplicateAndPrefixStringValue(
; 119  :     const char* value,
; 120  :     unsigned int length)
; 121  : {
; 122  :   // Avoid an integer overflow in the call to malloc below by limiting length
; 123  :   // to a sane value.
; 124  :   JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
; 125  :                       "in Json::Value::duplicateAndPrefixStringValue(): "
; 126  :                       "length too big for prefixing");
; 127  :   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
; 128  :   char* newString = static_cast<char*>(malloc(actualLength));
; 129  :   if (newString == 0) {
; 130  :     throwRuntimeError(
; 131  :         "in Json::Value::duplicateAndPrefixStringValue(): "
; 132  :         "Failed to allocate string value buffer");
; 133  :   }
; 134  :   *reinterpret_cast<unsigned*>(newString) = length;
; 135  :   memcpy(newString + sizeof(unsigned), value, length);
; 136  :   newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
; 137  :   return newString;
; 138  : }
; 139  : inline static void decodePrefixedString(
; 140  :     bool isPrefixed, char const* prefixed,
; 141  :     unsigned* length, char const** value)
; 142  : {
; 143  :   if (!isPrefixed) {
; 144  :     *length = static_cast<unsigned>(strlen(prefixed));
; 145  :     *value = prefixed;
; 146  :   } else {
; 147  :     *length = *reinterpret_cast<unsigned const*>(prefixed);
; 148  :     *value = prefixed + sizeof(unsigned);
; 149  :   }
; 150  : }
; 151  : /** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
; 152  :  */
; 153  : #if JSONCPP_USING_SECURE_MEMORY
; 154  : static inline void releasePrefixedStringValue(char* value) {
; 155  :   unsigned length = 0;
; 156  :   char const* valueDecoded;
; 157  :   decodePrefixedString(true, value, &length, &valueDecoded);
; 158  :   size_t const size = sizeof(unsigned) + length + 1U;
; 159  :   memset(value, 0, size);
; 160  :   free(value);
; 161  : }
; 162  : static inline void releaseStringValue(char* value, unsigned length) {
; 163  :   // length==0 => we allocated the strings memory
; 164  :   size_t size = (length==0) ? strlen(value) : length;
; 165  :   memset(value, 0, size);
; 166  :   free(value);
; 167  : }
; 168  : #else // !JSONCPP_USING_SECURE_MEMORY
; 169  : static inline void releasePrefixedStringValue(char* value) {
; 170  :   free(value);
; 171  : }
; 172  : static inline void releaseStringValue(char* value, unsigned) {
; 173  :   free(value);
; 174  : }
; 175  : #endif // JSONCPP_USING_SECURE_MEMORY
; 176  : 
; 177  : } // namespace Json
; 178  : 
; 179  : // //////////////////////////////////////////////////////////////////
; 180  : // //////////////////////////////////////////////////////////////////
; 181  : // //////////////////////////////////////////////////////////////////
; 182  : // ValueInternals...
; 183  : // //////////////////////////////////////////////////////////////////
; 184  : // //////////////////////////////////////////////////////////////////
; 185  : // //////////////////////////////////////////////////////////////////
; 186  : #if !defined(JSON_IS_AMALGAMATION)
; 187  : 
; 188  : #include "json_valueiterator.inl"
; 189  : #endif // if !defined(JSON_IS_AMALGAMATION)
; 190  : 
; 191  : namespace Json {
; 192  : 
; 193  : Exception::Exception(JSONCPP_STRING const& msg)
; 194  :   : msg_(msg)
; 195  : {}
; 196  : Exception::~Exception() JSONCPP_NOEXCEPT
; 197  : {}
; 198  : char const* Exception::what() const JSONCPP_NOEXCEPT
; 199  : {
; 200  :   return msg_.c_str();
; 201  : }
; 202  : RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
; 203  :   : Exception(msg)
; 204  : {}
; 205  : LogicError::LogicError(JSONCPP_STRING const& msg)
; 206  :   : Exception(msg)
; 207  : {}
; 208  : JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
; 209  : {
; 210  :   throw RuntimeError(msg);
; 211  : }
; 212  : JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
; 213  : {
; 214  :   throw LogicError(msg);
; 215  : }
; 216  : 
; 217  : // //////////////////////////////////////////////////////////////////
; 218  : // //////////////////////////////////////////////////////////////////
; 219  : // //////////////////////////////////////////////////////////////////
; 220  : // class Value::CommentInfo
; 221  : // //////////////////////////////////////////////////////////////////
; 222  : // //////////////////////////////////////////////////////////////////
; 223  : // //////////////////////////////////////////////////////////////////
; 224  : 
; 225  : Value::CommentInfo::CommentInfo() : comment_(0)
; 226  : {}
; 227  : 
; 228  : Value::CommentInfo::~CommentInfo() {
; 229  :   if (comment_)
; 230  :     releaseStringValue(comment_, 0u);
; 231  : }
; 232  : 
; 233  : void Value::CommentInfo::setComment(const char* text, size_t len) {
; 234  :   if (comment_) {
; 235  :     releaseStringValue(comment_, 0u);
; 236  :     comment_ = 0;
; 237  :   }
; 238  :   JSON_ASSERT(text != 0);
; 239  :   JSON_ASSERT_MESSAGE(
; 240  :       text[0] == '\0' || text[0] == '/',
; 241  :       "in Json::Value::setComment(): Comments must start with /");
; 242  :   // It seems that /**/ style comments are acceptable as well.
; 243  :   comment_ = duplicateStringValue(text, len);
; 244  : }
; 245  : 
; 246  : // //////////////////////////////////////////////////////////////////
; 247  : // //////////////////////////////////////////////////////////////////
; 248  : // //////////////////////////////////////////////////////////////////
; 249  : // class Value::CZString
; 250  : // //////////////////////////////////////////////////////////////////
; 251  : // //////////////////////////////////////////////////////////////////
; 252  : // //////////////////////////////////////////////////////////////////
; 253  : 
; 254  : // Notes: policy_ indicates if the string was allocated when
; 255  : // a string is stored.
; 256  : 
; 257  : Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
; 258  : 
; 259  : Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
; 260  :     : cstr_(str) {
; 261  :   // allocate != duplicate
; 262  :   storage_.policy_ = allocate & 0x3;
; 263  :   storage_.length_ = ulength & 0x3FFFFFFF;
; 264  : }
; 265  : 
; 266  : Value::CZString::CZString(const CZString& other) {
; 267  :   cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
; 268  : 				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
; 269  : 				 : other.cstr_);
; 270  :   storage_.policy_ = static_cast<unsigned>(other.cstr_
; 271  :                  ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
; 272  :                      ? noDuplication : duplicate)
; 273  :                  : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
; 274  :   storage_.length_ = other.storage_.length_;
; 275  : }
; 276  : 
; 277  : #if JSON_HAS_RVALUE_REFERENCES
; 278  : Value::CZString::CZString(CZString&& other)
; 279  :   : cstr_(other.cstr_), index_(other.index_) {
; 280  :   other.cstr_ = nullptr;
; 281  : }
; 282  : #endif
; 283  : 
; 284  : Value::CZString::~CZString() {
; 285  :   if (cstr_ && storage_.policy_ == duplicate) {
; 286  : 	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
; 287  :   }
; 288  : }
; 289  : 
; 290  : void Value::CZString::swap(CZString& other) {
; 291  :   std::swap(cstr_, other.cstr_);
; 292  :   std::swap(index_, other.index_);
; 293  : }
; 294  : 
; 295  : Value::CZString& Value::CZString::operator=(CZString other) {
; 296  :   swap(other);
; 297  :   return *this;
; 298  : }
; 299  : 
; 300  : bool Value::CZString::operator<(const CZString& other) const {
; 301  :   if (!cstr_) return index_ < other.index_;
; 302  :   //return strcmp(cstr_, other.cstr_) < 0;
; 303  :   // Assume both are strings.
; 304  :   unsigned this_len = this->storage_.length_;
; 305  :   unsigned other_len = other.storage_.length_;
; 306  :   unsigned min_len = std::min<unsigned>(this_len, other_len);
; 307  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 308  :   int comp = memcmp(this->cstr_, other.cstr_, min_len);
; 309  :   if (comp < 0) return true;
; 310  :   if (comp > 0) return false;
; 311  :   return (this_len < other_len);
; 312  : }
; 313  : 
; 314  : bool Value::CZString::operator==(const CZString& other) const {
; 315  :   if (!cstr_) return index_ == other.index_;
; 316  :   //return strcmp(cstr_, other.cstr_) == 0;
; 317  :   // Assume both are strings.
; 318  :   unsigned this_len = this->storage_.length_;
; 319  :   unsigned other_len = other.storage_.length_;
; 320  :   if (this_len != other_len) return false;
; 321  :   JSON_ASSERT(this->cstr_ && other.cstr_);
; 322  :   int comp = memcmp(this->cstr_, other.cstr_, this_len);
; 323  :   return comp == 0;
; 324  : }
; 325  : 
; 326  : ArrayIndex Value::CZString::index() const { return index_; }
; 327  : 
; 328  : //const char* Value::CZString::c_str() const { return cstr_; }
; 329  : const char* Value::CZString::data() const { return cstr_; }
; 330  : unsigned Value::CZString::length() const { return storage_.length_; }
; 331  : bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
; 332  : 
; 333  : // //////////////////////////////////////////////////////////////////
; 334  : // //////////////////////////////////////////////////////////////////
; 335  : // //////////////////////////////////////////////////////////////////
; 336  : // class Value::Value
; 337  : // //////////////////////////////////////////////////////////////////
; 338  : // //////////////////////////////////////////////////////////////////
; 339  : // //////////////////////////////////////////////////////////////////
; 340  : 
; 341  : /*! \internal Default constructor initialization must be equivalent to:
; 342  :  * memset( this, 0, sizeof(Value) )
; 343  :  * This optimization is used in ValueInternalMap fast allocator.
; 344  :  */
; 345  : Value::Value(ValueType vtype) {
; 346  :   static char const emptyString[] = "";
; 347  :   initBasic(vtype);
; 348  :   switch (vtype) {
; 349  :   case nullValue:
; 350  :     break;
; 351  :   case intValue:
; 352  :   case uintValue:
; 353  :     value_.int_ = 0;
; 354  :     break;
; 355  :   case realValue:
; 356  :     value_.real_ = 0.0;
; 357  :     break;
; 358  :   case stringValue:
; 359  :     // allocated_ == false, so this is safe.
; 360  :     value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
; 361  :     break;
; 362  :   case arrayValue:
; 363  :   case objectValue:
; 364  :     value_.map_ = new ObjectValues();
; 365  :     break;
; 366  :   case booleanValue:
; 367  :     value_.bool_ = false;
; 368  :     break;
; 369  :   default:
; 370  :     JSON_ASSERT_UNREACHABLE;
; 371  :   }
; 372  : }
; 373  : 
; 374  : Value::Value(Int value) {
; 375  :   initBasic(intValue);
; 376  :   value_.int_ = value;
; 377  : }
; 378  : 
; 379  : Value::Value(UInt value) {
; 380  :   initBasic(uintValue);
; 381  :   value_.uint_ = value;
; 382  : }
; 383  : #if defined(JSON_HAS_INT64)
; 384  : Value::Value(Int64 value) {
; 385  :   initBasic(intValue);
; 386  :   value_.int_ = value;
; 387  : }
; 388  : Value::Value(UInt64 value) {
; 389  :   initBasic(uintValue);
; 390  :   value_.uint_ = value;
; 391  : }
; 392  : #endif // defined(JSON_HAS_INT64)
; 393  : 
; 394  : Value::Value(double value) {
; 395  :   initBasic(realValue);
; 396  :   value_.real_ = value;
; 397  : }
; 398  : 
; 399  : Value::Value(const char* value) {
; 400  :   initBasic(stringValue, true);
; 401  :   JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");	
; 402  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
; 403  : }
; 404  : 
; 405  : Value::Value(const char* beginValue, const char* endValue) {
; 406  :   initBasic(stringValue, true);
; 407  :   value_.string_ =
; 408  :       duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
; 409  : }
; 410  : 
; 411  : Value::Value(const JSONCPP_STRING& value) {
; 412  :   initBasic(stringValue, true);
; 413  :   value_.string_ =
; 414  :       duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
; 415  : }
; 416  : 
; 417  : Value::Value(const StaticString& value) {
; 418  :   initBasic(stringValue);
; 419  :   value_.string_ = const_cast<char*>(value.c_str());
; 420  : }
; 421  : 
; 422  : #ifdef JSON_USE_CPPTL
; 423  : Value::Value(const CppTL::ConstString& value) {
; 424  :   initBasic(stringValue, true);
; 425  :   value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
; 426  : }
; 427  : #endif
; 428  : 
; 429  : Value::Value(bool value) {
; 430  :   initBasic(booleanValue);
; 431  :   value_.bool_ = value;
; 432  : }
; 433  : 
; 434  : Value::Value(Value const& other)
; 435  :     : type_(other.type_), allocated_(false)
; 436  :       ,
; 437  :       comments_(0), start_(other.start_), limit_(other.limit_)
; 438  : {
; 439  :   switch (type_) {
; 440  :   case nullValue:
; 441  :   case intValue:
; 442  :   case uintValue:
; 443  :   case realValue:
; 444  :   case booleanValue:
; 445  :     value_ = other.value_;
; 446  :     break;
; 447  :   case stringValue:
; 448  :     if (other.value_.string_ && other.allocated_) {
; 449  :       unsigned len;
; 450  :       char const* str;
; 451  :       decodePrefixedString(other.allocated_, other.value_.string_,
; 452  :           &len, &str);
; 453  :       value_.string_ = duplicateAndPrefixStringValue(str, len);
; 454  :       allocated_ = true;
; 455  :     } else {
; 456  :       value_.string_ = other.value_.string_;
; 457  :       allocated_ = false;
; 458  :     }
; 459  :     break;
; 460  :   case arrayValue:
; 461  :   case objectValue:
; 462  :     value_.map_ = new ObjectValues(*other.value_.map_);
; 463  :     break;
; 464  :   default:
; 465  :     JSON_ASSERT_UNREACHABLE;
; 466  :   }
; 467  :   if (other.comments_) {
; 468  :     comments_ = new CommentInfo[numberOfCommentPlacement];
; 469  :     for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
; 470  :       const CommentInfo& otherComment = other.comments_[comment];
; 471  :       if (otherComment.comment_)
; 472  :         comments_[comment].setComment(
; 473  :             otherComment.comment_, strlen(otherComment.comment_));
; 474  :     }
; 475  :   }
; 476  : }
; 477  : 
; 478  : #if JSON_HAS_RVALUE_REFERENCES
; 479  : // Move constructor
; 480  : Value::Value(Value&& other) {
; 481  :   initBasic(nullValue);
; 482  :   swap(other);
; 483  : }
; 484  : #endif
; 485  : 
; 486  : Value::~Value() {
; 487  :   switch (type_) {
; 488  :   case nullValue:
; 489  :   case intValue:
; 490  :   case uintValue:
; 491  :   case realValue:
; 492  :   case booleanValue:
; 493  :     break;
; 494  :   case stringValue:
; 495  :     if (allocated_)
; 496  :       releasePrefixedStringValue(value_.string_);
; 497  :     break;
; 498  :   case arrayValue:
; 499  :   case objectValue:
; 500  :     delete value_.map_;
; 501  :     break;
; 502  :   default:
; 503  :     JSON_ASSERT_UNREACHABLE;
; 504  :   }
; 505  : 
; 506  :   delete[] comments_;
; 507  : 
; 508  :   value_.uint_ = 0;
; 509  : }
; 510  : 
; 511  : Value& Value::operator=(Value other) {
; 512  :   swap(other);
; 513  :   return *this;
; 514  : }
; 515  : 
; 516  : void Value::swapPayload(Value& other) {
; 517  :   ValueType temp = type_;
; 518  :   type_ = other.type_;
; 519  :   other.type_ = temp;
; 520  :   std::swap(value_, other.value_);
; 521  :   int temp2 = allocated_;
; 522  :   allocated_ = other.allocated_;
; 523  :   other.allocated_ = temp2 & 0x1;
; 524  : }
; 525  : 
; 526  : void Value::swap(Value& other) {
; 527  :   swapPayload(other);
; 528  :   std::swap(comments_, other.comments_);
; 529  :   std::swap(start_, other.start_);
; 530  :   std::swap(limit_, other.limit_);
; 531  : }
; 532  : 
; 533  : ValueType Value::type() const { return type_; }
; 534  : 
; 535  : int Value::compare(const Value& other) const {
; 536  :   if (*this < other)
; 537  :     return -1;
; 538  :   if (*this > other)
; 539  :     return 1;
; 540  :   return 0;
; 541  : }
; 542  : 
; 543  : bool Value::operator<(const Value& other) const {
; 544  :   int typeDelta = type_ - other.type_;
; 545  :   if (typeDelta)
; 546  :     return typeDelta < 0 ? true : false;
; 547  :   switch (type_) {
; 548  :   case nullValue:
; 549  :     return false;
; 550  :   case intValue:
; 551  :     return value_.int_ < other.value_.int_;
; 552  :   case uintValue:
; 553  :     return value_.uint_ < other.value_.uint_;
; 554  :   case realValue:
; 555  :     return value_.real_ < other.value_.real_;
; 556  :   case booleanValue:
; 557  :     return value_.bool_ < other.value_.bool_;
; 558  :   case stringValue:
; 559  :   {
; 560  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 561  :       if (other.value_.string_) return true;
; 562  :       else return false;
; 563  :     }
; 564  :     unsigned this_len;
; 565  :     unsigned other_len;
; 566  :     char const* this_str;
; 567  :     char const* other_str;
; 568  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 569  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 570  :     unsigned min_len = std::min<unsigned>(this_len, other_len);
; 571  :     JSON_ASSERT(this_str && other_str);
; 572  :     int comp = memcmp(this_str, other_str, min_len);
; 573  :     if (comp < 0) return true;
; 574  :     if (comp > 0) return false;
; 575  :     return (this_len < other_len);
; 576  :   }
; 577  :   case arrayValue:
; 578  :   case objectValue: {
; 579  :     int delta = int(value_.map_->size() - other.value_.map_->size());
; 580  :     if (delta)
; 581  :       return delta < 0;
; 582  :     return (*value_.map_) < (*other.value_.map_);
; 583  :   }
; 584  :   default:
; 585  :     JSON_ASSERT_UNREACHABLE;
; 586  :   }
; 587  :   return false; // unreachable
; 588  : }
; 589  : 
; 590  : bool Value::operator<=(const Value& other) const { return !(other < *this); }
; 591  : 
; 592  : bool Value::operator>=(const Value& other) const { return !(*this < other); }
; 593  : 
; 594  : bool Value::operator>(const Value& other) const { return other < *this; }
; 595  : 
; 596  : bool Value::operator==(const Value& other) const {
; 597  :   // if ( type_ != other.type_ )
; 598  :   // GCC 2.95.3 says:
; 599  :   // attempt to take address of bit-field structure member `Json::Value::type_'
; 600  :   // Beats me, but a temp solves the problem.
; 601  :   int temp = other.type_;
; 602  :   if (type_ != temp)
; 603  :     return false;
; 604  :   switch (type_) {
; 605  :   case nullValue:
; 606  :     return true;
; 607  :   case intValue:
; 608  :     return value_.int_ == other.value_.int_;
; 609  :   case uintValue:
; 610  :     return value_.uint_ == other.value_.uint_;
; 611  :   case realValue:
; 612  :     return value_.real_ == other.value_.real_;
; 613  :   case booleanValue:
; 614  :     return value_.bool_ == other.value_.bool_;
; 615  :   case stringValue:
; 616  :   {
; 617  :     if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
; 618  :       return (value_.string_ == other.value_.string_);
; 619  :     }
; 620  :     unsigned this_len;
; 621  :     unsigned other_len;
; 622  :     char const* this_str;
; 623  :     char const* other_str;
; 624  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 625  :     decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
; 626  :     if (this_len != other_len) return false;
; 627  :     JSON_ASSERT(this_str && other_str);
; 628  :     int comp = memcmp(this_str, other_str, this_len);
; 629  :     return comp == 0;
; 630  :   }
; 631  :   case arrayValue:
; 632  :   case objectValue:
; 633  :     return value_.map_->size() == other.value_.map_->size() &&
; 634  :            (*value_.map_) == (*other.value_.map_);
; 635  :   default:
; 636  :     JSON_ASSERT_UNREACHABLE;
; 637  :   }
; 638  :   return false; // unreachable
; 639  : }
; 640  : 
; 641  : bool Value::operator!=(const Value& other) const { return !(*this == other); }
; 642  : 
; 643  : const char* Value::asCString() const {
; 644  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 645  :                       "in Json::Value::asCString(): requires stringValue");
; 646  :   if (value_.string_ == 0) return 0;
; 647  :   unsigned this_len;
; 648  :   char const* this_str;
; 649  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 650  :   return this_str;
; 651  : }
; 652  : 
; 653  : #if JSONCPP_USING_SECURE_MEMORY
; 654  : unsigned Value::getCStringLength() const {
; 655  :   JSON_ASSERT_MESSAGE(type_ == stringValue,
; 656  : 	                  "in Json::Value::asCString(): requires stringValue");
; 657  :   if (value_.string_ == 0) return 0;
; 658  :   unsigned this_len;
; 659  :   char const* this_str;
; 660  :   decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 661  :   return this_len;
; 662  : }
; 663  : #endif
; 664  : 
; 665  : bool Value::getString(char const** str, char const** cend) const {
; 666  :   if (type_ != stringValue) return false;
; 667  :   if (value_.string_ == 0) return false;
; 668  :   unsigned length;
; 669  :   decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
; 670  :   *cend = *str + length;
; 671  :   return true;
; 672  : }
; 673  : 
; 674  : JSONCPP_STRING Value::asString() const {
; 675  :   switch (type_) {
; 676  :   case nullValue:
; 677  :     return "";
; 678  :   case stringValue:
; 679  :   {
; 680  :     if (value_.string_ == 0) return "";
; 681  :     unsigned this_len;
; 682  :     char const* this_str;
; 683  :     decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
; 684  :     return JSONCPP_STRING(this_str, this_len);
; 685  :   }
; 686  :   case booleanValue:
; 687  :     return value_.bool_ ? "true" : "false";
; 688  :   case intValue:
; 689  :     return valueToString(value_.int_);
; 690  :   case uintValue:
; 691  :     return valueToString(value_.uint_);
; 692  :   case realValue:
; 693  :     return valueToString(value_.real_);
; 694  :   default:
; 695  :     JSON_FAIL_MESSAGE("Type is not convertible to string");
; 696  :   }
; 697  : }
; 698  : 
; 699  : #ifdef JSON_USE_CPPTL
; 700  : CppTL::ConstString Value::asConstString() const {
; 701  :   unsigned len;
; 702  :   char const* str;
; 703  :   decodePrefixedString(allocated_, value_.string_,
; 704  :       &len, &str);
; 705  :   return CppTL::ConstString(str, len);
; 706  : }
; 707  : #endif
; 708  : 
; 709  : Value::Int Value::asInt() const {
; 710  :   switch (type_) {
; 711  :   case intValue:
; 712  :     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
; 713  :     return Int(value_.int_);
; 714  :   case uintValue:
; 715  :     JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
; 716  :     return Int(value_.uint_);
; 717  :   case realValue:
; 718  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
; 719  :                         "double out of Int range");
; 720  :     return Int(value_.real_);
; 721  :   case nullValue:
; 722  :     return 0;
; 723  :   case booleanValue:
; 724  :     return value_.bool_ ? 1 : 0;
; 725  :   default:
; 726  :     break;
; 727  :   }
; 728  :   JSON_FAIL_MESSAGE("Value is not convertible to Int.");
; 729  : }
; 730  : 
; 731  : Value::UInt Value::asUInt() const {
; 732  :   switch (type_) {
; 733  :   case intValue:
; 734  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
; 735  :     return UInt(value_.int_);
; 736  :   case uintValue:
; 737  :     JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
; 738  :     return UInt(value_.uint_);
; 739  :   case realValue:
; 740  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
; 741  :                         "double out of UInt range");
; 742  :     return UInt(value_.real_);
; 743  :   case nullValue:
; 744  :     return 0;
; 745  :   case booleanValue:
; 746  :     return value_.bool_ ? 1 : 0;
; 747  :   default:
; 748  :     break;
; 749  :   }
; 750  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
; 751  : }
; 752  : 
; 753  : #if defined(JSON_HAS_INT64)
; 754  : 
; 755  : Value::Int64 Value::asInt64() const {
; 756  :   switch (type_) {
; 757  :   case intValue:
; 758  :     return Int64(value_.int_);
; 759  :   case uintValue:
; 760  :     JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
; 761  :     return Int64(value_.uint_);
; 762  :   case realValue:
; 763  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
; 764  :                         "double out of Int64 range");
; 765  :     return Int64(value_.real_);
; 766  :   case nullValue:
; 767  :     return 0;
; 768  :   case booleanValue:
; 769  :     return value_.bool_ ? 1 : 0;
; 770  :   default:
; 771  :     break;
; 772  :   }
; 773  :   JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
; 774  : }
; 775  : 
; 776  : Value::UInt64 Value::asUInt64() const {
; 777  :   switch (type_) {
; 778  :   case intValue:
; 779  :     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
; 780  :     return UInt64(value_.int_);
; 781  :   case uintValue:
; 782  :     return UInt64(value_.uint_);
; 783  :   case realValue:
; 784  :     JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
; 785  :                         "double out of UInt64 range");
; 786  :     return UInt64(value_.real_);
; 787  :   case nullValue:
; 788  :     return 0;
; 789  :   case booleanValue:
; 790  :     return value_.bool_ ? 1 : 0;
; 791  :   default:
; 792  :     break;
; 793  :   }
; 794  :   JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
; 795  : }
; 796  : #endif // if defined(JSON_HAS_INT64)
; 797  : 
; 798  : LargestInt Value::asLargestInt() const {
; 799  : #if defined(JSON_NO_INT64)
; 800  :   return asInt();
; 801  : #else
; 802  :   return asInt64();
; 803  : #endif
; 804  : }
; 805  : 
; 806  : LargestUInt Value::asLargestUInt() const {
; 807  : #if defined(JSON_NO_INT64)
; 808  :   return asUInt();
; 809  : #else
; 810  :   return asUInt64();
; 811  : #endif
; 812  : }
; 813  : 
; 814  : double Value::asDouble() const {
; 815  :   switch (type_) {
; 816  :   case intValue:
; 817  :     return static_cast<double>(value_.int_);
; 818  :   case uintValue:
; 819  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 820  :     return static_cast<double>(value_.uint_);
; 821  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 822  :     return integerToDouble(value_.uint_);
; 823  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 824  :   case realValue:
; 825  :     return value_.real_;
; 826  :   case nullValue:
; 827  :     return 0.0;
; 828  :   case booleanValue:
; 829  :     return value_.bool_ ? 1.0 : 0.0;
; 830  :   default:
; 831  :     break;
; 832  :   }
; 833  :   JSON_FAIL_MESSAGE("Value is not convertible to double.");
; 834  : }
; 835  : 
; 836  : float Value::asFloat() const {
; 837  :   switch (type_) {
; 838  :   case intValue:
; 839  :     return static_cast<float>(value_.int_);
; 840  :   case uintValue:
; 841  : #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 842  :     return static_cast<float>(value_.uint_);
; 843  : #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 844  :     // This can fail (silently?) if the value is bigger than MAX_FLOAT.
; 845  :     return static_cast<float>(integerToDouble(value_.uint_));
; 846  : #endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
; 847  :   case realValue:
; 848  :     return static_cast<float>(value_.real_);
; 849  :   case nullValue:
; 850  :     return 0.0;
; 851  :   case booleanValue:
; 852  :     return value_.bool_ ? 1.0f : 0.0f;
; 853  :   default:
; 854  :     break;
; 855  :   }
; 856  :   JSON_FAIL_MESSAGE("Value is not convertible to float.");
; 857  : }
; 858  : 
; 859  : bool Value::asBool() const {
; 860  :   switch (type_) {
; 861  :   case booleanValue:
; 862  :     return value_.bool_;
; 863  :   case nullValue:
; 864  :     return false;
; 865  :   case intValue:
; 866  :     return value_.int_ ? true : false;
; 867  :   case uintValue:
; 868  :     return value_.uint_ ? true : false;
; 869  :   case realValue:
; 870  :     // This is kind of strange. Not recommended.
; 871  :     return (value_.real_ != 0.0) ? true : false;
; 872  :   default:
; 873  :     break;
; 874  :   }
; 875  :   JSON_FAIL_MESSAGE("Value is not convertible to bool.");
; 876  : }
; 877  : 
; 878  : bool Value::isConvertibleTo(ValueType other) const {
; 879  :   switch (other) {
; 880  :   case nullValue:
; 881  :     return (isNumeric() && asDouble() == 0.0) ||
; 882  :            (type_ == booleanValue && value_.bool_ == false) ||
; 883  :            (type_ == stringValue && asString().empty()) ||
; 884  :            (type_ == arrayValue && value_.map_->size() == 0) ||
; 885  :            (type_ == objectValue && value_.map_->size() == 0) ||
; 886  :            type_ == nullValue;
; 887  :   case intValue:
; 888  :     return isInt() ||
; 889  :            (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
; 890  :            type_ == booleanValue || type_ == nullValue;
; 891  :   case uintValue:
; 892  :     return isUInt() ||
; 893  :            (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
; 894  :            type_ == booleanValue || type_ == nullValue;
; 895  :   case realValue:
; 896  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 897  :   case booleanValue:
; 898  :     return isNumeric() || type_ == booleanValue || type_ == nullValue;
; 899  :   case stringValue:
; 900  :     return isNumeric() || type_ == booleanValue || type_ == stringValue ||
; 901  :            type_ == nullValue;
; 902  :   case arrayValue:
; 903  :     return type_ == arrayValue || type_ == nullValue;
; 904  :   case objectValue:
; 905  :     return type_ == objectValue || type_ == nullValue;
; 906  :   }
; 907  :   JSON_ASSERT_UNREACHABLE;
; 908  :   return false;
; 909  : }
; 910  : 
; 911  : /// Number of values in array or object
; 912  : ArrayIndex Value::size() const {
; 913  :   switch (type_) {
; 914  :   case nullValue:
; 915  :   case intValue:
; 916  :   case uintValue:
; 917  :   case realValue:
; 918  :   case booleanValue:
; 919  :   case stringValue:
; 920  :     return 0;
; 921  :   case arrayValue: // size of the array is highest index + 1
; 922  :     if (!value_.map_->empty()) {
; 923  :       ObjectValues::const_iterator itLast = value_.map_->end();
; 924  :       --itLast;
; 925  :       return (*itLast).first.index() + 1;
; 926  :     }
; 927  :     return 0;
; 928  :   case objectValue:
; 929  :     return ArrayIndex(value_.map_->size());
; 930  :   }
; 931  :   JSON_ASSERT_UNREACHABLE;
; 932  :   return 0; // unreachable;
; 933  : }
; 934  : 
; 935  : bool Value::empty() const {
; 936  :   if (isNull() || isArray() || isObject())
; 937  :     return size() == 0u;
; 938  :   else
; 939  :     return false;
; 940  : }
; 941  : 
; 942  : bool Value::operator!() const { return isNull(); }
; 943  : 
; 944  : void Value::clear() {
; 945  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
; 946  :                           type_ == objectValue,
; 947  :                       "in Json::Value::clear(): requires complex value");
; 948  :   start_ = 0;
; 949  :   limit_ = 0;
; 950  :   switch (type_) {
; 951  :   case arrayValue:
; 952  :   case objectValue:
; 953  :     value_.map_->clear();
; 954  :     break;
; 955  :   default:
; 956  :     break;
; 957  :   }
; 958  : }
; 959  : 
; 960  : void Value::resize(ArrayIndex newSize) {
; 961  :   JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
; 962  :                       "in Json::Value::resize(): requires arrayValue");
; 963  :   if (type_ == nullValue)
; 964  :     *this = Value(arrayValue);
; 965  :   ArrayIndex oldSize = size();
; 966  :   if (newSize == 0)
; 967  :     clear();
; 968  :   else if (newSize > oldSize)
; 969  :     (*this)[newSize - 1];
; 970  :   else {
; 971  :     for (ArrayIndex index = newSize; index < oldSize; ++index) {
; 972  :       value_.map_->erase(index);
; 973  :     }
; 974  :     JSON_ASSERT(size() == newSize);
; 975  :   }
; 976  : }
; 977  : 
; 978  : Value& Value::operator[](ArrayIndex index) {
; 979  :   JSON_ASSERT_MESSAGE(
; 980  :       type_ == nullValue || type_ == arrayValue,
; 981  :       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
; 982  :   if (type_ == nullValue)
; 983  :     *this = Value(arrayValue);
; 984  :   CZString key(index);
; 985  :   ObjectValues::iterator it = value_.map_->lower_bound(key);
; 986  :   if (it != value_.map_->end() && (*it).first == key)
; 987  :     return (*it).second;
; 988  : 
; 989  :   ObjectValues::value_type defaultValue(key, nullSingleton());
; 990  :   it = value_.map_->insert(it, defaultValue);
; 991  :   return (*it).second;
; 992  : }
; 993  : 
; 994  : Value& Value::operator[](int index) {
; 995  :   JSON_ASSERT_MESSAGE(
; 996  :       index >= 0,
; 997  :       "in Json::Value::operator[](int index): index cannot be negative");
; 998  :   return (*this)[ArrayIndex(index)];
; 999  : }
; 1000 : 
; 1001 : const Value& Value::operator[](ArrayIndex index) const {
; 1002 :   JSON_ASSERT_MESSAGE(
; 1003 :       type_ == nullValue || type_ == arrayValue,
; 1004 :       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
; 1005 :   if (type_ == nullValue)
; 1006 :     return nullSingleton();
; 1007 :   CZString key(index);
; 1008 :   ObjectValues::const_iterator it = value_.map_->find(key);
; 1009 :   if (it == value_.map_->end())
; 1010 :     return nullSingleton();
; 1011 :   return (*it).second;
; 1012 : }
; 1013 : 
; 1014 : const Value& Value::operator[](int index) const {
; 1015 :   JSON_ASSERT_MESSAGE(
; 1016 :       index >= 0,
; 1017 :       "in Json::Value::operator[](int index) const: index cannot be negative");
; 1018 :   return (*this)[ArrayIndex(index)];
; 1019 : }
; 1020 : 
; 1021 : void Value::initBasic(ValueType vtype, bool allocated) {
; 1022 :   type_ = vtype;

	mov	BYTE PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, al

; 1023 :   allocated_ = allocated;

	and	DWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+8, -257 ; fffffeffH
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+16, xmm0

; 1024 :   comments_ = 0;
; 1025 :   start_ = 0;
; 1026 :   limit_ = 0;

	mov	QWORD PTR ?nullStatic@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4V23@B+32, rsi

; 42   :  static Value const nullStatic;

	lea	rcx, OFFSET FLAT:??__FnullStatic@?1??nullSingleton@Value@Json@@SAAEBV12@XZ@YAXXZ ; `Json::Value::nullSingleton'::`2'::`dynamic atexit destructor for 'nullStatic''
	call	atexit
	npad	1

; 1091 :   if (!found) return nullSingleton();

	jmp	SHORT $LN227@newStreamW
$LN226@newStreamW:

; 1092 :   return *found;

	mov	rbx, rax
$LN227@newStreamW:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1141 :   unsigned int pre = settings_["precision"].asUInt();

	mov	rcx, rbx
	call	?asUInt@Value@Json@@QEBAIXZ		; Json::Value::asUInt
	mov	esi, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rcx, QWORD PTR cs_str$[rbp-169]
	mov	rdi, QWORD PTR cs_str$[rbp-169]
	mov	r14, QWORD PTR cs_str$[rbp-145]
	cmp	r14, 16
	cmovae	rcx, rdi

; 2182 : 			_N0 < _Count ? _N0 : _Count);

	mov	r8d, 3
	mov	rbx, QWORD PTR cs_str$[rbp-153]
	cmp	rbx, r8
	cmovb	r8, rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 517  : 			: _CSTD memcmp(_First1, _First2, _Count));

	test	r8, r8
	jne	SHORT $LN294@newStreamW
	xor	eax, eax
	jmp	SHORT $LN295@newStreamW
$LN294@newStreamW:
	lea	rdx, OFFSET FLAT:??_C@_03HFJGAJFE@All?$AA@
	call	memcmp
$LN295@newStreamW:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2182 : 			_N0 < _Count ? _N0 : _Count);

	cdqe

; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);

	test	rax, rax
	jne	SHORT $LN280@newStreamW
	cmp	rbx, 3
	jae	SHORT $LN279@newStreamW
	or	eax, -1
	jmp	SHORT $LN280@newStreamW
$LN279@newStreamW:
	xor	eax, eax
	cmp	rbx, 3
	setne	al
$LN280@newStreamW:

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);

	test	eax, eax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1143 :   if (cs_str == "All") {

	jne	SHORT $LN305@newStreamW

; 1144 :     cs = CommentStyle::All;

	lea	r14d, QWORD PTR [rax+2]

; 1145 :   } else if (cs_str == "None") {

	jmp	SHORT $LN404@newStreamW
$LN305@newStreamW:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rcx, QWORD PTR cs_str$[rbp-169]
	cmp	r14, 16
	cmovae	rcx, rdi

; 2182 : 			_N0 < _Count ? _N0 : _Count);

	mov	r8d, 4
	cmp	rbx, r8
	cmovb	r8, rbx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 517  : 			: _CSTD memcmp(_First1, _First2, _Count));

	test	r8, r8
	jne	SHORT $LN326@newStreamW
	xor	eax, eax
	jmp	SHORT $LN327@newStreamW
$LN326@newStreamW:
	lea	rdx, OFFSET FLAT:??_C@_04OHJIHAFH@None?$AA@
	call	memcmp
$LN327@newStreamW:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2182 : 			_N0 < _Count ? _N0 : _Count);

	cdqe

; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);

	test	rax, rax
	jne	SHORT $LN312@newStreamW
	cmp	rbx, 4
	jae	SHORT $LN311@newStreamW
	or	eax, -1
	jmp	SHORT $LN312@newStreamW
$LN311@newStreamW:
	xor	eax, eax
	cmp	rbx, 4
	setne	al
$LN312@newStreamW:

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);

	test	eax, eax
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1145 :   } else if (cs_str == "None") {

	jne	$LN7@newStreamW

; 1146 :     cs = CommentStyle::None;

	xor	r14d, r14d
$LN404@newStreamW:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR colonSymbol$[rbp-145], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR colonSymbol$[rbp-153], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR colonSymbol$[rbp-169], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:??_C@_03MCPBMLDJ@?5?3?5?$AA@
	lea	rcx, QWORD PTR colonSymbol$[rbp-169]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1151 :   if (eyc) {

	test	r12b, r12b
	je	SHORT $LN5@newStreamW
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1153 :   } else if (indentation.empty()) {

	jmp	SHORT $LN948@newStreamW
$LN5@newStreamW:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	QWORD PTR indentation$[rbp-153], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1153 :   } else if (indentation.empty()) {

	jne	SHORT $LN460@newStreamW
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
$LN948@newStreamW:
	lea	rcx, QWORD PTR colonSymbol$[rbp-169]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN460@newStreamW:

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR nullSymbol$[rbp-145], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	r12d, r12d
	mov	QWORD PTR nullSymbol$[rbp-153], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR nullSymbol$[rbp-169], r12b
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r12+4]
	lea	rdx, OFFSET FLAT:??_C@_04MLLLIHIP@null?$AA@
	lea	rcx, QWORD PTR nullSymbol$[rbp-169]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1157 :   if (dnp) {

	test	r15b, r15b
	je	SHORT $LN522@newStreamW
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR nullSymbol$[rbp-153], r12

; 513  : 			: this->_Bx._Buf);

	lea	rax, QWORD PTR nullSymbol$[rbp-169]
	cmp	QWORD PTR nullSymbol$[rbp-145], 16
	cmovae	rax, QWORD PTR nullSymbol$[rbp-169]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rax], r12b
$LN522@newStreamW:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1160 :   if (pre > 17) pre = 17;

	mov	eax, 17
	cmp	esi, eax
	cmova	esi, eax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	edi, 15
	mov	QWORD PTR endingLineFeedSymbol$[rbp-145], rdi

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR endingLineFeedSymbol$[rbp-153], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR endingLineFeedSymbol$[rbp-169], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1164 :       colonSymbol, nullSymbol, endingLineFeedSymbol, usf, pre);

	mov	ecx, 224				; 000000e0H
	call	QWORD PTR __imp_??2@YAPEAX_K@Z
	mov	rbx, rax
	mov	QWORD PTR $T1[rsp], rax
	test	rax, rax
	je	$LN12@newStreamW

; 898  : }
; 899  : int BuiltStyledStreamWriter::write(Value const& root, JSONCPP_OSTREAM* sout)
; 900  : {
; 901  :   sout_ = sout;
; 902  :   addChildValues_ = false;
; 903  :   indented_ = true;
; 904  :   indentString_.clear();
; 905  :   writeCommentBeforeValue(root);
; 906  :   if (!indented_) writeIndent();
; 907  :   indented_ = true;
; 908  :   writeValue(root);
; 909  :   writeCommentAfterValueOnSameLine(root);
; 910  :   *sout_ << endingLineFeedSymbol_;
; 911  :   sout_ = NULL;
; 912  :   return 0;
; 913  : }
; 914  : void BuiltStyledStreamWriter::writeValue(Value const& value) {
; 915  :   switch (value.type()) {
; 916  :   case nullValue:
; 917  :     pushValue(nullSymbol_);
; 918  :     break;
; 919  :   case intValue:
; 920  :     pushValue(valueToString(value.asLargestInt()));
; 921  :     break;
; 922  :   case uintValue:
; 923  :     pushValue(valueToString(value.asLargestUInt()));
; 924  :     break;
; 925  :   case realValue:
; 926  :     pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_));
; 927  :     break;
; 928  :   case stringValue:
; 929  :   {
; 930  :     // Is NULL is possible for value.string_? No.
; 931  :     char const* str;
; 932  :     char const* end;
; 933  :     bool ok = value.getString(&str, &end);
; 934  :     if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end-str)));
; 935  :     else pushValue("");
; 936  :     break;
; 937  :   }
; 938  :   case booleanValue:
; 939  :     pushValue(valueToString(value.asBool()));
; 940  :     break;
; 941  :   case arrayValue:
; 942  :     writeArrayValue(value);
; 943  :     break;
; 944  :   case objectValue: {
; 945  :     Value::Members members(value.getMemberNames());
; 946  :     if (members.empty())
; 947  :       pushValue("{}");
; 948  :     else {
; 949  :       writeWithIndent("{");
; 950  :       indent();
; 951  :       Value::Members::iterator it = members.begin();
; 952  :       for (;;) {
; 953  :         JSONCPP_STRING const& name = *it;
; 954  :         Value const& childValue = value[name];
; 955  :         writeCommentBeforeValue(childValue);
; 956  :         writeWithIndent(valueToQuotedStringN(name.data(), static_cast<unsigned>(name.length())));
; 957  :         *sout_ << colonSymbol_;
; 958  :         writeValue(childValue);
; 959  :         if (++it == members.end()) {
; 960  :           writeCommentAfterValueOnSameLine(childValue);
; 961  :           break;
; 962  :         }
; 963  :         *sout_ << ",";
; 964  :         writeCommentAfterValueOnSameLine(childValue);
; 965  :       }
; 966  :       unindent();
; 967  :       writeWithIndent("}");
; 968  :     }
; 969  :   } break;
; 970  :   }
; 971  : }
; 972  : 
; 973  : void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
; 974  :   unsigned size = value.size();
; 975  :   if (size == 0)
; 976  :     pushValue("[]");
; 977  :   else {
; 978  :     bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
; 979  :     if (isMultiLine) {
; 980  :       writeWithIndent("[");
; 981  :       indent();
; 982  :       bool hasChildValue = !childValues_.empty();
; 983  :       unsigned index = 0;
; 984  :       for (;;) {
; 985  :         Value const& childValue = value[index];
; 986  :         writeCommentBeforeValue(childValue);
; 987  :         if (hasChildValue)
; 988  :           writeWithIndent(childValues_[index]);
; 989  :         else {
; 990  :           if (!indented_) writeIndent();
; 991  :           indented_ = true;
; 992  :           writeValue(childValue);
; 993  :           indented_ = false;
; 994  :         }
; 995  :         if (++index == size) {
; 996  :           writeCommentAfterValueOnSameLine(childValue);
; 997  :           break;
; 998  :         }
; 999  :         *sout_ << ",";
; 1000 :         writeCommentAfterValueOnSameLine(childValue);
; 1001 :       }
; 1002 :       unindent();
; 1003 :       writeWithIndent("]");
; 1004 :     } else // output on a single line
; 1005 :     {
; 1006 :       assert(childValues_.size() == size);
; 1007 :       *sout_ << "[";
; 1008 :       if (!indentation_.empty()) *sout_ << " ";
; 1009 :       for (unsigned index = 0; index < size; ++index) {
; 1010 :         if (index > 0)
; 1011 :           *sout_ << ((!indentation_.empty()) ? ", " : ",");
; 1012 :         *sout_ << childValues_[index];
; 1013 :       }
; 1014 :       if (!indentation_.empty()) *sout_ << " ";
; 1015 :       *sout_ << "]";
; 1016 :     }
; 1017 :   }
; 1018 : }
; 1019 : 
; 1020 : bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
; 1021 :   ArrayIndex const size = value.size();
; 1022 :   bool isMultiLine = size * 3 >= rightMargin_;
; 1023 :   childValues_.clear();
; 1024 :   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
; 1025 :     Value const& childValue = value[index];
; 1026 :     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
; 1027 :                         childValue.size() > 0);
; 1028 :   }
; 1029 :   if (!isMultiLine) // check if line length > max line length
; 1030 :   {
; 1031 :     childValues_.reserve(size);
; 1032 :     addChildValues_ = true;
; 1033 :     ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
; 1034 :     for (ArrayIndex index = 0; index < size; ++index) {
; 1035 :       if (hasCommentForValue(value[index])) {
; 1036 :         isMultiLine = true;
; 1037 :       }
; 1038 :       writeValue(value[index]);
; 1039 :       lineLength += static_cast<ArrayIndex>(childValues_[index].length());
; 1040 :     }
; 1041 :     addChildValues_ = false;
; 1042 :     isMultiLine = isMultiLine || lineLength >= rightMargin_;
; 1043 :   }
; 1044 :   return isMultiLine;
; 1045 : }
; 1046 : 
; 1047 : void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
; 1048 :   if (addChildValues_)
; 1049 :     childValues_.push_back(value);
; 1050 :   else
; 1051 :     *sout_ << value;
; 1052 : }
; 1053 : 
; 1054 : void BuiltStyledStreamWriter::writeIndent() {
; 1055 :   // blep intended this to look at the so-far-written string
; 1056 :   // to determine whether we are already indented, but
; 1057 :   // with a stream we cannot do that. So we rely on some saved state.
; 1058 :   // The caller checks indented_.
; 1059 : 
; 1060 :   if (!indentation_.empty()) {
; 1061 :     // In this case, drop newlines too.
; 1062 :     *sout_ << '\n' << indentString_;
; 1063 :   }
; 1064 : }
; 1065 : 
; 1066 : void BuiltStyledStreamWriter::writeWithIndent(JSONCPP_STRING const& value) {
; 1067 :   if (!indented_) writeIndent();
; 1068 :   *sout_ << value;
; 1069 :   indented_ = false;
; 1070 : }
; 1071 : 
; 1072 : void BuiltStyledStreamWriter::indent() { indentString_ += indentation_; }
; 1073 : 
; 1074 : void BuiltStyledStreamWriter::unindent() {
; 1075 :   assert(indentString_.size() >= indentation_.size());
; 1076 :   indentString_.resize(indentString_.size() - indentation_.size());
; 1077 : }
; 1078 : 
; 1079 : void BuiltStyledStreamWriter::writeCommentBeforeValue(Value const& root) {
; 1080 :   if (cs_ == CommentStyle::None) return;
; 1081 :   if (!root.hasComment(commentBefore))
; 1082 :     return;
; 1083 : 
; 1084 :   if (!indented_) writeIndent();
; 1085 :   const JSONCPP_STRING& comment = root.getComment(commentBefore);
; 1086 :   JSONCPP_STRING::const_iterator iter = comment.begin();
; 1087 :   while (iter != comment.end()) {
; 1088 :     *sout_ << *iter;
; 1089 :     if (*iter == '\n' &&
; 1090 :        (iter != comment.end() && *(iter + 1) == '/'))
; 1091 :       // writeIndent();  // would write extra newline
; 1092 :       *sout_ << indentString_;
; 1093 :     ++iter;
; 1094 :   }
; 1095 :   indented_ = false;
; 1096 : }
; 1097 : 
; 1098 : void BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine(Value const& root) {
; 1099 :   if (cs_ == CommentStyle::None) return;
; 1100 :   if (root.hasComment(commentAfterOnSameLine))
; 1101 :     *sout_ << " " + root.getComment(commentAfterOnSameLine);
; 1102 : 
; 1103 :   if (root.hasComment(commentAfter)) {
; 1104 :     writeIndent();
; 1105 :     *sout_ << root.getComment(commentAfter);
; 1106 :   }
; 1107 : }
; 1108 : 
; 1109 : // static
; 1110 : bool BuiltStyledStreamWriter::hasCommentForValue(const Value& value) {
; 1111 :   return value.hasComment(commentBefore) ||
; 1112 :          value.hasComment(commentAfterOnSameLine) ||
; 1113 :          value.hasComment(commentAfter);
; 1114 : }
; 1115 : 
; 1116 : ///////////////
; 1117 : // StreamWriter
; 1118 : 
; 1119 : StreamWriter::StreamWriter()
; 1120 :     : sout_(NULL)
; 1121 : {

	mov	QWORD PTR [rax+8], r12

; 897  : {

	lea	rax, OFFSET FLAT:??_7BuiltStyledStreamWriter@Json@@6B@
	mov	QWORD PTR [rbx], rax
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rbx+16], r12

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rbx+24], r12

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rbx+32], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+64], rdi

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+56], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx+40], 0
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 897  : {

	mov	DWORD PTR [rbx+72], 74			; 0000004aH
	lea	rcx, QWORD PTR [rbx+80]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], rdi

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR indentation$[rbp-169]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 897  : {

	mov	DWORD PTR [rbx+112], r14d
	lea	rcx, QWORD PTR [rbx+120]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], rdi

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR colonSymbol$[rbp-169]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 897  : {

	lea	rcx, QWORD PTR [rbx+152]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], rdi

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR nullSymbol$[rbp-169]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 897  : {

	lea	rcx, QWORD PTR [rbx+184]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], rdi

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR endingLineFeedSymbol$[rbp-169]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 897  : {

	and	BYTE PTR [rbx+216], 248			; 000000f8H
	and	r13b, 1
	shl	r13b, 2
	or	BYTE PTR [rbx+216], r13b
	mov	DWORD PTR [rbx+220], esi

; 1164 :       colonSymbol, nullSymbol, endingLineFeedSymbol, usf, pre);

	mov	rdi, QWORD PTR endingLineFeedSymbol$[rbp-145]
	jmp	SHORT $LN13@newStreamW
$LN12@newStreamW:
	mov	rbx, r12
$LN13@newStreamW:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	rdi, 16
	jb	SHORT $LN807@newStreamW
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR endingLineFeedSymbol$[rbp-169]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
	npad	1
$LN807@newStreamW:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR nullSymbol$[rbp-145], 16
	jb	SHORT $LN839@newStreamW
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR nullSymbol$[rbp-169]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN839@newStreamW:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR nullSymbol$[rbp-145], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR nullSymbol$[rbp-153], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR nullSymbol$[rbp-169], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR colonSymbol$[rbp-145], 16
	jb	SHORT $LN871@newStreamW
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR colonSymbol$[rbp-169]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN871@newStreamW:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR colonSymbol$[rbp-145], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR colonSymbol$[rbp-153], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR colonSymbol$[rbp-169], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR cs_str$[rbp-145], 16
	jb	SHORT $LN903@newStreamW
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR cs_str$[rbp-169]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN903@newStreamW:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR cs_str$[rbp-145], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR cs_str$[rbp-153], r12
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR cs_str$[rbp-169], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR indentation$[rbp-145], 16
	jb	SHORT $LN935@newStreamW
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR indentation$[rbp-169]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN935@newStreamW:
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1164 :       colonSymbol, nullSymbol, endingLineFeedSymbol, usf, pre);

	mov	rax, rbx
	jmp	SHORT $LN10@newStreamW
$LN7@newStreamW:
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rbp-145], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rbp-153], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rbp-169], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 36					; 00000024H
	lea	rdx, OFFSET FLAT:??_C@_0CF@BGMIIABI@commentStyle?5must?5be?5?8All?8?5or?5?8N@
	lea	rcx, QWORD PTR $T3[rbp-169]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File e:\jsoncpp-master\src\lib_json\json_writer.cpp

; 1148 :     throwRuntimeError("commentStyle must be 'All' or 'None'");

	lea	rcx, QWORD PTR $T3[rbp-169]
	call	?throwRuntimeError@Json@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::throwRuntimeError
	npad	1
$LN10@newStreamW:

; 1165 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-169]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN947@newStreamW:
?newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ ENDP ; Json::StreamWriterBuilder::newStreamWriter
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$7@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$7
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$7@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$0@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$0
	lea	rcx, QWORD PTR indentation$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$13@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$13
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$13@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$1@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$1
	lea	rcx, QWORD PTR cs_str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$19@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$19
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$19@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$25@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$25
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$25@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$31@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$31
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$31@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$31
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$37@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$37
	push	rbp
	mov	rbp, rdx
	mov	eax, DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??nullSingleton@Value@Json@@SAAEBV23@XZ@4IA, eax
	pop	rbp
	ret	0
?dtor$37@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$37
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$2@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$2
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$3@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$3
	lea	rcx, QWORD PTR colonSymbol$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$4@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$4
	lea	rcx, QWORD PTR nullSymbol$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$5@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$5
	lea	rcx, QWORD PTR endingLineFeedSymbol$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$6@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$6
	mov	rcx, QWORD PTR $T1[rdx]
	rex_jmp	QWORD PTR __imp_??3@YAXPEAX@Z
?dtor$6@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$43@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$43
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1StreamWriter@Json@@UEAA@XZ		; Json::StreamWriter::~StreamWriter
?dtor$43@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$43
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$44@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$44
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 16
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$44@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$44
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$45@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$45
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$45@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$45
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$46@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$46
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 80					; 00000050H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$46@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$46
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$47@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$47
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 120				; 00000078H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$47@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$47
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
nullSymbol$ = 48
colonSymbol$ = 80
endingLineFeedSymbol$ = 112
$T3 = 112
cs_str$ = 144
indentation$ = 176
__$ArrayPad$ = 208
this$ = 272
?dtor$48@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA PROC ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$48
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 152				; 00000098H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$48@?0??newStreamWriter@StreamWriterBuilder@Json@@UEBAPEAVStreamWriter@2@XZ@4HA ENDP ; `Json::StreamWriterBuilder::newStreamWriter'::`1'::dtor$48
text$x	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator++, COMDAT

; 103  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 104  : 		if (this->_Getcont() == 0
; 105  : 			|| this->_Ptr == 0
; 106  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 107  : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 108  : 			{	// report error
; 109  : 			_DEBUG_ERROR("string iterator not incrementable");
; 110  : 			_SCL_SECURE_OUT_OF_RANGE;
; 111  : 			}
; 112  : 
; 113  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 114  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 115  : 		_SCL_SECURE_VALIDATE_RANGE(
; 116  : 			this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 117  : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 118  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 119  : 
; 120  : 		++this->_Ptr;

	inc	QWORD PTR [rcx]

; 121  : 		return (*this);

	mov	rax, rcx

; 122  : 		}

	ret	0
??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$dead$ = 24
??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator+, COMDAT

; 180  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	inc	rax

; 186  : 		_Myiter _Tmp = *this;
; 187  : 		return (_Tmp += _Off);

	mov	QWORD PTR [rdx], rax
	mov	rax, rdx

; 188  : 		}

	ret	0
??H?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator!=, COMDAT

; 215  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx

; 220  : 		return (!(*this == _Right));

	setne	al

; 221  : 		}

	ret	0
??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT ??$isfinite@N@@YA_NN@Z
_TEXT	SEGMENT
_X$ = 48
_X$ = 48
??$isfinite@N@@YA_NN@Z PROC				; isfinite<double>, COMDAT

; 414  : {

$LN6:
	sub	rsp, 40					; 00000028H

; 311  :     return (_dtest(&_X));

	lea	rcx, QWORD PTR _X$[rsp]

; 415  :     return (fpclassify(_X) <= 0);

	movsdx	QWORD PTR _X$[rsp], xmm0

; 311  :     return (_dtest(&_X));

	call	QWORD PTR __imp__dtest

; 415  :     return (fpclassify(_X) <= 0);

	test	ax, ax
	setle	al

; 416  : }

	add	rsp, 40					; 00000028H
	ret	0
??$isfinite@N@@YA_NN@Z ENDP				; isfinite<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip
;	COMDAT ??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Ch$dead$ = 16
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z PROC		; std::setfill<char>, COMDAT

; 25   : 		{	// construct from fill character

	mov	BYTE PTR [rcx], 48			; 00000030H

; 35   : 	return (_Fillobj<_Elem>(_Ch));

	mov	rax, rcx

; 36   : 	}

	ret	0
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z ENDP		; std::setfill<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip
;	COMDAT ??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z
_TEXT	SEGMENT
_Ostr$ = 8
_Manip$ = 16
??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,char>, COMDAT

; 59   : 	static_assert((is_same<_Elem, _Elem2>::value),
; 60   : 		"wrong character type for setfill");
; 61   : 
; 62   : 	_Ostr.fill(_Manip._Fill);

	mov	rax, QWORD PTR [rcx]
	movsxd	r8, DWORD PTR [rax+4]
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 115  : 		_Fillch = _Newfill;

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8+rcx+88], al
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip

; 63   : 	return (_Ostr);

	mov	rax, rcx

; 64   : 	}

	ret	0
??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip
;	COMDAT ??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z
_TEXT	SEGMENT
_Ostr$ = 48
_Manip$ = 56
??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,__int64>, COMDAT

; 276  : 	{	// insert by calling function with output stream and argument

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 277  : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	test	rcx, rcx
	jne	SHORT $LN3@operator
	mov	rdx, QWORD PTR [rdx+8]
	call	QWORD PTR [r8]

; 278  : 	return (_Ostr);

	mov	rax, rbx

; 279  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@operator:

; 277  : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rdx+8]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR [r8]

; 278  : 	return (_Ostr);

	mov	rax, rbx

; 279  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iomanip
;	COMDAT ??0?$_Fillobj@D@std@@QEAA@D@Z
_TEXT	SEGMENT
this$ = 8
_Ch$dead$ = 16
??0?$_Fillobj@D@std@@QEAA@D@Z PROC			; std::_Fillobj<char>::_Fillobj<char>, COMDAT

; 25   : 		{	// construct from fill character

	mov	BYTE PTR [rcx], 48			; 00000030H

; 26   : 		}

	mov	rax, rcx
	ret	0
??0?$_Fillobj@D@std@@QEAA@D@Z ENDP			; std::_Fillobj<char>::_Fillobj<char>
_TEXT	ENDS
END
